<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"littlefxc.gitee.io","root":"/blog/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="littlefxc&#39;s blog">
<meta property="og:url" content="https://littlefxc.gitee.io/blog/index.html">
<meta property="og:site_name" content="littlefxc&#39;s blog">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="littlefxc&#39;s blog">

<link rel="canonical" href="https://littlefxc.gitee.io/blog/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>littlefxc's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">littlefxc's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/blog/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/littlefxc" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://littlefxc.gitee.io/blog/passages/Java中锁的分类和特点/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="冯雪超">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="littlefxc's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/passages/Java中锁的分类和特点/" class="post-title-link" itemprop="url">Java中锁的分类和特点</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-24 09:11:19" itemprop="dateCreated datePublished" datetime="2021-02-24T09:11:19+08:00">2021-02-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://littlefxc.gitee.io/blog/passages/JVM-调优/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="冯雪超">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="littlefxc's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/passages/JVM-调优/" class="post-title-link" itemprop="url">JVM 调优</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-23 20:49:45" itemprop="dateCreated datePublished" datetime="2021-02-23T20:49:45+08:00">2021-02-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-24 22:27:54" itemprop="dateModified" datetime="2021-02-24T22:27:54+08:00">2021-02-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h1 id="1-理论"><a href="#1-理论" class="headerlink" title="1 理论"></a>1 理论</h1><h2 id="1-1-内存结构"><a href="#1-1-内存结构" class="headerlink" title="1.1 内存结构"></a>1.1 内存结构</h2><p><img src="https://gitee.com/littlefxc/oss/raw/master/images/JVM内存结构.png" alt="https://gitee.com/littlefxc/oss/raw/master/images/JVM内存结构.png"></p>
<ul>
<li>线程共享：堆，方法区</li>
<li>线程隔离：虚拟机栈，本地方法栈，程序计数器</li>
</ul>
<h3 id="1-1-1-堆"><a href="#1-1-1-堆" class="headerlink" title="1.1.1 堆"></a>1.1.1 堆</h3><p>堆又做了细分如下图所示：</p>
<p><img src="https://gitee.com/littlefxc/oss/raw/master/images/JVM内存结构-堆.png" alt="https://gitee.com/littlefxc/oss/raw/master/images/JVM内存结构-堆.png"></p>
<p>JDK8 之前堆分为新生代、老年代和持久代（也叫永久代），其中新生代中又有伊甸园和存活区，而存活区又分为 “From survivor” 和 “To survivor”。</p>
<p>JDK8 之后，持久代被废弃，由元空间代替，而元空间并不是堆内存的一部分，元空间是本地内存。</p>
<h3 id="1-1-2-虚拟机栈"><a href="#1-1-2-虚拟机栈" class="headerlink" title="1.1.2 虚拟机栈"></a>1.1.2 虚拟机栈</h3><p>虚拟机栈是线程独享的，当创建一个现成的时候就会创建虚拟机栈。</p>
<p><img src="https://gitee.com/littlefxc/oss/raw/master/images/JVM内存结构-虚拟机栈.png" alt="https://gitee.com/littlefxc/oss/raw/master/images/JVM内存结构-虚拟机栈.png"></p>
<ul>
<li>虚拟机栈由栈帧组成。</li>
<li>每一次方法调用都会创建一个栈帧，然后去压栈。</li>
<li>方法返回的时候代表栈帧的出栈操作。</li>
<li>栈帧里面包含一系列数据：局部变量表、操作数栈、指向运行时常量池的引用、方法返回地址和动态链接</li>
</ul>
<h3 id="1-1-2-本地方法栈"><a href="#1-1-2-本地方法栈" class="headerlink" title="1.1.2 本地方法栈"></a>1.1.2 本地方法栈</h3><p>虚拟机栈中放的是Java 方法，而本地方法栈放的是 native 方法（如 UnSafe类）。</p>
<h3 id="1-1-4-程序计数器"><a href="#1-1-4-程序计数器" class="headerlink" title="1.1.4 程序计数器"></a>1.1.4 程序计数器</h3><p>程序计数器用来记录各个字节码执行的字节码的地址，像分支、循环、跳转、异常、线程恢复等等操作都需依赖程序计数器。</p>
<ul>
<li><p><strong>为什么需要程序计数器?</strong></p>
<p>这是因为Java 是个多线程语言，当执行的线程数量超过CPU核心的时候，线程之间就会根据时间片争抢CPU资源。例如，某个线程它的任务还没有执行完成，CPU 就被其它线程抢走，如果之后又轮到这个线程执行任务，那么就得知道从哪里继续执行任务，所以会为每一个线程分配一个程序计数器，用来记录它下一条指令是什么等等。</p>
</li>
</ul>
<h3 id="1-1-5-方法区"><a href="#1-1-5-方法区" class="headerlink" title="1.1.5 方法区"></a>1.1.5 方法区</h3><p><img src="https://gitee.com/littlefxc/oss/raw/master/images/JVM内存结构-方法区.png" alt="https://gitee.com/littlefxc/oss/raw/master/images/JVM内存结构-方法区.png"></p>
<p>方法区主要包括 4 个部分：类信息、运行时常量池、字符串常量池和静态变量。</p>
<p>方法区主要存放的是虚拟机加载的类相关的信息。</p>
<p>从上图中可以看到好几种常量池：静态常量池、运行时常量池和字符串常量池。下面来分析一下这 3 种常量池的作用：</p>
<ul>
<li><p>静态常量池</p>
<p> 也叫 class 文件常量池，主要用来存放：</p>
<ul>
<li>字面量：例如，文本字符串、final 修饰的常量</li>
<li>符号引用：例如，类和接口的全限定名、字段的名称和描述符、方法的名称和描述符</li>
</ul>
</li>
<li><p>运行时常量池</p>
<p> 当类加载到内存中后，JVM 就会将静态常量池中的内容存放到运行时的常量池中。运行时常量池里面存储的主要是编译期间生成的字面量、符号引用等等。</p>
</li>
<li><p>字符串常量池</p>
<p> 也可以理解称运行时常量池分出来的一部分，类加载到内存的时候，字符串会存到字符串常量池里面</p>
</li>
</ul>
<p><strong>为什么要用元空间代替持久代？</strong></p>
<ul>
<li><p>一方面是 Orcale 把 Hotspot 虚拟机和 JRockit 虚拟机收购了，而 JRockit 虚拟机压根就没有永久代的概念。于是为了融合Hotspot 虚拟机和 JRockit 虚拟机，干脆就把它去掉了</p>
</li>
<li><p>另一方面是持久代在使用过程中还是很容易发生故障的</p>
<p>相信很多人都遇到过这种异常 <code>java.lang.OutOfMemoryError: PermGen</code>。在之前的版本中，字符串常量池存在于永久代中，在大量使用字符串的情况下，非常容易出现OOM的异常。此外，J<strong>VM加载的class的总数，方法的大小</strong>等都很难确定，因此对永久代大小的指定难以确定。太小的永久代容易导致永久代内存溢出，太大的永久代则容易导致虚拟机内存紧张。</p>
</li>
<li><p>元空间(Metaspace)，不再与堆连续，而是直接存在于本地内存中，也就是机器的内存。理论上机器内存有多大，元空间的野心就有多大。</p>
</li>
</ul>
<p>当然，还有很多更多深层次的原因，可以参考这篇博文<a href="https://www.cnblogs.com/duanxz/p/3520829.html" target="_blank" rel="noopener">Metaspace 之一：Metaspace整体介绍（永久代被替换原因、元空间特点、元空间内存查看分析方法）</a></p>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JVMTest1</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Demo demo = <span class="keyword">new</span> Demo(<span class="string">"aaa"</span>);</span><br><span class="line">    demo.printName();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Demo</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码的内存分布大致是这样的：</p>
<p><img src="https://gitee.com/littlefxc/oss/raw/master/images/image-20210223220317252.png" alt="image-20210223220317252"></p>
<ol>
<li><p>在启动的时候首先将类加载到方法区，要加载两个类分别是 JVMTest1.class 和 Demo.class 。</p>
</li>
<li><p>当创建 Demo 对象的时候，首先会创建一个局部变量 demo 放在栈里面并指向到一个引用，而真正的 Demo 对象会存储到堆里面。</p>
</li>
<li><p>最后执行 printName 方法。</p>
</li>
</ol>
<h2 id="1-2-类加载机制"><a href="#1-2-类加载机制" class="headerlink" title="1.2 类加载机制"></a>1.2 类加载机制</h2><p><img src="https://gitee.com/littlefxc/oss/raw/master/images/类加载过程详解.png" alt="https://gitee.com/littlefxc/oss/raw/master/images/类加载过程详解.png"></p>
<h3 id="1-2-1-编译"><a href="#1-2-1-编译" class="headerlink" title="1.2.1 编译"></a>1.2.1 编译</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac JVMTest1.java</span><br></pre></td></tr></table></figure>
<p>结果产生了两个 class 文件，如下所示：</p>
<p>JVMTest1.class</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Source code recreated from a .class file by IntelliJ IDEA</span></span><br><span class="line"><span class="comment">// (powered by Fernflower decompiler)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.fengxuechao.jvm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JVMTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JVMTest1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] var0)</span> </span>&#123;</span><br><span class="line">        Demo var1 = <span class="keyword">new</span> Demo(<span class="string">"aaa"</span>);</span><br><span class="line">        var1.printName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Demo.class</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Source code recreated from a .class file by IntelliJ IDEA</span></span><br><span class="line"><span class="comment">// (powered by Fernflower decompiler)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.fengxuechao.jvm;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Demo</span><span class="params">(String var1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = var1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>反编译</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -v -p Demo &gt; a.txt</span><br></pre></td></tr></table></figure>
<p>反编译结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">// 描述信息</span><br><span class="line">Classfile /Users/fengxuechao/WorkSpace/IdeaProjects/foodie/jvm/src/main/java/com/fengxuechao/jvm/Demo.class</span><br><span class="line">  Last modified 2021-2-24; size 461 bytes</span><br><span class="line">  MD5 checksum 4232b9a7f5bc219b5c632adabd643a3d</span><br><span class="line">  Compiled from &quot;JVMTest1.java&quot;</span><br><span class="line">// 描述信息</span><br><span class="line">class com.fengxuechao.jvm.Demo</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: ACC_SUPER</span><br><span class="line">// 常量池</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #6.#17         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Fieldref           #5.#18         // com/fengxuechao/jvm/Demo.name:Ljava/lang/String;</span><br><span class="line">   #3 = Fieldref           #19.#20        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #4 = Methodref          #21.#22        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">   #5 = Class              #23            // com/fengxuechao/jvm/Demo</span><br><span class="line">   #6 = Class              #24            // java/lang/Object</span><br><span class="line">   #7 = Utf8               name</span><br><span class="line">   #8 = Utf8               Ljava/lang/String;</span><br><span class="line">   #9 = Utf8               &lt;init&gt;</span><br><span class="line">  #10 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">  #11 = Utf8               Code</span><br><span class="line">  #12 = Utf8               LineNumberTable</span><br><span class="line">  #13 = Utf8               printName</span><br><span class="line">  #14 = Utf8               ()V</span><br><span class="line">  #15 = Utf8               SourceFile</span><br><span class="line">  #16 = Utf8               JVMTest1.java</span><br><span class="line">  #17 = NameAndType        #9:#14         // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #18 = NameAndType        #7:#8          // name:Ljava/lang/String;</span><br><span class="line">  #19 = Class              #25            // java/lang/System</span><br><span class="line">  #20 = NameAndType        #26:#27        // out:Ljava/io/PrintStream;</span><br><span class="line">  #21 = Class              #28            // java/io/PrintStream</span><br><span class="line">  #22 = NameAndType        #29:#10        // println:(Ljava/lang/String;)V</span><br><span class="line">  #23 = Utf8               com/fengxuechao/jvm/Demo</span><br><span class="line">  #24 = Utf8               java/lang/Object</span><br><span class="line">  #25 = Utf8               java/lang/System</span><br><span class="line">  #26 = Utf8               out</span><br><span class="line">  #27 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #28 = Utf8               java/io/PrintStream</span><br><span class="line">  #29 = Utf8               println</span><br><span class="line">// 字段信息</span><br><span class="line">&#123;</span><br><span class="line">  private java.lang.String name;</span><br><span class="line">    descriptor: Ljava/lang/String;</span><br><span class="line">    flags: ACC_PRIVATE</span><br><span class="line">// 方法的信息</span><br><span class="line">  public com.fengxuechao.jvm.Demo(java.lang.String);</span><br><span class="line">    descriptor: (Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=2, args_size=2</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: aload_0</span><br><span class="line">         5: aload_1</span><br><span class="line">         6: putfield      #2                  // Field name:Ljava/lang/String;</span><br><span class="line">         9: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 16: 0</span><br><span class="line">        line 17: 4</span><br><span class="line">        line 18: 9</span><br><span class="line"></span><br><span class="line">  public void printName();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=1, args_size=1</span><br><span class="line">         0: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: aload_0</span><br><span class="line">         4: getfield      #2                  // Field name:Ljava/lang/String;</span><br><span class="line">         7: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">        10: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 21: 0</span><br><span class="line">        line 22: 10</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;JVMTest1.java&quot;</span><br></pre></td></tr></table></figure>
<p>指令参考：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jvms/se8/html/index.html</a></p>
<h3 id="1-2-2-加载"><a href="#1-2-2-加载" class="headerlink" title="1.2.2 加载"></a>1.2.2 加载</h3><ul>
<li><p>JVM 是如何加载 class 文件的呢？</p>
<p>当一个类被创建实例或者被引用到的时候, 如果虚拟机发现之前没有加载过这个类，就会通过类加载器（也就是 ClassLoader ）把 class 文件加载到内存。</p>
<p>在加载的过程中主要做了 3 件事：</p>
<ol>
<li>读取类的二进制流。</li>
<li>把二进制流转为方法区数据结构，并存放到方法区。</li>
<li>最后，在 Java 堆中产生 java.lang.Class 对象。</li>
</ol>
<p>文档参考：<a href="https://www.cnblogs.com/williamjie/p/11167920.html" target="_blank" rel="noopener">描述一下JVM加载class文件的原理机制</a></p>
</li>
</ul>
<h3 id="1-2-3-链接"><a href="#1-2-3-链接" class="headerlink" title="1.2.3 链接"></a>1.2.3 链接</h3><p>class 文件加载完成后，会进入“链接”这个步骤，链接这个步骤又可以分为“验证”、“准备”和“解析”。</p>
<h4 id="1-2-3-1-验证"><a href="#1-2-3-1-验证" class="headerlink" title="1.2.3.1 验证"></a>1.2.3.1 验证</h4><p>验证——顾名思义，就是验证 class 文件是不是符合规范，这里面包含了多个层次的验证，包括：</p>
<ul>
<li><p>文件格式的验证</p>
<ul>
<li>是否以 <code>0xCAFEBABE</code> 开头（可以用 16 进制编辑器打开查看）</li>
<li>版本好是否合理</li>
</ul>
</li>
<li><p>元数据验证</p>
<ul>
<li>是否有父类</li>
<li>是否继承了 final 类（final 类是不能被继承的，如果继承了，那就是有问题）</li>
<li>非抽象类是否实现了所有抽象方法（没有，那就是有问题）</li>
</ul>
</li>
<li><p>字节码验证</p>
<p>字节码的验证是非常复杂的，一个 class 文件能够通过字节码验证并不代表它没有问题，但是如果它没有通过字节码验证，那就一定有问题。</p>
<ul>
<li>运行检查</li>
<li>栈数据类型和操作码操作参数吻合（比如栈空间只有 2 字节，但其实却需要大于 2 字节，此时就认为这个字节码是有问题的）</li>
<li>跳转指令是不是指向合理的位置</li>
</ul>
</li>
<li><p>符号引用验证</p>
<ul>
<li>常量池中描述类是否存在</li>
<li>访问的方法或字段是否存在且有足够的权限</li>
</ul>
</li>
<li><p>如果事先已经确认代码是安全无误的可以在启动的时候用<code>-Xverify:none</code>关闭验证。</p>
</li>
</ul>
<h4 id="1-2-3-2-准备"><a href="#1-2-3-2-准备" class="headerlink" title="1.2.3.2 准备"></a>1.2.3.2 准备</h4><p>如果通过验证发现没有问题的话，就会进入准备环节。</p>
<p>准备环节的作用：</p>
<ul>
<li>为类的静态变量分配内存，初始化为系统的初始值<ul>
<li>final static 修饰的变量：直接赋值为用户定义的值，比如 <code>private final static int value =123</code>，直接赋值 123。</li>
<li>但是 <code>private static int value = 123</code>, 该阶段的值依然是 0。</li>
</ul>
</li>
</ul>
<h4 id="1-2-3-3-解析"><a href="#1-2-3-3-解析" class="headerlink" title="1.2.3.3 解析"></a>1.2.3.3 解析</h4><p>“准备”完成后，就可以进入解析了。</p>
<p>解析的作用：把符号引用转换成直接引用。</p>
<ul>
<li><p>什么是符号引用？</p>
<p>符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能够无歧义的定位到目标即可。例如，在Class文件中它以CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等类型的常量出现。符号引用与虚拟机的内存布局无关，引用的目标并不一定加载到内存中。在Java中，一个java类将会编译成一个class文件。在编译时，java类并不知道所引用的类的实际地址，因此只能使用符号引用来代替。比如org.simple.People类引用了org.simple.Language类，在编译时People类并不知道Language类的实际内存地址，因此只能使用符号org.simple.Language（假设是这个，当然实际中是由类似于CONSTANT_Class_info的常量来表示的）来表示Language类的地址。各种虚拟机实现的内存布局可能有所不同，但是它们能接受的符号引用都是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。</p>
<p><img src="https://gitee.com/littlefxc/oss/raw/master/images/image-20210224212914755.png" alt="image-20210224212914755"></p>
</li>
<li><p>什么是直接引用？</p>
<p>可以是</p>
<ul>
<li>直接指向目标的指针（比如，指向“类型”【Class对象】、类变量、类方法的直接引用可能是指向方法区的指针）</li>
<li>相对偏移量（比如，指向实例变量、实例方法的直接引用都是偏移量）</li>
<li>一个能间接定位到目标的句柄</li>
</ul>
<p>直接引用是和虚拟机的布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经被加载入内存中了。</p>
</li>
</ul>
<h4 id="1-2-4-初始化"><a href="#1-2-4-初始化" class="headerlink" title="1.2.4 初始化"></a>1.2.4 初始化</h4><p>解析完成之后，就会进入初始化这个阶段。在这个阶段，JVM首先会执行 <clinit> 方法，clinit 方法由编译器自动收集里面的所有静态变量赋值动作和静态语句块合并而成，也叫类构造器方法</clinit></p>
<ul>
<li>初始化的顺序和源文件中的顺序一致</li>
<li>子类的 <clinit> 被调用前，会先调用父类的 <clinit></clinit></clinit></li>
<li>JVM 会保证 clinit 方法的线程安全性</li>
</ul>
<p>示例1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class JVMTest2 &#123;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;JVMTest2 静态块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;JVMTest2 构造块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public JVMTest2() &#123;</span><br><span class="line">        System.out.println(&quot;JVMTest2 构造方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;JVMTest2 main() 方法&quot;);</span><br><span class="line">        new JVMTest2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JVMTest2 静态块</span><br><span class="line">JVMTest2 main() 方法</span><br><span class="line">JVMTest2 构造块</span><br><span class="line">JVMTest2 构造方法</span><br></pre></td></tr></table></figure>
<p>示例2:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JVMTest3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"JVMTest3 静态块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"JVMTest3 构造块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JVMTest3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"JVMTest3 构造方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"JVMTest3 main() 方法"</span>);</span><br><span class="line">        <span class="keyword">new</span> Sub();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Super 静态块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"Super 构造块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Super</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Super 构造方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Sub 静态块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"Sub 构造块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sub</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Sub 构造方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">JVMTest3 静态块</span><br><span class="line">JVMTest3 main() 方法</span><br><span class="line">Super 静态块</span><br><span class="line">Sub 静态块</span><br><span class="line">Super 构造块</span><br><span class="line">Super 构造方法</span><br><span class="line">Sub 构造块</span><br><span class="line">Sub 构造方法</span><br></pre></td></tr></table></figure>
<h3 id="1-2-5-使用"><a href="#1-2-5-使用" class="headerlink" title="1.2.5 使用"></a>1.2.5 使用</h3><p>初始化完成之后就可以使用这个类了。</p>
<h3 id="1-2-6-卸载"><a href="#1-2-6-卸载" class="headerlink" title="1.2.6 卸载"></a>1.2.6 卸载</h3><p>但不使用这个类的话，可以把它卸载掉。</p>
<h3 id="1-2-7-小节"><a href="#1-2-7-小节" class="headerlink" title="1.2.7 小节"></a>1.2.7 小节</h3><p>章节 1.2 的图表示的是一般的类加载流程，而事实上类加载的时候并不一定完全按照这个流程走。例如，解析不一定在初始化之前，也有可能在初始化之后去做。</p>
<h2 id="1-3-编译器优化"><a href="#1-3-编译器优化" class="headerlink" title="1.3 编译器优化"></a>1.3 编译器优化</h2><h2 id="1-4-垃圾收集算法"><a href="#1-4-垃圾收集算法" class="headerlink" title="1.4 垃圾收集算法"></a>1.4 垃圾收集算法</h2><h2 id="1-5-垃圾收集器"><a href="#1-5-垃圾收集器" class="headerlink" title="1.5 垃圾收集器"></a>1.5 垃圾收集器</h2><h1 id="2-工具"><a href="#2-工具" class="headerlink" title="2 工具"></a>2 工具</h1><h1 id="3-实战"><a href="#3-实战" class="headerlink" title="3 实战"></a>3 实战</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://littlefxc.gitee.io/blog/passages/KAFKA-配置参数详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="冯雪超">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="littlefxc's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/passages/KAFKA-配置参数详解/" class="post-title-link" itemprop="url">KAFKA 配置参数详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-02-19 21:56:02 / 修改时间：21:57:51" itemprop="dateCreated datePublished" datetime="2021-02-19T21:56:02+08:00">2021-02-19</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>3.1    Broker Configs</p>
<p>基本配置如下：</p>
<p>-broker.id<br>-log.dirs<br>-zookeeper.connect</p>
<p>Topic-level配置以及其默认值将在<a href="http://kafka.apache.org/documentation.html#topic-config" target="_blank" rel="noopener">下面</a>讨论。</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>broker.id</td>
<td></td>
<td>每个broker都可以用一个唯一的非负整数id进行标识；这个id可以作为broker的“名字”，并且它的存在使得broker无须混淆consumers就可以迁移到不同的host/port上。你可以选择任意你喜欢的数字作为id，只要id是唯一的即可。</td>
</tr>
<tr>
<td>log.dirs</td>
<td>/tmp/kafka-logs</td>
<td>kafka存放数据的路径。这个路径并不是唯一的，可以是多个，路径之间只需要使用逗号分隔即可；每当创建新partition时，都会选择在包含最少partitions的路径下进行。</td>
</tr>
<tr>
<td>port</td>
<td>6667</td>
<td>server接受客户端连接的端口</td>
</tr>
<tr>
<td>zookeeper.connect</td>
<td>null</td>
<td>ZooKeeper连接字符串的格式为：hostname:port，此处hostname和port分别是ZooKeeper集群中某个节点的host和port；为了当某个host宕掉之后你能通过其他ZooKeeper节点进行连接，你可以按照一下方式制定多个hosts： hostname1:port1, hostname2:port2, hostname3:port3.ZooKeeper 允许你增加一个“chroot”路径，将集群中所有kafka数据存放在特定的路径下。当多个Kafka集群或者其他应用使用相同ZooKeeper集群时，可以使用这个方式设置数据存放路径。这种方式的实现可以通过这样设置连接字符串格式，如下所示： hostname1：port1，hostname2：port2，hostname3：port3/chroot/path 这样设置就将所有kafka集群数据存放在/chroot/path路径下。注意，在你启动broker之前，你必须创建这个路径，并且consumers必须使用相同的连接格式。</td>
</tr>
<tr>
<td>message.max.bytes</td>
<td>1000000</td>
<td>server可以接收的消息最大尺寸。重要的是，consumer和producer有关这个属性的设置必须同步，否则producer发布的消息对consumer来说太大。</td>
</tr>
<tr>
<td>num.network.threads</td>
<td>3</td>
<td>server用来处理网络请求的网络线程数目；一般你不需要更改这个属性。</td>
</tr>
<tr>
<td>num.io.threads</td>
<td>8</td>
<td>server用来处理请求的I/O线程的数目；这个线程数目至少要等于硬盘的个数。</td>
</tr>
<tr>
<td>background.threads</td>
<td>4</td>
<td>用于后台处理的线程数目，例如文件删除；你不需要更改这个属性。</td>
</tr>
<tr>
<td>queued.max.requests</td>
<td>500</td>
<td>在网络线程停止读取新请求之前，可以排队等待I/O线程处理的最大请求个数。</td>
</tr>
<tr>
<td>host.name</td>
<td>null</td>
<td>broker的hostname；如果hostname已经设置的话，broker将只会绑定到这个地址上；如果没有设置，它将绑定到所有接口，并发布一份到ZK</td>
</tr>
<tr>
<td>advertised.host.name</td>
<td>null</td>
<td>如果设置，则就作为broker 的hostname发往producer、consumers以及其他brokers</td>
</tr>
<tr>
<td>advertised.port</td>
<td>null</td>
<td>此端口将给与producers、consumers、以及其他brokers，它会在建立连接时用到； 它仅在实际端口和server需要绑定的端口不一样时才需要设置。</td>
</tr>
<tr>
<td>socket.send.buffer.bytes</td>
<td>100 * 1024</td>
<td>SO_SNDBUFF 缓存大小，server进行socket 连接所用</td>
</tr>
<tr>
<td>socket.receive.buffer.bytes</td>
<td>100 * 1024</td>
<td>SO_RCVBUFF缓存大小，server进行socket连接时所用</td>
</tr>
<tr>
<td>socket.request.max.bytes</td>
<td>100 <em> 1024 </em> 1024</td>
<td>server允许的最大请求尺寸； 这将避免server溢出，它应该小于Java heap size</td>
</tr>
<tr>
<td>num.partitions</td>
<td>1</td>
<td>如果创建topic时没有给出划分partitions个数，这个数字将是topic下partitions数目的默认数值。</td>
</tr>
<tr>
<td>log.segment.bytes</td>
<td>1014<em>1024</em>1024</td>
<td>topic partition的日志存放在某个目录下诸多文件中，这些文件将partition的日志切分成一段一段的；这个属性就是每个文件的最大尺寸；当尺寸达到这个数值时，就会创建新文件。此设置可以由每个topic基础设置时进行覆盖。 查看 <a href="http://kafka.apache.org/documentation.html#topic-config" target="_blank" rel="noopener">the per-topic configuration section</a></td>
</tr>
<tr>
<td>log.roll.hours</td>
<td>24 * 7</td>
<td>即使文件没有到达log.segment.bytes，只要文件创建时间到达此属性，就会创建新文件。这个设置也可以有topic层面的设置进行覆盖； 查看<a href="http://kafka.apache.org/documentation.html#topic-config" target="_blank" rel="noopener">the per-topic configuration section</a></td>
</tr>
<tr>
<td>log.cleanup.policy</td>
<td>delete</td>
<td></td>
</tr>
<tr>
<td>log.retention.minutes和log.retention.hours</td>
<td>7 days</td>
<td>每个日志文件删除之前保存的时间。默认数据保存时间对所有topic都一样。 log.retention.minutes 和 log.retention.bytes 都是用来设置删除日志文件的，无论哪个属性已经溢出。 这个属性设置可以在topic基本设置时进行覆盖。 查看<a href="http://kafka.apache.org/documentation.html#topic-config" target="_blank" rel="noopener">the per-topic configuration section</a></td>
</tr>
<tr>
<td>log.retention.bytes</td>
<td>-1</td>
<td>每个topic下每个partition保存数据的总量；注意，这是每个partitions的上限，因此这个数值乘以partitions的个数就是每个topic保存的数据总量。同时注意：如果log.retention.hours和log.retention.bytes都设置了，则超过了任何一个限制都会造成删除一个段文件。 注意，这项设置可以由每个topic设置时进行覆盖。 查看<a href="http://kafka.apache.org/documentation.html#topic-config" target="_blank" rel="noopener">the per-topic configuration section</a></td>
</tr>
<tr>
<td>log.retention.check.interval.ms</td>
<td>5 minutes</td>
<td>检查日志分段文件的间隔时间，以确定是否文件属性是否到达删除要求。</td>
</tr>
<tr>
<td>log.cleaner.enable</td>
<td>false</td>
<td>当这个属性设置为false时，一旦日志的保存时间或者大小达到上限时，就会被删除；如果设置为true，则当保存属性达到上限时，就会进行<a href="https://cwiki.apache.org/confluence/display/KAFKA/Log+Compaction" target="_blank" rel="noopener">log compaction</a>。</td>
</tr>
<tr>
<td>log.cleaner.threads</td>
<td>1</td>
<td>进行日志压缩的线程数</td>
</tr>
<tr>
<td>log.cleaner.io.max.bytes.per.second</td>
<td>None</td>
<td>进行log compaction时，log cleaner可以拥有的最大I/O数目。这项设置限制了cleaner，以避免干扰活动的请求服务。</td>
</tr>
<tr>
<td>log.cleaner.io.buffer.size</td>
<td>500<em>1024</em>1024</td>
<td>log cleaner清除过程中针对日志进行索引化以及精简化所用到的缓存大小。最好设置大点，以提供充足的内存。</td>
</tr>
<tr>
<td>log.cleaner.io.buffer.load.factor</td>
<td>512*1024</td>
<td>进行log cleaning时所需要的I/O chunk尺寸。你不需要更改这项设置。</td>
</tr>
<tr>
<td>log.cleaner.io.buffer.load.factor</td>
<td>0.9</td>
<td>log cleaning中所使用的hash表的负载因子；你不需要更改这个选项。</td>
</tr>
<tr>
<td>log.cleaner.backoff.ms</td>
<td>15000</td>
<td>进行日志是否清理检查的时间间隔</td>
</tr>
<tr>
<td>log.cleaner.min.cleanable.ratio</td>
<td>0.5</td>
<td>这项配置控制log compactor试图清理日志的频率（假定<a href="https://cwiki.apache.org/confluence/display/KAFKA/Log+Compaction" target="_blank" rel="noopener">log compaction</a>是打开的）。默认避免清理压缩超过50%的日志。这个比率绑定了备份日志所消耗的最大空间（50%的日志备份时压缩率为50%）。更高的比率则意味着浪费消耗更少，也就可以更有效的清理更多的空间。这项设置在每个topic设置中可以覆盖。 查看<a href="http://kafka.apache.org/documentation.html#topic-config" target="_blank" rel="noopener">the per-topic configuration section</a>。</td>
</tr>
<tr>
<td>log.cleaner.delete.retention.ms</td>
<td>1day</td>
<td>保存时间；保存压缩日志的最长时间；也是客户端消费消息的最长时间，荣log.retention.minutes的区别在于一个控制未压缩数据，一个控制压缩后的数据；会被topic创建时的指定时间覆盖。</td>
</tr>
<tr>
<td>log.index.size.max.bytes</td>
<td>10<em>1024</em>1024</td>
<td>每个log segment的最大尺寸。注意，如果log尺寸达到这个数值，即使尺寸没有超过log.segment.bytes限制，也需要产生新的log segment。</td>
</tr>
<tr>
<td>log.index.interval.bytes</td>
<td>4096</td>
<td>当执行一次fetch后，需要一定的空间扫描最近的offset，设置的越大越好，一般使用默认值就可以</td>
</tr>
<tr>
<td>log.flush.interval.messages</td>
<td>Long.MaxValue</td>
<td>log文件“sync”到磁盘之前累积的消息条数。因为磁盘IO操作是一个慢操作，但又是一个“数据可靠性”的必要手段，所以检查是否需要固化到硬盘的时间间隔。需要在“数据可靠性”与“性能”之间做必要的权衡，如果此值过大，将会导致每次“发sync”的时间过长（IO阻塞），如果此值过小，将会导致“fsync”的时间较长（IO阻塞），如果此值过小，将会导致”发sync“的次数较多，这也就意味着整体的client请求有一定的延迟，物理server故障，将会导致没有fsync的消息丢失。</td>
</tr>
<tr>
<td>log.flush.scheduler.interval.ms</td>
<td>Long.MaxValue</td>
<td>检查是否需要fsync的时间间隔</td>
</tr>
<tr>
<td>log.flush.interval.ms</td>
<td>Long.MaxValue</td>
<td>仅仅通过interval来控制消息的磁盘写入时机，是不足的，这个数用来控制”fsync“的时间间隔，如果消息量始终没有达到固化到磁盘的消息数，但是离上次磁盘同步的时间间隔达到阈值，也将触发磁盘同步。</td>
</tr>
<tr>
<td>log.delete.delay.ms</td>
<td>60000</td>
<td>文件在索引中清除后的保留时间，一般不需要修改</td>
</tr>
<tr>
<td>auto.create.topics.enable</td>
<td>true</td>
<td>是否允许自动创建topic。如果是真的，则produce或者fetch 不存在的topic时，会自动创建这个topic。否则需要使用命令行创建topic</td>
</tr>
<tr>
<td>controller.socket.timeout.ms</td>
<td>30000</td>
<td>partition管理控制器进行备份时，socket的超时时间。</td>
</tr>
<tr>
<td>controller.message.queue.size</td>
<td>Int.MaxValue</td>
<td>controller-to-broker-channles的buffer 尺寸</td>
</tr>
<tr>
<td>default.replication.factor</td>
<td>1</td>
<td>默认备份份数，仅指自动创建的topics</td>
</tr>
<tr>
<td>replica.lag.time.max.ms</td>
<td>10000</td>
<td>如果一个follower在这个时间内没有发送fetch请求，leader将从ISR重移除这个follower，并认为这个follower已经挂了</td>
</tr>
<tr>
<td>replica.lag.max.messages</td>
<td>4000</td>
<td>如果一个replica没有备份的条数超过这个数值，则leader将移除这个follower，并认为这个follower已经挂了</td>
</tr>
<tr>
<td>replica.socket.timeout.ms</td>
<td>30*1000</td>
<td>leader 备份数据时的socket网络请求的超时时间</td>
</tr>
<tr>
<td>replica.socket.receive.buffer.bytes</td>
<td>64*1024</td>
<td>备份时向leader发送网络请求时的socket receive buffer</td>
</tr>
<tr>
<td>replica.fetch.max.bytes</td>
<td>1024*1024</td>
<td>备份时每次fetch的最大值</td>
</tr>
<tr>
<td>replica.fetch.min.bytes</td>
<td>500</td>
<td>leader发出备份请求时，数据到达leader的最长等待时间</td>
</tr>
<tr>
<td>replica.fetch.min.bytes</td>
<td>1</td>
<td>备份时每次fetch之后回应的最小尺寸</td>
</tr>
<tr>
<td>num.replica.fetchers</td>
<td>1</td>
<td>从leader备份数据的线程数</td>
</tr>
<tr>
<td>replica.high.watermark.checkpoint.interval.ms</td>
<td>5000</td>
<td>每个replica检查是否将最高水位进行固化的频率</td>
</tr>
<tr>
<td>fetch.purgatory.purge.interval.requests</td>
<td>1000</td>
<td>fetch 请求清除时的清除间隔</td>
</tr>
<tr>
<td>producer.purgatory.purge.interval.requests</td>
<td>1000</td>
<td>producer请求清除时的清除间隔</td>
</tr>
<tr>
<td>zookeeper.session.timeout.ms</td>
<td>6000</td>
<td>zookeeper会话超时时间。</td>
</tr>
<tr>
<td>zookeeper.connection.timeout.ms</td>
<td>6000</td>
<td>客户端等待和zookeeper建立连接的最大时间</td>
</tr>
<tr>
<td>zookeeper.sync.time.ms</td>
<td>2000</td>
<td>zk follower落后于zk leader的最长时间</td>
</tr>
<tr>
<td>controlled.shutdown.enable</td>
<td>true</td>
<td>是否能够控制broker的关闭。如果能够，broker将可以移动所有leaders到其他的broker上，在关闭之前。这减少了不可用性在关机过程中。</td>
</tr>
<tr>
<td>controlled.shutdown.max.retries</td>
<td>3</td>
<td>在执行不彻底的关机之前，可以成功执行关机的命令数。</td>
</tr>
<tr>
<td>controlled.shutdown.retry.backoff.ms</td>
<td>5000</td>
<td>在关机之间的backoff时间</td>
</tr>
<tr>
<td>auto.leader.rebalance.enable</td>
<td>true</td>
<td>如果这是true，控制者将会自动平衡brokers对于partitions的leadership</td>
</tr>
<tr>
<td>leader.imbalance.per.broker.percentage</td>
<td>10</td>
<td>每个broker所允许的leader最大不平衡比率</td>
</tr>
<tr>
<td>leader.imbalance.check.interval.seconds</td>
<td>300</td>
<td>检查leader不平衡的频率</td>
</tr>
<tr>
<td>offset.metadata.max.bytes</td>
<td>4096</td>
<td>允许客户端保存他们offsets的最大个数</td>
</tr>
<tr>
<td>max.connections.per.ip</td>
<td>Int.MaxValue</td>
<td>每个ip地址上每个broker可以被连接的最大数目</td>
</tr>
<tr>
<td>max.connections.per.ip.overrides</td>
<td></td>
<td>每个ip或者hostname默认的连接的最大覆盖</td>
</tr>
<tr>
<td>connections.max.idle.ms</td>
<td>600000</td>
<td>空连接的超时限制</td>
</tr>
<tr>
<td>log.roll.jitter.{ms,hours}</td>
<td>0</td>
<td>从logRollTimeMillis抽离的jitter最大数目</td>
</tr>
<tr>
<td>num.recovery.threads.per.data.dir</td>
<td>1</td>
<td>每个数据目录用来日志恢复的线程数目</td>
</tr>
<tr>
<td>unclean.leader.election.enable</td>
<td>true</td>
<td>指明了是否能够使不在ISR中replicas设置用来作为leader</td>
</tr>
<tr>
<td>delete.topic.enable</td>
<td>false</td>
<td>能够删除topic</td>
</tr>
<tr>
<td>offsets.topic.num.partitions</td>
<td>50</td>
<td>The number of partitions for the offset commit topic. Since changing this after deployment is currently unsupported, we recommend using a higher setting for production (e.g., 100-200).</td>
</tr>
<tr>
<td>offsets.topic.retention.minutes</td>
<td>1440</td>
<td>存在时间超过这个时间限制的offsets都将被标记为待删除</td>
</tr>
<tr>
<td>offsets.retention.check.interval.ms</td>
<td>600000</td>
<td>offset管理器检查陈旧offsets的频率</td>
</tr>
<tr>
<td>offsets.topic.replication.factor</td>
<td>3</td>
<td>topic的offset的备份份数。建议设置更高的数字保证更高的可用性</td>
</tr>
<tr>
<td>offset.topic.segment.bytes</td>
<td>104857600</td>
<td>offsets topic的segment尺寸。</td>
</tr>
<tr>
<td>offsets.load.buffer.size</td>
<td>5242880</td>
<td>这项设置与批量尺寸相关，当从offsets segment中读取时使用。</td>
</tr>
<tr>
<td>offsets.commit.required.acks</td>
<td>-1</td>
<td>在offset commit可以接受之前，需要设置确认的数目，一般不需要更改</td>
</tr>
</tbody>
</table>
<p>offsets.commit.timeout.ms   5000    offset commit的延迟时间，这和producer request的超时时间相似。</p>
<p>更多细节可以在scala 类 kafka.server.KafkaConfig中找到。</p>
<p>topic-level的配置</p>
<p>有关topics的配置既有全局的又有每个topic独有的配置。如果没有给定特定topic设置，则应用默认的全局设置。这些覆盖会在每次创建topic发生。下面的例子：创建一个topic，命名为my-topic，自定义最大消息尺寸以及刷新比率为：<br>>  bin/kafka-topics.sh –zookeeper localhost:2181 –create –topic my-topic –partitions 1<br>–replication-factor 1 –config max.message.bytes=64000 –config flush.messages=1</p>
<p>需要删除重写时，可以按照以下来做：</p>
<p>> bin/kafka-topics.sh –zookeeper localhost:2181 –alter –topic my-topic<br>–deleteConfig max.message.bytes</p>
<p>以下是topic-level的配置选项。server的默认配置在Server Default Property列下给出了，设定这些默认值不会改变原有的设置</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Default</th>
<th>Server Default Property</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>cleanup.policy</td>
<td>delete</td>
<td>log.cleanup.policy</td>
<td>要么是”delete“要么是”compact“； 这个字符串指明了针对旧日志部分的利用方式；默认方式（”delete”）将会丢弃旧的部分当他们的回收时间或者尺寸限制到达时。”compact“将会进行日志压缩</td>
</tr>
<tr>
<td>delete.retention.ms</td>
<td>86400000 (24 hours)</td>
<td>log.cleaner.delete.retention.ms</td>
<td>对于压缩日志保留的最长时间，也是客户端消费消息的最长时间，通log.retention.minutes的区别在于一个控制未压缩数据，一个控制压缩后的数据。此项配置可以在topic创建时的置顶参数覆盖</td>
</tr>
<tr>
<td>flush.messages</td>
<td>None</td>
<td>log.flush.interval.messages</td>
<td>此项配置指定时间间隔：强制进行fsync日志。例如，如果这个选项设置为1，那么每条消息之后都需要进行fsync，如果设置为5，则每5条消息就需要进行一次fsync。一般来说，建议你不要设置这个值。此参数的设置,需要在”数据可靠性”与”性能”之间做必要的权衡.如果此值过大,将会导致每次”fsync”的时间较长(IO阻塞),如果此值过小,将会导致”fsync”的次数较多,这也意味着整体的client请求有一定的延迟.物理server故障,将会导致没有fsync的消息丢失.</td>
</tr>
<tr>
<td>flush.ms</td>
<td>None</td>
<td>log.flush.interval.ms</td>
<td>此项配置用来置顶强制进行fsync日志到磁盘的时间间隔；例如，如果设置为1000，那么每1000ms就需要进行一次fsync。一般不建议使用这个选项</td>
</tr>
<tr>
<td>index.interval.bytes</td>
<td>4096</td>
<td>log.index.interval.bytes</td>
<td>默认设置保证了我们每4096个字节就对消息添加一个索引，更多的索引使得阅读的消息更加靠近，但是索引规模却会由此增大；一般不需要改变这个选项</td>
</tr>
<tr>
<td>max.message.bytes</td>
<td>1000000</td>
<td>max.message.bytes</td>
<td>kafka追加消息的最大尺寸。注意如果你增大这个尺寸，你也必须增大你consumer的fetch 尺寸，这样consumer才能fetch到这些最大尺寸的消息。</td>
</tr>
<tr>
<td>min.cleanable.dirty.ratio</td>
<td>0.5</td>
<td>min.cleanable.dirty.ratio</td>
<td>此项配置控制log压缩器试图进行清除日志的频率。默认情况下，将避免清除压缩率超过50%的日志。这个比率避免了最大的空间浪费</td>
</tr>
<tr>
<td>min.insync.replicas</td>
<td>1</td>
<td>min.insync.replicas</td>
<td>当producer设置request.required.acks为-1时，min.insync.replicas指定replicas的最小数目（必须确认每一个repica的写数据都是成功的），如果这个数目没有达到，producer会产生异常。</td>
</tr>
<tr>
<td>retention.bytes</td>
<td>None</td>
<td>log.retention.bytes</td>
<td>如果使用“delete”的retention 策略，这项配置就是指在删除日志之前，日志所能达到的最大尺寸。默认情况下，没有尺寸限制而只有时间限制</td>
</tr>
<tr>
<td>retention.ms</td>
<td>7 days</td>
<td>log.retention.minutes</td>
<td>如果使用“delete”的retention策略，这项配置就是指删除日志前日志保存的时间。</td>
</tr>
<tr>
<td>segment.bytes</td>
<td>1GB</td>
<td>log.segment.bytes</td>
<td>kafka中log日志是分成一块块存储的，此配置是指log日志划分成块的大小</td>
</tr>
<tr>
<td>segment.index.bytes</td>
<td>10MB</td>
<td>log.index.size.max.bytes</td>
<td>此配置是有关offsets和文件位置之间映射的索引文件的大小；一般不需要修改这个配置</td>
</tr>
<tr>
<td>segment.ms</td>
<td>7 days</td>
<td>log.roll.hours</td>
<td>即使log的分块文件没有达到需要删除、压缩的大小，一旦log 的时间达到这个上限，就会强制新建一个log分块文件</td>
</tr>
<tr>
<td>segment.jitter.ms</td>
<td>0</td>
<td>log.roll.jitter.{ms,hours}</td>
<td>The maximum jitter to subtract from logRollTimeMillis.</td>
</tr>
</tbody>
</table>
<p>3.2 Consumer Configs<br>consumer基本配置如下：<br>group.id<br>zookeeper.connect</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>group.id</td>
<td></td>
<td>用来唯一标识consumer进程所在组的字符串，如果设置同样的group id，表示这些processes都是属于同一个consumer group</td>
</tr>
<tr>
<td>zookeeper.connect</td>
<td></td>
<td>指定zookeeper的连接的字符串，格式是hostname：port，此处host和port都是zookeeper server的host和port，为避免某个zookeeper 机器宕机之后失联，你可以指定多个hostname：port，使用逗号作为分隔： hostname1：port1，hostname2：port2，hostname3：port3 可以在zookeeper连接字符串中加入zookeeper的chroot路径，此路径用于存放他自己的数据，方式： hostname1：port1，hostname2：port2，hostname3：port3/chroot/path</td>
</tr>
<tr>
<td>consumer.id</td>
<td>null</td>
<td>不需要设置，一般自动产生</td>
</tr>
<tr>
<td>socket.timeout.ms</td>
<td>30*100</td>
<td>网络请求的超时限制。真实的超时限制是  max.fetch.wait+socket.timeout.ms</td>
</tr>
<tr>
<td>socket.receive.buffer.bytes</td>
<td>64*1024</td>
<td>socket用于接收网络请求的缓存大小</td>
</tr>
<tr>
<td>fetch.message.max.bytes</td>
<td>1024*1024</td>
<td>每次fetch请求中，针对每次fetch消息的最大字节数。这些字节将会督导用于每个partition的内存中，因此，此设置将会控制consumer所使用的memory大小。这个fetch请求尺寸必须至少和server允许的最大消息尺寸相等，否则，producer可能发送的消息尺寸大于consumer所能消耗的尺寸。</td>
</tr>
<tr>
<td>num.consumer.fetchers</td>
<td>1</td>
<td>用于fetch数据的fetcher线程数</td>
</tr>
<tr>
<td>auto.commit.enable</td>
<td>true</td>
<td>如果为真，consumer所fetch的消息的offset将会自动的同步到zookeeper。这项提交的offset将在进程挂掉时，由新的consumer使用</td>
</tr>
<tr>
<td>auto.commit.interval.ms</td>
<td>60*1000</td>
<td>consumer向zookeeper提交offset的频率，单位是秒</td>
</tr>
<tr>
<td>queued.max.message.chunks</td>
<td>2</td>
<td>用于缓存消息的最大数目，以供consumption。每个chunk必须和fetch.message.max.bytes相同</td>
</tr>
<tr>
<td>rebalance.max.retries</td>
<td>4</td>
<td>当新的consumer加入到consumer group时，consumers集合试图重新平衡分配到每个consumer的partitions数目。如果consumers集合改变了，当分配正在执行时，这个重新平衡会失败并重入</td>
</tr>
<tr>
<td>fetch.min.bytes</td>
<td>1</td>
<td>每次fetch请求时，server应该返回的最小字节数。如果没有足够的数据返回，请求会等待，直到足够的数据才会返回。</td>
</tr>
<tr>
<td>fetch.wait.max.ms</td>
<td>100</td>
<td>如果没有足够的数据能够满足fetch.min.bytes，则此项配置是指在应答fetch请求之前，server会阻塞的最大时间。</td>
</tr>
<tr>
<td>rebalance.backoff.ms</td>
<td>2000</td>
<td>在重试reblance之前backoff时间</td>
</tr>
<tr>
<td>refresh.leader.backoff.ms</td>
<td>200</td>
<td>在试图确定某个partition的leader是否失去他的leader地位之前，需要等待的backoff时间</td>
</tr>
<tr>
<td>auto.offset.reset</td>
<td>largest</td>
<td>zookeeper中没有初始化的offset时，如果offset是以下值的回应： smallest：自动复位offset为smallest的offset largest：自动复位offset为largest的offset anything else：向consumer抛出异常</td>
</tr>
<tr>
<td>consumer.timeout.ms</td>
<td>-1</td>
<td>如果没有消息可用，即使等待特定的时间之后也没有，则抛出超时异常</td>
</tr>
<tr>
<td>exclude.internal.topics</td>
<td>true</td>
<td>是否将内部topics的消息暴露给consumer</td>
</tr>
<tr>
<td>paritition.assignment.strategy</td>
<td>range</td>
<td>选择向consumer 流分配partitions的策略，可选值：range，roundrobin</td>
</tr>
<tr>
<td>client.id</td>
<td>group id value</td>
<td>是用户特定的字符串，用来在每次请求中帮助跟踪调用。它应该可以逻辑上确认产生这个请求的应用</td>
</tr>
<tr>
<td>zookeeper.session.timeout.ms</td>
<td>6000</td>
<td>zookeeper 会话的超时限制。如果consumer在这段时间内没有向zookeeper发送心跳信息，则它会被认为挂掉了，并且reblance将会产生</td>
</tr>
<tr>
<td>zookeeper.connection.timeout.ms</td>
<td>6000</td>
<td>客户端在建立通zookeeper连接中的最大等待时间</td>
</tr>
<tr>
<td>zookeeper.sync.time.ms</td>
<td>2000</td>
<td>ZK follower可以落后ZK leader的最大时间</td>
</tr>
<tr>
<td>offsets.storage</td>
<td>zookeeper</td>
<td>用于存放offsets的地点： zookeeper或者kafka</td>
</tr>
<tr>
<td>offset.channel.backoff.ms</td>
<td>1000</td>
<td>重新连接offsets channel或者是重试失败的offset的fetch/commit请求的backoff时间</td>
</tr>
<tr>
<td>offsets.channel.socket.timeout.ms</td>
<td>10000</td>
<td>当读取offset的fetch/commit请求回应的socket 超时限制。此超时限制是被consumerMetadata请求用来请求offset管理</td>
</tr>
<tr>
<td>offsets.commit.max.retries</td>
<td>5</td>
<td>重试offset commit的次数。这个重试只应用于offset commits在shut-down之间。他</td>
</tr>
<tr>
<td>dual.commit.enabled</td>
<td>true</td>
<td>如果使用“kafka”作为offsets.storage，你可以二次提交offset到zookeeper(还有一次是提交到kafka）。在zookeeper-based的offset storage到kafka-based的offset storage迁移时，这是必须的。对任意给定的consumer group来说，比较安全的建议是当完成迁移之后就关闭这个选项</td>
</tr>
<tr>
<td>partition.assignment.strategy</td>
<td>range</td>
<td>在“range”和“roundrobin”策略之间选择一种作为分配partitions给consumer 数据流的策略； 循环的partition分配器分配所有可用的partitions以及所有可用consumer 线程。它会将partition循环的分配到consumer线程上。如果所有consumer实例的订阅都是确定的，则partitions的划分是确定的分布。循环分配策略只有在以下条件满足时才可以：（1）每个topic在每个consumer实力上都有同样数量的数据流。（2）订阅的topic的集合对于consumer group中每个consumer实例来说都是确定的。</td>
</tr>
</tbody>
</table>
<p>更多细节可以查看 scala类： kafka.consumer.ConsumerConfig</p>
<p>3.3  Producer Configs<br>producer基本的配置属性包含：<br>（1） metadata.broker.list<br>（2）request.required.acks<br>（3）producer.type<br>（4）serializer.class</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>metadata.broker.list</td>
<td></td>
<td>服务于bootstrapping。producer仅用来获取metadata（topics，partitions，replicas）。发送实际数据的socket连接将基于返回的metadata数据信息而建立。格式是： host1：port1，host2：port2 这个列表可以是brokers的子列表或者是一个指向brokers的VIP</td>
</tr>
<tr>
<td>request.required.acks</td>
<td>0</td>
<td>此配置是表明当一次produce请求被认为完成时的确认值。特别是，多少个其他brokers必须已经提交了数据到他们的log并且向他们的leader确认了这些信息。典型的值包括： 0： 表示producer从来不等待来自broker的确认信息（和0.7一样的行为）。这个选择提供了最小的时延但同时风险最大（因为当server宕机时，数据将会丢失）。 1：表示获得leader replica已经接收了数据的确认信息。这个选择时延较小同时确保了server确认接收成功。 -1：producer会获得所有同步replicas都收到数据的确认。同时时延最大，然而，这种方式并没有完全消除丢失消息的风险，因为同步replicas的数量可能是1.如果你想确保某些replicas接收到数据，那么你应该在topic-level设置中选项min.insync.replicas设置一下。请阅读一下设计文档，可以获得更深入的讨论。</td>
</tr>
<tr>
<td>request.timeout.ms</td>
<td>10000</td>
<td>broker尽力实现request.required.acks需求时的等待时间，否则会发送错误到客户端</td>
</tr>
<tr>
<td>producer.type</td>
<td>sync</td>
<td>此选项置顶了消息是否在后台线程中异步发送。正确的值： （1） async： 异步发送 （2） sync： 同步发送 通过将producer设置为异步，我们可以批量处理请求（有利于提高吞吐率）但是这也就造成了客户端机器丢掉未发送数据的可能性</td>
</tr>
<tr>
<td>serializer.class</td>
<td>kafka.serializer.DefaultEncoder</td>
<td>消息的序列化类别。默认编码器输入一个字节byte[]，然后返回相同的字节byte[]</td>
</tr>
<tr>
<td>key.serializer.class</td>
<td></td>
<td>关键字的序列化类。如果没给与这项，默认情况是和消息一致</td>
</tr>
<tr>
<td>partitioner.class</td>
<td>kafka.producer.DefaultPartitioner</td>
<td>partitioner 类，用于在subtopics之间划分消息。默认partitioner基于key的hash表</td>
</tr>
<tr>
<td>compression.codec</td>
<td>none</td>
<td>此项参数可以设置压缩数据的codec，可选codec为：“none”， “gzip”， “snappy”</td>
</tr>
<tr>
<td>compressed.topics</td>
<td>null</td>
<td>此项参数可以设置某些特定的topics是否进行压缩。如果压缩codec是NoCompressCodec之外的codec，则对指定的topics数据应用这些codec。如果压缩topics列表是空，则将特定的压缩codec应用于所有topics。如果压缩的codec是NoCompressionCodec，压缩对所有topics军不可用。</td>
</tr>
<tr>
<td>message.send.max.retries</td>
<td>3</td>
<td>此项参数将使producer自动重试失败的发送请求。此项参数将置顶重试的次数。注意：设定非0值将导致重复某些网络错误：引起一条发送并引起确认丢失</td>
</tr>
<tr>
<td>retry.backoff.ms</td>
<td>100</td>
<td>在每次重试之前，producer会更新相关topic的metadata，以此进行查看新的leader是否分配好了。因为leader的选择需要一点时间，此选项指定更新metadata之前producer需要等待的时间。</td>
</tr>
<tr>
<td>topic.metadata.refresh.interval.ms</td>
<td>600*1000</td>
<td>producer一般会在某些失败的情况下（partition missing，leader不可用等）更新topic的metadata。他将会规律的循环。如果你设置为负值，metadata只有在失败的情况下才更新。如果设置为0，metadata会在每次消息发送后就会更新（不建议这种选择，系统消耗太大）。重要提示： 更新是有在消息发送后才会发生，因此，如果producer从来不发送消息，则metadata从来也不会更新。</td>
</tr>
<tr>
<td>queue.buffering.max.ms</td>
<td>5000</td>
<td>当应用async模式时，用户缓存数据的最大时间间隔。例如，设置为100时，将会批量处理100ms之内消息。这将改善吞吐率，但是会增加由于缓存产生的延迟。</td>
</tr>
<tr>
<td>queue.buffering.max.messages</td>
<td>10000</td>
<td>当使用async模式时，在在producer必须被阻塞或者数据必须丢失之前，可以缓存到队列中的未发送的最大消息条数</td>
</tr>
<tr>
<td>batch.num.messages</td>
<td>200</td>
<td>使用async模式时，可以批量处理消息的最大条数。或者消息数目已到达这个上线或者是queue.buffer.max.ms到达，producer才会处理</td>
</tr>
<tr>
<td>send.buffer.bytes</td>
<td>100*1024</td>
<td>socket 写缓存尺寸</td>
</tr>
<tr>
<td>client.id</td>
<td>“”</td>
<td>这个client id是用户特定的字符串，在每次请求中包含用来追踪调用，他应该逻辑上可以确认是那个应用发出了这个请求。</td>
</tr>
</tbody>
</table>
<p>更多细节需要查看 scala类<br>kafka.producer.ProducerConfig</p>
<p>3、4 New Producer Configs<br>我们正在努力替换现有的producer。代码在trunk中是可用的，可以认为beta版本。下面是新producer的配置</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Importance</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>boostrap.servers</td>
<td>list</td>
<td></td>
<td>high</td>
<td>用于建立与kafka集群连接的host/port组。数据将会在所有servers上均衡加载，不管哪些server是指定用于bootstrapping。这个列表仅仅影响初始化的hosts（用于发现全部的servers）。这个列表格式： host1:port1,host2:port2,… 因为这些server仅仅是用于初始化的连接，以发现集群所有成员关系（可能会动态的变化），这个列表不需要包含所有的servers（你可能想要不止一个server，尽管这样，可能某个server宕机了）。如果没有server在这个列表出现，则发送数据会一直失败，直到列表可用。</td>
</tr>
<tr>
<td>acks</td>
<td>string</td>
<td>1</td>
<td>high</td>
<td>producer需要server接收到数据之后发出的确认接收的信号，此项配置就是指procuder需要多少个这样的确认信号。此配置实际上代表了数据备份的可用性。以下设置为常用选项： （1）acks=0： 设置为0表示producer不需要等待任何确认收到的信息。副本将立即加到socket buffer并认为已经发送。没有任何保障可以保证此种情况下server已经成功接收数据，同时重试配置不会发生作用（因为客户端不知道是否失败）回馈的offset会总是设置为-1； （2）acks=1： 这意味着至少要等待leader已经成功将数据写入本地log，但是并没有等待所有follower是否成功写入。这种情况下，如果follower没有成功备份数据，而此时leader又挂掉，则消息会丢失。 （3）acks=all： 这意味着leader需要等待所有备份都成功写入日志，这种策略会保证只要有一个备份存活就不会丢失数据。这是最强的保证。 （4）其他的设置，例如acks=2也是可以的，这将需要给定的acks数量，但是这种策略一般很少用。</td>
</tr>
<tr>
<td>buffer.memory</td>
<td>long</td>
<td>33554432</td>
<td>high</td>
<td>producer可以用来缓存数据的内存大小。如果数据产生速度大于向broker发送的速度，producer会阻塞或者抛出异常，以“block.on.buffer.full”来表明。这项设置将和producer能够使用的总内存相关，但并不是一个硬性的限制，因为不是producer使用的所有内存都是用于缓存。一些额外的内存会用于压缩（如果引入压缩机制），同样还有一些用于维护请求。</td>
</tr>
<tr>
<td>compression.type</td>
<td>string</td>
<td>none</td>
<td>high</td>
<td>producer用于压缩数据的压缩类型。默认是无压缩。正确的选项值是none、gzip、snappy。 压缩最好用于批量处理，批量处理消息越多，压缩性能越好。</td>
</tr>
<tr>
<td>retries</td>
<td>int</td>
<td>0</td>
<td>high</td>
<td>设置大于0的值将使客户端重新发送任何数据，一旦这些数据发送失败。注意，这些重试与客户端接收到发送错误时的重试没有什么不同。允许重试将潜在的改变数据的顺序，如果这两个消息记录都是发送到同一个partition，则第一个消息失败第二个发送成功，则第二条消息会比第一条消息出现要早。</td>
</tr>
<tr>
<td>batch.size</td>
<td>int</td>
<td>16384</td>
<td>medium</td>
<td>producer将试图批处理消息记录，以减少请求次数。这将改善client与server之间的性能。这项配置控制默认的批量处理消息字节数。 不会试图处理大于这个字节数的消息字节数。 发送到brokers的请求将包含多个批量处理，其中会包含对每个partition的一个请求。 较小的批量处理数值比较少用，并且可能降低吞吐量（0则会仅用批量处理）。较大的批量处理数值将会浪费更多内存空间，这样就需要分配特定批量处理数值的内存大小。</td>
</tr>
<tr>
<td>client.id</td>
<td>string</td>
<td></td>
<td>medium</td>
<td>当向server发出请求时，这个字符串会发送给server。目的是能够追踪请求源头，以此来允许ip/port许可列表之外的一些应用可以发送信息。这项应用可以设置任意字符串，因为没有任何功能性的目的，除了记录和跟踪</td>
</tr>
<tr>
<td>linger.ms</td>
<td>long</td>
<td>0</td>
<td>medium</td>
<td>producer组将会汇总任何在请求与发送之间到达的消息记录一个单独批量的请求。通常来说，这只有在记录产生速度大于发送速度的时候才能发生。然而，在某些条件下，客户端将希望降低请求的数量，甚至降低到中等负载一下。这项设置将通过增加小的延迟来完成–即，不是立即发送一条记录，producer将会等待给定的延迟时间以允许其他消息记录发送，这些消息记录可以批量处理。这可以认为是TCP种Nagle的算法类似。这项设置设定了批量处理的更高的延迟边界：一旦我们获得某个partition的batch.size，他将会立即发送而不顾这项设置，然而如果我们获得消息字节数比这项设置要小的多，我们需要“linger”特定的时间以获取更多的消息。 这个设置默认为0，即没有延迟。设定linger.ms=5，例如，将会减少请求数目，但是同时会增加5ms的延迟。</td>
</tr>
<tr>
<td>max.request.size</td>
<td>int</td>
<td>1028576</td>
<td>medium</td>
<td>请求的最大字节数。这也是对最大记录尺寸的有效覆盖。注意：server具有自己对消息记录尺寸的覆盖，这些尺寸和这个设置不同。此项设置将会限制producer每次批量发送请求的数目，以防发出巨量的请求。</td>
</tr>
<tr>
<td>receive.buffer.bytes</td>
<td>int</td>
<td>32768</td>
<td>medium</td>
<td>TCP receive缓存大小，当阅读数据时使用</td>
</tr>
<tr>
<td>send.buffer.bytes</td>
<td>int</td>
<td>131072</td>
<td>medium</td>
<td>TCP send缓存大小，当发送数据时使用</td>
</tr>
<tr>
<td>timeout.ms</td>
<td>int</td>
<td>30000</td>
<td>medium</td>
<td>此配置选项控制server等待来自followers的确认的最大时间。如果确认的请求数目在此时间内没有实现，则会返回一个错误。这个超时限制是以server端度量的，没有包含请求的网络延迟</td>
</tr>
<tr>
<td>block.on.buffer.full</td>
<td>boolean</td>
<td>true</td>
<td>low</td>
<td>当我们内存缓存用尽时，必须停止接收新消息记录或者抛出错误。默认情况下，这个设置为真，然而某些阻塞可能不值得期待，因此立即抛出错误更好。设置为false则会这样：producer会抛出一个异常错误：BufferExhaustedException， 如果记录已经发送同时缓存已满</td>
</tr>
<tr>
<td>metadata.fetch.timeout.ms</td>
<td>long</td>
<td>60000</td>
<td>low</td>
<td>是指我们所获取的一些元素据的第一个时间数据。元素据包含：topic，host，partitions。此项配置是指当等待元素据fetch成功完成所需要的时间，否则会跑出异常给客户端。</td>
</tr>
<tr>
<td>metadata.max.age.ms</td>
<td>long</td>
<td>300000</td>
<td>low</td>
<td>以微秒为单位的时间，是在我们强制更新metadata的时间间隔。即使我们没有看到任何partition leadership改变。</td>
</tr>
<tr>
<td>metric.reporters</td>
<td>list</td>
<td>[]</td>
<td>low</td>
<td>类的列表，用于衡量指标。实现MetricReporter接口，将允许增加一些类，这些类在新的衡量指标产生时就会改变。JmxReporter总会包含用于注册JMX统计</td>
</tr>
<tr>
<td>metrics.num.samples</td>
<td>int</td>
<td>2</td>
<td>low</td>
<td>用于维护metrics的样本数</td>
</tr>
<tr>
<td>metrics.sample.window.ms</td>
<td>long</td>
<td>30000</td>
<td>low</td>
<td>metrics系统维护可配置的样本数量，在一个可修正的window size。这项配置配置了窗口大小，例如。我们可能在30s的期间维护两个样本。当一个窗口推出后，我们会擦除并重写最老的窗口</td>
</tr>
<tr>
<td>recoonect.backoff.ms</td>
<td>long</td>
<td>10</td>
<td>low</td>
<td>连接失败时，当我们重新连接时的等待时间。这避免了客户端反复重连</td>
</tr>
<tr>
<td>retry.backoff.ms</td>
<td>long</td>
<td>100</td>
<td>low</td>
<td>在试图重试失败的produce请求之前的等待时间。避免陷入发送-失败的死循环中。</td>
</tr>
</tbody>
</table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://littlefxc.gitee.io/blog/passages/ES-7-X-下动态增加分片数量/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="冯雪超">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="littlefxc's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/passages/ES-7-X-下动态增加分片数量/" class="post-title-link" itemprop="url">ES 7.X 下动态增加分片数量</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-02-19 21:54:09 / 修改时间：21:55:45" itemprop="dateCreated datePublished" datetime="2021-02-19T21:54:09+08:00">2021-02-19</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1 背景"></a>1 <strong>背景</strong></h1><p>在老版本的ES（例如2.3版本）中， index的shard数量定好后，就不能再修改，除非重建数据才能实现。</p>
<p>从ES6.1开始，ES 支持可以在线操作扩大shard的数量（注意：操作期间也需要对index锁写）</p>
<p>从ES7.0开始，split时候，不再需要加参数 index.number_of_routing_shards</p>
<p><strong>具体参考官方文档：</strong></p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.5/indices-split-index.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/7.5/indices-split-index.html</a></p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.1/indices-split-index.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/6.1/indices-split-index.html</a></p>
<h1 id="2-split的过程："><a href="#2-split的过程：" class="headerlink" title="2 split的过程："></a>2 <strong>split的过程：</strong></h1><p>1、创建一个新的目标index，其定义与源index相同，但是具有更多的primary shard。</p>
<p>2、将segment从源index硬链接到目标index。（如果文件系统不支持硬链接，则将所有segment都复制到新索引中，这是一个非常耗时的过程。）</p>
<p>3、创建低级文件后，再次对所有文档进行哈希处理，以删除属于不同shard的documents</p>
<p>4、恢复目标索引，就像它是刚刚重新打开的封闭索引一样。</p>
<h1 id="3-为啥ES不支持增量resharding？"><a href="#3-为啥ES不支持增量resharding？" class="headerlink" title="3 为啥ES不支持增量resharding？"></a>3 <strong>为啥ES不支持增量resharding？</strong></h1><p>从N个分片到N + 1个分片。增量重新分片确实是许多键值存储支持的功能。仅添加一个新的分片并将新的数据推入该新的分片是不可行的：这可能是一个索引瓶颈，并根据给定的_id来确定文档所属的分片，这对于获取，删除和更新请求是必需的，会变得很复杂。这意味着我们需要使用其他哈希方案重新平衡现有数据。</p>
<p>键值存储有效执行此操作的最常见方式是使用一致的哈希。当分片的数量从N增加到N + 1时，一致的哈希仅需要重定位键的1 / N。但是，Elasticsearch的存储单位（碎片）是Lucene索引。由于它们以搜索为导向的数据结构，仅占Lucene索引的很大一部分，即仅占5％的文档，将其删除并在另一个分片上建立索引通常比键值存储要高得多的成本。如上节所述，当通过增加乘数来增加分片数量时，此成本保持合理：这允许Elasticsearch在本地执行拆分，这又允许在索引级别执行拆分，而不是为需要重新索引的文档重新编制索引移动，以及使用硬链接进行有效的文件复制。</p>
<p>对于仅追加数据，可以通过创建新索引并将新数据推送到其中，同时添加一个别名来覆盖读取操作的新旧索引，从而获得更大的灵活性。假设旧索引和新索引分别具有M和N个分片，与搜索具有M + N个分片的索引相比，这没有开销。</p>
<h1 id="4-索引能进行split的前提条件："><a href="#4-索引能进行split的前提条件：" class="headerlink" title="4 索引能进行split的前提条件："></a>4 <strong>索引能进行split的前提条件：</strong></h1><p>1、目标索引不能存在。</p>
<p>2、源索引必须比目标索引具有更少的primary shard。</p>
<p>3、目标索引中主shard的数量必须是源索引中主shard的数量的倍数。</p>
<p>4、处理拆分过程的节点必须具有足够的可用磁盘空间，以容纳现有索引的第二个副本。</p>
<h1 id="5-操作"><a href="#5-操作" class="headerlink" title="5 操作"></a>5 <strong>操作</strong></h1><p><strong>下面是具体的实验部分：</strong></p>
<blockquote>
<p>tips：实验机器有限，索引的replica都设置为0，生产上至少replica&gt;=1</p>
</blockquote>
<h2 id="5-1-创建一个索引，2个主shard，没有副本"><a href="#5-1-创建一个索引，2个主shard，没有副本" class="headerlink" title="5.1 创建一个索引，2个主shard，没有副本"></a>5.1 <strong>创建一个索引，2个主shard，没有副本</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl -s -X PUT “&lt;http://localhost:9200/twitter?pretty”&gt; -H ‘Content-Type: application/json’ -d’ &#123; “settings”: &#123; “index.number_of_shards”: 2, “index.number_of_replicas”: 0 &#125;, “aliases”: &#123; “my_search_indices”: &#123;&#125; &#125; &#125;’ </span><br><span class="line"><span class="comment"># index.number_of_shards：主分片设定个数 </span></span><br><span class="line"><span class="comment"># index.number_of_replicas：副本分片设定个数，一个副本就等于把整个索引备份1份 </span></span><br><span class="line"><span class="comment"># aliases：设定索引别名”my_search_indices”</span></span><br></pre></td></tr></table></figure>
<h3 id="写入几条测试数据"><a href="#写入几条测试数据" class="headerlink" title="写入几条测试数据"></a><strong>写入几条测试数据</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -s –X PUT “&lt;http://localhost:9200/my_search_indices/_doc/11?pretty”&gt; –H ‘Content–Type: application/json’ -d ‘&#123; “id”: 11, “name”:“lee”, “age”:“23” &#125;’ </span><br><span class="line"></span><br><span class="line">curl -s –X PUT “&lt;http://localhost:9200/my_search_indices/_doc/22?pretty”&gt; –H ‘Content–Type: application/json’ -d ‘&#123; “id”: 22, “name”:“amd”, “age”:“22” &#125;’</span><br></pre></td></tr></table></figure>
<h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a><strong>查询数据</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -s -XGET “&lt;http://localhost:9200/my_search_indices/_search”&gt; | jq .</span><br></pre></td></tr></table></figure>
<h2 id="5-2-对索引锁写，以便下面执行split操作"><a href="#5-2-对索引锁写，以便下面执行split操作" class="headerlink" title="5.2 对索引锁写，以便下面执行split操作"></a>5.2 <strong>对索引锁写，以便下面执行split操作</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -s -X PUT “&lt;http://localhost:9200/twitter/_settings?pretty”&gt; -H ‘Content-Type: application/json’ -d ‘&#123; “settings”: &#123; “index.blocks.write”: <span class="literal">true</span> &#125; &#125;’ </span><br><span class="line"><span class="comment"># index.blocks.write：写入锁定，只能读，不能写</span></span><br></pre></td></tr></table></figure>
<h3 id="写数据测试，确保锁写生效"><a href="#写数据测试，确保锁写生效" class="headerlink" title="写数据测试，确保锁写生效"></a><strong>写数据测试，确保锁写生效</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -s -X PUT “&lt;http://localhost:9200/twitter/_doc/33?pretty”&gt; -H ‘Content-Type: application/json’ -d ‘&#123; “id”: 33, “name”:“amd”, “age”:“33” &#125;’ </span><br><span class="line"><span class="comment"># 测试写入失败</span></span><br></pre></td></tr></table></figure>
<h3 id="取消-twitter-索引的alias"><a href="#取消-twitter-索引的alias" class="headerlink" title="取消 twitter 索引的alias"></a><strong>取消 twitter 索引的alias</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -s -X POST “&lt;http://localhost:9200/_aliases?pretty”&gt; -H ‘Content-Type: application/json’ -d ‘&#123; “actions” : [ &#123; “remove” : &#123; “index” : “twitter”, “<span class="built_in">alias</span>” : “my_search_indices” &#125; &#125; ] &#125;‘ </span><br><span class="line"></span><br><span class="line">curl -s -X GET “&lt;http://localhost:9200/_cat/aliases”&gt;</span><br></pre></td></tr></table></figure>
<p>第二种方式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 取消索引别名 </span></span><br><span class="line">curl -s -X DELETE “&lt;http://localhost:9200/twitter/_alias/my_search_indices”&gt; </span><br><span class="line">curl -s -X GET“&lt;http://localhost:9200/_cat/aliases”&gt;</span><br></pre></td></tr></table></figure>
<h2 id="5-3-开始执行-split-切分索引的操作，调整后索引名称为new-twitter，且主shard数量为8"><a href="#5-3-开始执行-split-切分索引的操作，调整后索引名称为new-twitter，且主shard数量为8" class="headerlink" title="5.3 开始执行 split 切分索引的操作，调整后索引名称为new_twitter，且主shard数量为8"></a>5.3 <strong>开始执行 split 切分索引的操作，调整后索引名称为new_twitter，且主shard数量为8</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -s –X POST “&lt;http://localhost:9200/twitter/_split/new_twitter?pretty”&gt; –H ‘Content–Type: application/json’ -d ‘&#123; “settings”: &#123; “index.number_of_shards”: 8, “index.number_of_replicas”: 0 &#125; &#125;’</span><br></pre></td></tr></table></figure>
<h3 id="对新的index添加alias"><a href="#对新的index添加alias" class="headerlink" title="对新的index添加alias"></a><strong>对新的index添加alias</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -s –X POST “&lt;http://localhost:9200/_aliases?pretty”&gt; –H ‘Content–Type: application/json’ -d ‘&#123; “actions” : [ &#123; “add” : &#123; “index” : “new_twitter”, “<span class="built_in">alias</span>” : “my_search_indices” &#125; &#125; ] &#125;’</span><br></pre></td></tr></table></figure>
<p>第二种方式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新建索引别名 </span></span><br><span class="line">curl -s -X PUT “&lt;http://localhost:9200/new_twitter/_alias/my_search_indices”&gt;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">	<span class="attr">"acknowledged"</span> : <span class="literal">true</span>, </span><br><span class="line">  <span class="attr">"shards_acknowledged” : true, </span></span><br><span class="line">  "index" : "new_twitter" </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>补充：</strong></p>
<p><strong>查看split的进度，可以使用 _cat/recovery 这个api， 或者在 cerebro 界面上查看。</strong></p>
<h2 id="5-4-查看新索引的数据，能正常查看"><a href="#5-4-查看新索引的数据，能正常查看" class="headerlink" title="5.4 查看新索引的数据，能正常查看"></a>5.4 <strong>查看新索引的数据，能正常查看</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -s -XGET “&lt;http://localhost:9200/my_search_indices/_search”&gt; | jq .</span><br></pre></td></tr></table></figure>
<h3 id="查看split的进度，可以使用-cat-recovery-这个api，-或者在-cerebro-界面上查看。"><a href="#查看split的进度，可以使用-cat-recovery-这个api，-或者在-cerebro-界面上查看。" class="headerlink" title="查看split的进度，可以使用 _cat/recovery 这个api， 或者在 cerebro 界面上查看。"></a><strong>查看split的进度，可以使用 _cat/recovery 这个api， 或者在 cerebro 界面上查看。</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -s -X GET “&lt;http://localhost:9200/_cat/recovery”&gt;</span><br></pre></td></tr></table></figure>
<h3 id="对新索引写数据测试-可以看到失败的"><a href="#对新索引写数据测试-可以看到失败的" class="headerlink" title="对新索引写数据测试,可以看到失败的"></a><strong>对新索引写数据测试,可以看到失败的</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -s -X PUT “localhost:9200/my_search_indices/_doc/33?pretty” -H ‘Content-Type: application/json’ -d ‘&#123; “id”: 33, “name”:“amd”, “age”:“33” &#125;’ <span class="comment"># 写入失败</span></span><br></pre></td></tr></table></figure>
<h3 id="打开索引的写功能"><a href="#打开索引的写功能" class="headerlink" title="打开索引的写功能"></a><strong>打开索引的写功能</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -s –X PUT “localhost:9200/my_search_indices/_settings?pretty” –H ‘Content–Type: application/json’ -d ‘&#123; “settings”: &#123; “index.blocks.write”: <span class="literal">false</span> &#125; &#125;’</span><br></pre></td></tr></table></figure>
<h3 id="再次对新索引写数据测试-可以看到此时，写入是成功的"><a href="#再次对新索引写数据测试-可以看到此时，写入是成功的" class="headerlink" title="再次对新索引写数据测试,可以看到此时，写入是成功的"></a><strong>再次对新索引写数据测试,可以看到此时，写入是成功的</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -s –X PUT “localhost:9200/my_search_indices/_doc/33?pretty” –H ‘Content–Type: application/json’ -d ‘&#123; “id”: 33, “name”:“amd”, “age”:“33” &#125;’ </span><br><span class="line"></span><br><span class="line">curl -s –X PUT “localhost:9200/my_search_indices/_doc/44?pretty” –H ‘Content–Type: application/json’ -d ‘&#123; “id”: 44, “name”:“intel”, “age”:“4” &#125;’</span><br></pre></td></tr></table></figure>
<p>此时，老的那个索引还是只读的，我们确保新索引OK后，就可以考虑关闭或者删除老的 twitter索引了。</p>
<h3 id="测试将新数据写入别名"><a href="#测试将新数据写入别名" class="headerlink" title="测试将新数据写入别名"></a><strong>测试将新数据写入别名</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -s –X PUT “localhost:9200/my_search_indices/_doc/44?pretty” –H ‘Content–Type: application/json’ -d ‘&#123; “id”: 44, “name”:“amd”, “age”:“44” &#125;’ </span><br><span class="line"><span class="comment"># 写入也是ok 的</span></span><br></pre></td></tr></table></figure>
<h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a><strong>删除索引</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -s -X DELETE “&lt;http://localhost:9200/new_twitter”&gt;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><p>贴一张 生产环境执行后的index的截图，可以看到新的index的每个shard体积只有老index的一半，这样也就分摊了index的压力：</p>
<p><img src="https://gitee.com/littlefxc/oss/raw/master/images/774.jpg" alt="https://www.xiaohuait.com/wp-content/uploads/2020/09/774.jpg"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://littlefxc.gitee.io/blog/passages/ES集群核心概念之集群、分片、副本/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="冯雪超">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="littlefxc's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/passages/ES集群核心概念之集群、分片、副本/" class="post-title-link" itemprop="url">ES集群核心概念之集群、分片、副本</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-02-18 21:31:27 / 修改时间：21:35:46" itemprop="dateCreated datePublished" datetime="2021-02-18T21:31:27+08:00">2021-02-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/ELK/" itemprop="url" rel="index"><span itemprop="name">ELK</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="ES集群核心概念"><a href="#ES集群核心概念" class="headerlink" title="ES集群核心概念"></a><strong>ES集群核心概念</strong></h1><h3 id="1）Cluster：集群"><a href="#1）Cluster：集群" class="headerlink" title="1）Cluster：集群"></a><strong>1）Cluster：集群</strong></h3><p>ES可以作为一个独立的单个搜索服务器。不过，为了处理大型数据集，实现容错和高可用性，ES可以运行在许多互相合作的服务器上。这些服务器的集合称为集群，集群内的节点的<code>cluster.name</code>相同。</p>
<h3 id="2）Node：节点"><a href="#2）Node：节点" class="headerlink" title="2）Node：节点"></a><strong>2）Node：节点</strong></h3><p>形成集群的每个服务器称为节点。</p>
<p>ES 为分配不同的任务，定义了以下几个节点角色：<code>Master</code>,<code>Data Node</code>,<code>Coordinating Node</code>,<code>Ingest Node</code></p>
<ul>
<li><p><strong>Master 节点</strong>：每个 ES 节点启动之前都会有个默认配置 <code>node.master:true</code> ,也就是说每个节点都有可能成为 Master 节点，这些节点被称作 <code>Master-eligible nodes</code> ，就是合格的有资格成为 Master 节点的节点。当然 <strong>Master 只能有一个</strong>，所以会通过选举的方法对这启动的节点选举，被选中的节点才会成为 Master 节点。 Master 节点主要是负责维护集群的状态，像所有节点的信息，所有的索引和它相关的 Mapping 关系，配置信息，分片的路由等。既然 Master 节点维护了这么重要的信息，玩意它挂了怎么办？挂了的话，将会对其他的有资格成为 Master 节点的节点重新选举出另一个 Master 节点，因此这就说明了其他 Master-eligible nodes 也会保存集群信息，但是只有 Master 节点有权限能够修改，试想如果其他节点也能修改的话，这将会导致数据不一致的问题。</p>
</li>
<li><p><strong>Data Node 节点</strong>：数据节点，这个节点主要负责数据的存储，在数据扩展上起到了至关重要的作用。也就是说读写数据都会找到相应的 Data Node 节点。</p>
</li>
<li><p><strong>Coordinating Node 节点</strong>：协调节点主要负责协调客户端的请求，将接收到的请求分发给合适的节点，并把结果汇集到一起。比如客户端请求查询某个索引的数据，协调节点将会把请求分发给保存相关的数据的 DataNode 节点，找到相应的分片，并把查询到的结果都汇集返回。并且每个节点都默认起到了 Coordinating Node 的职责。</p>
</li>
<li><p><strong>Ingest Node节点</strong>: Ingest node 专门对索引的文档做预处理,发生在对真实文档建立索引之前。在建立索引对文档预处理之前，先定义一个管道（pipeline），管道里指定了一系列的处理器。每个处理器能够把文档按照某种特定的方式转换。比如在管道里定义一个从某个文档中移除字段的处理器，紧接着一个重命名字段的处理器。集群的状态也会被存储到配置的管道内。定义一个管道，简单的在索引或者bulk request(一种批量请求方法)操作上定义 pipeline 参数,这样 ingest node 就会知道哪个管道在使用。这个节点在使用过程中用的也不多，所以大概了解一下就行。</p>
</li>
<li><p>文档读写原理</p>
<p><img src="https://gitee.com/littlefxc/oss/raw/master/images/es_8_2.png" alt="https://gitee.com/littlefxc/oss/raw/master/images/es_8_2.png"></p>
<p><img src="https://gitee.com/littlefxc/oss/raw/master/images/es_8_3.png" alt="https://gitee.com/littlefxc/oss/raw/master/images/es_8_3.png"></p>
</li>
</ul>
<p><strong>说明：</strong></p>
<ul>
<li><strong>一个节点可以充当一个或多个角色，默认三个角色都有。</strong></li>
<li><strong>协调节点：一个节点只作为接收请求、转发请求到其他节点、汇总各个节点返回数据等功能的节点。就叫协调节点。</strong></li>
</ul>
<h3 id="3）Index：索引"><a href="#3）Index：索引" class="headerlink" title="3）Index：索引"></a><strong>3）Index：索引</strong></h3><p>在 ES 中, 索引是一组文档的集合。索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容。当表中有大量记录时，若要对表进行查询，第一种搜索信息方式是全表搜索，是将所有记录一一取出，和查询条件进行一一对比，然后返回满足条件的记录，这样做会消耗大量数据库系统时间，并造成大量磁盘I/O操作；第二种就是在表中建立索引，然后在索引中找到符合查询条件的索引值，最后通过保存在索引中的ROWID（相当于页码）快速找到表中对应的记录。</p>
<h3 id="4）Shard：分片"><a href="#4）Shard：分片" class="headerlink" title="4）Shard：分片"></a><strong>4）Shard：分片</strong></h3><p>当有大量的文档时，由于内存的限制、磁盘处理能力不足、无法足够快的响应客户端的请求等，一个节点可能不够。</p>
<p>这种情况下，数据可以分为较小的分片。每个分片放到不同的服务器上。当你查询的索引分布在多个分片上时，ES会把查询发送给每个相关的分片，并将结果组合在一起，而应用程序并不知道分片的存在。即：这个过程对用户来说是透明的。</p>
<p><strong>说明：</strong></p>
<ul>
<li><strong>创建索引的时候就确定好主分片的数量，除非重索引。</strong></li>
<li><strong>分片对应的存储实体是索引。</strong></li>
<li><strong>一个分片就是一个 Lucene 实例</strong></li>
</ul>
<h3 id="5）路由"><a href="#5）路由" class="headerlink" title="5）路由"></a><strong>5）路由</strong></h3><p>Elasticsearch 如何知道一个文档应该存放到哪个分片中呢？当我们创建文档时，它如何决定这个文档应当被存储在分片 1 还是分片 2 中呢？首先这肯定不会是随机的，否则将来要获取文档的时候我们就不知道从何处寻找了。实际上，这个过程是根据下面这个公式决定的：<code>shard = hash(routing) % number_of_primary_shards</code>， <code>routing</code> 是一个可变值，唯一不可重复，默认是<code>文档的 _id</code> ，也可以设置成一个自定义的值。 <code>routing</code> 通过 <code>hash 函数</code>生成一个数字，然后这个数字再除以 <code>number_of_primary_shards</code> （主分片的数量）后得到余数 。这个分布在 0 到 number_of_primary_shards-1 之间的余数，就是我们所寻求的文档所在分片的位置。这就解释了为什么我们要在创建索引的时候就确定好主分片的数量 并且永远不会改变这个数量：因为如果数量变化了，那么所有之前路由的值都会无效，文档也再也找不到了。所有的文档 API( get 、 index 、 delete 、 bulk 、 update 以及 mget )都接受一个叫做 routing 的路由参数 ，通过这个参数我们可以自定义文档到分片的映射。一个自定义的路由参数可以用来确保所有相关的文档——例如所有属于同一个用户的文档——都被存储到同一个分片中。</p>
<h3 id="6）Replia：副本"><a href="#6）Replia：副本" class="headerlink" title="6）Replia：副本"></a><strong>6）Replia：副本</strong></h3><p>在创建某个索引之前，需要指定分配这个索引多少个分片？多少个副本？副本就这这个分片的备胎，当分片挂掉了，它的副本就会随时准备上位，因此副本也是个分片只不过不负责主要功能。</p>
<p>不仅仅如此，ES 如何能够提高数据吞吐量呢？增加副本个数就是个不错的选择，比如说读写分离，读数据的时候从副本上读，写数据的时候只用主分片去写。需要注意的是，主分片的个数实在建立索引之前要确定，建立完索引之后，是不能够进行修改的，除非重新建索引。因此在建索引之前，一定要合理的配置分片个数，副本个数的话后期是可以改动的。</p>
<p>为提高查询吞吐量或实现高可用性，可以使用分片副本。副本是一个分片的精确复制，每个分片可以有零个或多个副本。ES中可以有许多相同的分片，其中之一被选择更改索引操作，这种特殊的分片称为主分片。当主分片丢失时，如：该分片所在的数据不可用时，集群将副本提升为新的主分片。Elasticsearch 禁止同一个分片的主分片和副本分片在同一个节点上，所以如果是一个节点的集群是不能有副本的。</p>
<p>它在节点失败的情况下提供高可用性。由于这个原因，需要注意的是，副本分片永远不会分配到与主分片相同的节点上。</p>
<p><strong>如何设置副本</strong></p>
<p>启动 2 个 ES 节点，配置分片个数为 3，副本个数为 1（每个分片有一个副本）。如下图，蓝色的代表主分片，绿色的是副本，仔细一点不难发现，分片与其副本不在同一个节点内。这是非常合理的，因为副本本来就是主分片的备胎，当主分片节点挂了，另外一个节点的副本将会充当主分片，如果它们在同一个节点内，副本将发挥不到作用。</p>
<p><img src="https://gitee.com/littlefxc/oss/raw/master/images/es_9_1.png" alt="https://gitee.com/littlefxc/oss/raw/master/images/es_9_1.png"></p>
<p><strong>水平扩展原理</strong></p>
<p>单个节点的容量是有限的，如果后期两个节点的容量不能够支持三个分片，那么另外启动一个节点就可以了，ES 会自动的重新规划分片，如下图：可以看到 A3 节点已经被自动的分配到 Node3 节点里面了，另外副本 B1 从 Node2 移动到 Node3 节点，B3 分片从 Node1 节点被分配到 Node2 节点。这里想一下，如果再启动一个节点呢？是的，再启动一个节点将不会对主分片起到任何作用，因为主分片不可以修改，只有三个，但是副本可以修改，能够起到扩容的作用。</p>
<p><img src="https://gitee.com/littlefxc/oss/raw/master/images/es_9_2.png" alt="https://gitee.com/littlefxc/oss/raw/master/images/es_9_2.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://littlefxc.gitee.io/blog/passages/Java多线程JUC原子类之AtomicReference/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="冯雪超">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="littlefxc's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/passages/Java多线程JUC原子类之AtomicReference/" class="post-title-link" itemprop="url">Java多线程JUC原子类之AtomicReference</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-02-03 13:42:09 / 修改时间：13:43:24" itemprop="dateCreated datePublished" datetime="2021-02-03T13:42:09+08:00">2021-02-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>转载自<a href="https://www.cnblogs.com/skywang12345/p/3514623.html" target="_blank" rel="noopener">https://www.cnblogs.com/skywang12345/p/3514623.html</a></p>
</blockquote>
<h1 id="AtomicReference介绍和函数列表"><a href="#AtomicReference介绍和函数列表" class="headerlink" title="AtomicReference介绍和函数列表"></a>AtomicReference介绍和函数列表</h1><p>AtomicReference是作用是对”对象”进行原子操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 null 初始值创建新的 AtomicReference。</span></span><br><span class="line">AtomicReference()</span><br><span class="line"><span class="comment">// 使用给定的初始值创建新的 AtomicReference。</span></span><br><span class="line">AtomicReference(V initialValue)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果当前值 == 预期值，则以原子方式将该值设置为给定的更新值。</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V expect, V update)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 获取当前值。</span></span></span><br><span class="line"><span class="function">V <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 以原子方式设置为给定值，并返回旧值。</span></span></span><br><span class="line"><span class="function">V <span class="title">getAndSet</span><span class="params">(V newValue)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 最终设置为给定值。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lazySet</span><span class="params">(V newValue)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 设置为给定值。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(V newValue)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回当前值的字符串表示形式。</span></span></span><br><span class="line"><span class="function">String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 如果当前值 == 预期值，则以原子方式将该值设置为给定的更新值。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">weakCompareAndSet</span><span class="params">(V expect, V update)</span></span></span><br></pre></td></tr></table></figure>
<h1 id="源码（JDK1-8-0-202）"><a href="#源码（JDK1-8-0-202）" class="headerlink" title="源码（JDK1.8.0_202）"></a>源码（JDK1.8.0_202）</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An object reference that may be updated atomically. See the &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * java.util.concurrent.atomic&#125; package specification for description</span></span><br><span class="line"><span class="comment"> * of the properties of atomic variables.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Doug Lea</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;V&gt; The type of object referred to by this reference</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicReference</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">1848883965231344442L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取Unsafe对象，Unsafe的作用是提供CAS操作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicReference.class.getDeclaredField(<span class="string">"value"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// volatile类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> V value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new AtomicReference with the given initial value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialValue the initial value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtomicReference</span><span class="params">(V initialValue)</span> </span>&#123;</span><br><span class="line">        value = initialValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new AtomicReference with null initial value.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtomicReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets the current value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the current value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets to the given value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newValue the new value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        value = newValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Eventually sets to the given value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newValue the new value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lazySet</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        unsafe.putOrderedObject(<span class="keyword">this</span>, valueOffset, newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically sets the value to the given updated value</span></span><br><span class="line"><span class="comment">     * if the current value &#123;<span class="doctag">@code</span> ==&#125; the expected value.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expect the expected value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> update the new value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if successful. False return indicates that</span></span><br><span class="line"><span class="comment">     * the actual value was not equal to the expected value.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V expect, V update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapObject(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically sets the value to the given updated value</span></span><br><span class="line"><span class="comment">     * if the current value &#123;<span class="doctag">@code</span> ==&#125; the expected value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;&lt;a href="package-summary.html#weakCompareAndSet"&gt;May fail</span></span><br><span class="line"><span class="comment">     * spuriously and does not provide ordering guarantees&lt;/a&gt;, so is</span></span><br><span class="line"><span class="comment">     * only rarely an appropriate alternative to &#123;<span class="doctag">@code</span> compareAndSet&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expect the expected value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> update the new value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if successful</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">weakCompareAndSet</span><span class="params">(V expect, V update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapObject(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically sets to the given value and returns the old value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newValue the new value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the previous value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getAndSet</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (V)unsafe.getAndSetObject(<span class="keyword">this</span>, valueOffset, newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically updates the current value with the results of</span></span><br><span class="line"><span class="comment">     * applying the given function, returning the previous value. The</span></span><br><span class="line"><span class="comment">     * function should be side-effect-free, since it may be re-applied</span></span><br><span class="line"><span class="comment">     * when attempted updates fail due to contention among threads.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> updateFunction a side-effect-free function</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the previous value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getAndUpdate</span><span class="params">(UnaryOperator&lt;V&gt; updateFunction)</span> </span>&#123;</span><br><span class="line">        V prev, next;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            prev = get();</span><br><span class="line">            next = updateFunction.apply(prev);</span><br><span class="line">        &#125; <span class="keyword">while</span> (!compareAndSet(prev, next));</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically updates the current value with the results of</span></span><br><span class="line"><span class="comment">     * applying the given function, returning the updated value. The</span></span><br><span class="line"><span class="comment">     * function should be side-effect-free, since it may be re-applied</span></span><br><span class="line"><span class="comment">     * when attempted updates fail due to contention among threads.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> updateFunction a side-effect-free function</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the updated value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">updateAndGet</span><span class="params">(UnaryOperator&lt;V&gt; updateFunction)</span> </span>&#123;</span><br><span class="line">        V prev, next;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            prev = get();</span><br><span class="line">            next = updateFunction.apply(prev);</span><br><span class="line">        &#125; <span class="keyword">while</span> (!compareAndSet(prev, next));</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically updates the current value with the results of</span></span><br><span class="line"><span class="comment">     * applying the given function to the current and given values,</span></span><br><span class="line"><span class="comment">     * returning the previous value. The function should be</span></span><br><span class="line"><span class="comment">     * side-effect-free, since it may be re-applied when attempted</span></span><br><span class="line"><span class="comment">     * updates fail due to contention among threads.  The function</span></span><br><span class="line"><span class="comment">     * is applied with the current value as its first argument,</span></span><br><span class="line"><span class="comment">     * and the given update as the second argument.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x the update value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> accumulatorFunction a side-effect-free function of two arguments</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the previous value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getAndAccumulate</span><span class="params">(V x,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    BinaryOperator&lt;V&gt; accumulatorFunction)</span> </span>&#123;</span><br><span class="line">        V prev, next;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            prev = get();</span><br><span class="line">            next = accumulatorFunction.apply(prev, x);</span><br><span class="line">        &#125; <span class="keyword">while</span> (!compareAndSet(prev, next));</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically updates the current value with the results of</span></span><br><span class="line"><span class="comment">     * applying the given function to the current and given values,</span></span><br><span class="line"><span class="comment">     * returning the updated value. The function should be</span></span><br><span class="line"><span class="comment">     * side-effect-free, since it may be re-applied when attempted</span></span><br><span class="line"><span class="comment">     * updates fail due to contention among threads.  The function</span></span><br><span class="line"><span class="comment">     * is applied with the current value as its first argument,</span></span><br><span class="line"><span class="comment">     * and the given update as the second argument.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x the update value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> accumulatorFunction a side-effect-free function of two arguments</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the updated value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">accumulateAndGet</span><span class="params">(V x,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    BinaryOperator&lt;V&gt; accumulatorFunction)</span> </span>&#123;</span><br><span class="line">        V prev, next;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            prev = get();</span><br><span class="line">            next = accumulatorFunction.apply(prev, x);</span><br><span class="line">        &#125; <span class="keyword">while</span> (!compareAndSet(prev, next));</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the String representation of the current value.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the String representation of the current value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：AtomicReference的源码比较简单。它是通过”volatile”和”Unsafe提供的CAS函数实现”原子操作。(01) value是volatile类型。这保证了：当某线程修改value的值时，其他线程看到的value值都是最新的value值，即修改之后的volatile的值。(02) 通过CAS设置value。这保证了：当某线程池通过CAS函数(如compareAndSet函数)设置value时，它的操作是原子的，即线程在操作value时不会被中断。</p>
<h1 id="AtomicReference示例"><a href="#AtomicReference示例" class="headerlink" title="AtomicReference示例"></a>AtomicReference示例</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AtomicReferenceTest.java的源码</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicReferenceTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建两个Person对象，它们的id分别是101和102。</span></span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(<span class="number">101</span>);</span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person(<span class="number">102</span>);</span><br><span class="line">        <span class="comment">// 新建AtomicReference对象，初始化它的值为p1对象</span></span><br><span class="line">        AtomicReference ar = <span class="keyword">new</span> AtomicReference(p1);</span><br><span class="line">        <span class="comment">// 通过CAS设置ar。如果ar的值为p1的话，则将其设置为p2。</span></span><br><span class="line">        ar.compareAndSet(p1, p2);</span><br><span class="line"></span><br><span class="line">        Person p3 = (Person)ar.get();</span><br><span class="line">        System.out.println(<span class="string">"p3 is "</span>+p3);</span><br><span class="line">        System.out.println(<span class="string">"p3.equals(p1)="</span>+p3.equals(p1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"id:"</span>+id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>运行结果</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p3 is id:<span class="number">102</span></span><br><span class="line">p3.equals(p1)=<span class="keyword">false</span></span><br></pre></td></tr></table></figure>
<p><strong>结果说明</strong>：新建AtomicReference对象ar时，将它初始化为p1。紧接着，通过CAS函数对它进行设置。如果ar的值为p1的话，则将其设置为p2。最后，获取ar对应的对象，并打印结果。p3.equals(p1)的结果为false，这是因为Person并没有覆盖equals()方法，而是采用继承自Object.java的equals()方法；而Object.java中的equals()实际上是调用”==”去比较两个对象，即比较两个对象的地址是否相等。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://littlefxc.gitee.io/blog/passages/Kafka入门-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="冯雪超">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="littlefxc's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/passages/Kafka入门-1/" class="post-title-link" itemprop="url">Kafka入门(1)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-02 23:24:14" itemprop="dateCreated datePublished" datetime="2021-02-02T23:24:14+08:00">2021-02-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-24 13:05:39" itemprop="dateModified" datetime="2021-02-24T13:05:39+08:00">2021-02-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/mq/" itemprop="url" rel="index"><span itemprop="name">mq</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h1 id="Kafka-核心概念详解"><a href="#Kafka-核心概念详解" class="headerlink" title="Kafka 核心概念详解"></a>Kafka 核心概念详解</h1><h2 id="Kafka-MQ-的应用场景"><a href="#Kafka-MQ-的应用场景" class="headerlink" title="Kafka(MQ) 的应用场景"></a>Kafka(MQ) 的应用场景</h2><h3 id="Kafka-MQ-之异步化、服务解耦、削峰填谷"><a href="#Kafka-MQ-之异步化、服务解耦、削峰填谷" class="headerlink" title="Kafka(MQ)之异步化、服务解耦、削峰填谷"></a>Kafka(MQ)之异步化、服务解耦、削峰填谷</h3><ul>
<li><p>异步化</p>
<p><img src="https://gitee.com/littlefxc/oss/raw/master/images/kafka_1_1.png" alt="kafka_1_1"></p>
</li>
<li><p>服务解耦、削峰填谷</p>
<p><img src="https://gitee.com/littlefxc/oss/raw/master/images/kafka_1_2.png" alt="kafka_1_2"></p>
</li>
</ul>
<h3 id="Kafka-海量日志收集"><a href="#Kafka-海量日志收集" class="headerlink" title="Kafka 海量日志收集"></a>Kafka 海量日志收集</h3><p><img src="https://gitee.com/littlefxc/oss/raw/master/images/kafka_1_3.png" alt="kafka_1_3"></p>
<p><img src="https://gitee.com/littlefxc/oss/raw/master/images/image-20210203211950113.png" alt="image-20210203211950113"></p>
<ul>
<li><p>Kafka 之数据同步应用</p>
<p><img src="https://gitee.com/littlefxc/oss/raw/master/images/kafka_1_4.png" alt="kafka_1_4"></p>
</li>
<li><p>Kafka 之实时计算</p>
<p><img src="https://gitee.com/littlefxc/oss/raw/master/images/kafka_1_5.png" alt="kafka_1_5"></p>
</li>
</ul>
<h2 id="Kafka-基本概念"><a href="#Kafka-基本概念" class="headerlink" title="Kafka 基本概念"></a>Kafka 基本概念</h2><h3 id="集群架构概念"><a href="#集群架构概念" class="headerlink" title="集群架构概念"></a>集群架构概念</h3><p><img src="https://gitee.com/littlefxc/oss/raw/master/images/kafka_1_6.png" alt="kafka_1_6"></p>
<h3 id="Topic、Partition"><a href="#Topic、Partition" class="headerlink" title="Topic、Partition"></a>Topic、Partition</h3><p><img src="https://gitee.com/littlefxc/oss/raw/master/images/kafka_1_7.png" alt="kafka_1_7"></p>
<h3 id="副本-replica"><a href="#副本-replica" class="headerlink" title="副本(replica)"></a>副本(replica)</h3><p><img src="https://gitee.com/littlefxc/oss/raw/master/images/kafka_1_8.png" alt="kafka_1_8"></p>
<h3 id="ISR详解-In-Sync-Replicas"><a href="#ISR详解-In-Sync-Replicas" class="headerlink" title="ISR详解(In Sync Replicas)"></a>ISR详解(In Sync Replicas)</h3><p><img src="https://gitee.com/littlefxc/oss/raw/master/images/kafka_1_9.png" alt="kafka_1_9"></p>
<p>上图表示拉取及时的情况</p>
<p><img src="https://gitee.com/littlefxc/oss/raw/master/images/kafka_1_10.png" alt="kafka_1_10"></p>
<p>上图表示拉取滞后的情况。</p>
<font color="red"><strong>PS: 当Kafka集群中的 leader 挂了之后，Kafka集群会重新选举leader，这是只有在 ISR 集合里面的Kafka才会被选举成为leader。</strong></font>



<ul>
<li><p>HW: High Watermark， 高水位线，消费者只能最多拉取到高水位线的消息</p>
</li>
<li><p>LEO: Log End Offset，日志文件的最后一条记录的 offset(偏移量)</p>
</li>
<li><p>ISR 集合与 HW 和 LEO 直接存在着密不可分的关系</p>
</li>
</ul>
<p><img src="https://gitee.com/littlefxc/oss/raw/master/images/kafka_1_11.png" alt="kafka_1_11"></p>
<p><img src="https://gitee.com/littlefxc/oss/raw/master/images/kafka_1_12.png" alt="kafka_1_12"></p>
<p><img src="https://gitee.com/littlefxc/oss/raw/master/images/kafka_1_13.png" alt="kafka_1_13"></p>
<p>上图右边的图形表示数据传入到leader节点，但还没有同步到follower节点上</p>
<p><img src="https://gitee.com/littlefxc/oss/raw/master/images/kafka_1_14.png" alt="kafka_1_14"></p>
<p>上图HW移动了一格，表示 follower1 节点和follower2 节点都同步了第3条数据，而第4条数据因为follower2节点没有同步到，Kafka消费者就消费不了第4条数据。</p>
<h2 id="Kafka-环境搭建"><a href="#Kafka-环境搭建" class="headerlink" title="Kafka 环境搭建"></a>Kafka 环境搭建</h2><p><a href="https://blog.csdn.net/Little_fxc/article/details/108626224?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161236585916780269848148%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=161236585916780269848148&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v1~rank_blog_v1-1-108626224.pc_v1_rank_blog_v1&amp;utm_term=zookeeper&amp;spm=1018.2226.3001.4450" target="_blank" rel="noopener">zookeeper 集群搭建</a></p>
<p><a href="https://www.cnblogs.com/luzhanshi/p/13369834.html" target="_blank" rel="noopener">Kafka 集群搭建</a></p>
<p><a href="https://www.cnblogs.com/pzb-shadow/p/13030365.html" target="_blank" rel="noopener">Kafka Manager - Kafka集群管理工具</a><br><a href="https://blog.csdn.net/asd136912/article/details/103735037" target="_blank" rel="noopener">kafka 命令行工具常用命令行操作</a></p>
<h2 id="Kafka-极速入门"><a href="#Kafka-极速入门" class="headerlink" title="Kafka 极速入门"></a>Kafka 极速入门</h2><h3 id="构建生产者步骤"><a href="#构建生产者步骤" class="headerlink" title="构建生产者步骤"></a>构建生产者步骤</h3><ol>
<li>配置生产者参数属性和创建生产者对象</li>
<li>构建消息：ProducerRecord</li>
<li>发送消息</li>
<li>关闭生产者</li>
</ol>
<h3 id="构建消费者步骤"><a href="#构建消费者步骤" class="headerlink" title="构建消费者步骤"></a>构建消费者步骤</h3><ol>
<li>配置消费者参数属性和创建消费者对象</li>
<li>订阅主题</li>
<li>拉取消息并进行消费处理</li>
<li>提交消费偏移量，关闭消费者</li>
</ol>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * kafka配置类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> olafwang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2020/9/29 2:45 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KafkaProducer&lt;String, String&gt; <span class="title">producerRecord</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">// 配置kafka集群地址，不用将全部机器都写上，zk会自动发现全部的kafka broke</span></span><br><span class="line">        properties.setProperty(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">"localhost:9092,localhost:9093"</span>);</span><br><span class="line">        <span class="comment">// 设置发送消息的应答方式</span></span><br><span class="line">        properties.setProperty(ProducerConfig.ACKS_CONFIG, <span class="string">"all"</span>);</span><br><span class="line">        <span class="comment">// 重试次数</span></span><br><span class="line">        properties.setProperty(ProducerConfig.RETRIES_CONFIG, <span class="string">"3"</span>);</span><br><span class="line">        <span class="comment">// 重试间隔时间</span></span><br><span class="line">        properties.setProperty(ProducerConfig.RETRY_BACKOFF_MS_CONFIG, <span class="string">"100"</span>);</span><br><span class="line">        <span class="comment">// 一批次发送的消息大小 16KB</span></span><br><span class="line">        properties.setProperty(ProducerConfig.BATCH_SIZE_CONFIG, <span class="string">"16348"</span>);</span><br><span class="line">        <span class="comment">// 一个批次等待时间,10ms</span></span><br><span class="line">        properties.setProperty(ProducerConfig.LINGER_MS_CONFIG, <span class="string">"10"</span>);</span><br><span class="line">        <span class="comment">// RecordAccumulator 缓冲区大小  32M，如果缓冲区满了会阻塞发送端</span></span><br><span class="line">        properties.setProperty(ProducerConfig.BUFFER_MEMORY_CONFIG, <span class="string">"33554432"</span>);</span><br><span class="line">        <span class="comment">// 配置拦截器, 多个逗号隔开</span></span><br><span class="line">        properties.setProperty(ProducerConfig.INTERCEPTOR_CLASSES_CONFIG, <span class="string">"com.xiaolyuh.interceptor.TraceInterceptor"</span>);</span><br><span class="line"></span><br><span class="line">        Serializer&lt;String&gt; keySerializer = <span class="keyword">new</span> StringSerializer();</span><br><span class="line">        Serializer&lt;String&gt; valueSerializer = <span class="keyword">new</span> StringSerializer();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> KafkaProducer&lt;&gt;(properties, keySerializer, valueSerializer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootStudentKafkaApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> KafkaProducer&lt;String, String&gt; kafkaProducer;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSyncKafkaSend</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 同步发送测试</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            ProducerRecord&lt;String, String&gt; producerRecord = <span class="keyword">new</span> ProducerRecord&lt;&gt;(<span class="string">"test_cluster_topic"</span>, <span class="string">"key-"</span> + i, <span class="string">"value-"</span> + i);</span><br><span class="line">            <span class="comment">// 同步发送，这里我们还可以指定发送到那个分区，还可以添加header</span></span><br><span class="line">            kafkaProducer.send(producerRecord, <span class="keyword">new</span> KafkaCallback&lt;&gt;(producerRecord)).get(<span class="number">50</span>, TimeUnit.MINUTES);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"ThreadName::"</span> + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAsyncKafkaSend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 异步发送测试</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            ProducerRecord&lt;String, String&gt; producerRecord = <span class="keyword">new</span> ProducerRecord&lt;&gt;(<span class="string">"test_cluster_topic2"</span>, <span class="string">"key-"</span> + i, <span class="string">"value-"</span> + i);</span><br><span class="line">            <span class="comment">// 异步发送，这里我们还可以指定发送到那个分区，还可以添加header</span></span><br><span class="line">            kafkaProducer.send(producerRecord, <span class="keyword">new</span> KafkaCallback&lt;&gt;(producerRecord));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"ThreadName::"</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="comment">// 记得刷新，否则消息有可能没有发出去</span></span><br><span class="line">        kafkaProducer.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异步回调函数，该方法会在 Producer 收到 ack 时调用，当Exception不为空表示发送消息失败。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;K&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;V&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KafkaCallback</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Callback</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ProducerRecord&lt;K, V&gt; producerRecord;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KafkaCallback</span><span class="params">(ProducerRecord&lt;K, V&gt; producerRecord)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.producerRecord = producerRecord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompletion</span><span class="params">(RecordMetadata metadata, Exception exception)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ThreadName::"</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(exception)) &#123;</span><br><span class="line">            System.out.println(metadata.partition() + <span class="string">"-"</span> + metadata.offset() + <span class="string">":::"</span> + producerRecord.key() + <span class="string">"="</span> + producerRecord.value());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Objects.nonNull(exception)) &#123;</span><br><span class="line">            <span class="comment">// TODO  告警，消息落库从发</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h4><p>Kafka中的消息消费是一个不断轮询的过程，消费者所要做的就是重复地调用<code>poll()</code>方法，而<code>poll()</code>方法返回的是所订阅的主题（分区）上的一组消息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaConsumerDemo</span> </span>&#123;</span><br><span class="line">    ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">10</span>,</span><br><span class="line">            <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startConsumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        executor.submit(() -&gt; &#123;</span><br><span class="line">            Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">            properties.setProperty(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">"localhost:9092,localhost:9093"</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 非常重要的属性配置：与我们的消费者订阅组有关系</span></span><br><span class="line">            properties.setProperty(ConsumerConfig.GROUP_ID_CONFIG, <span class="string">"groupId"</span>);</span><br><span class="line">            <span class="comment">// 消费者提交 offset：自动提交 &amp; 手工提交，默认是自动提交</span></span><br><span class="line">            properties.setProperty(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, <span class="string">"false"</span>);</span><br><span class="line">            <span class="comment">// 请求超时时间</span></span><br><span class="line">            properties.setProperty(ConsumerConfig.REQUEST_TIMEOUT_MS_CONFIG, <span class="string">"60000"</span>);</span><br><span class="line">            <span class="comment">// 序列化</span></span><br><span class="line">            Deserializer&lt;String&gt; keyDeserializer = <span class="keyword">new</span> StringDeserializer();</span><br><span class="line">            Deserializer&lt;String&gt; valueDeserializer = <span class="keyword">new</span> StringDeserializer();</span><br><span class="line">            <span class="comment">// 创建消费者对象</span></span><br><span class="line">            KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(properties, keyDeserializer, valueDeserializer);</span><br><span class="line">            <span class="comment">// 订阅感兴趣的主题</span></span><br><span class="line">            consumer.subscribe(Arrays.asList(<span class="string">"test_cluster_topic"</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// KafkaConsumer的assignment（）方法来判定是否分配到了相应的分区，如果为空表示没有分配到分区</span></span><br><span class="line">            Set&lt;TopicPartition&gt; assignment = consumer.assignment();</span><br><span class="line">            <span class="keyword">while</span> (assignment.isEmpty()) &#123;</span><br><span class="line">                <span class="comment">// 阻塞1秒</span></span><br><span class="line">                consumer.poll(<span class="number">1000</span>);</span><br><span class="line">                assignment = consumer.assignment();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// KafkaConsumer 分配到了分区，开始消费</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 拉取记录，如果没有记录则柱塞1000ms。</span></span><br><span class="line">                ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">1000</span>);</span><br><span class="line">                <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">                    String traceId = <span class="keyword">new</span> String(record.headers().lastHeader(<span class="string">"traceId"</span>).value());</span><br><span class="line">                    System.out.printf(<span class="string">"traceId = %s, offset = %d, key = %s, value = %s%n"</span>, traceId, record.offset(), record.key(), record.value());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 异步确认提交</span></span><br><span class="line">                consumer.commitAsync((offsets, exception) -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (Objects.isNull(exception)) &#123;</span><br><span class="line">                        <span class="comment">// TODO 告警、落盘、重试</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> olafwang</span></span><br><span class="line"><span class="comment"> * 链路ID</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TraceInterceptor</span> <span class="keyword">implements</span> <span class="title">ProducerInterceptor</span>&lt;<span class="title">String</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> errorCounter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> successCounter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最先调用，读取配置信息，只调用一次</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(Map&lt;String, ?&gt; configs)</span> </span>&#123;</span><br><span class="line">        System.out.println(JSON.toJSONString(configs));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 它运行在用户主线程中，在消息序列化和计算分区之前调用，这里最好不小修改topic 和分区参数，否则会出一些奇怪的现象。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> record</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProducerRecord&lt;String, String&gt; <span class="title">onSend</span><span class="params">(ProducerRecord&lt;String, String&gt; record)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Headers headers = <span class="keyword">new</span> RecordHeaders();</span><br><span class="line">        headers.add(<span class="string">"traceId"</span>, UUID.randomUUID().toString().getBytes(Charset.forName(<span class="string">"UTF8"</span>)));</span><br><span class="line">        <span class="comment">// 修改消息</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProducerRecord&lt;&gt;(record.topic(), record.partition(), record.key(), record.value(), headers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该方法会在消息从 RecordAccumulator 成功发送到 Kafka Broker 之后，或者在发送过程 中失败时调用。</span></span><br><span class="line"><span class="comment">     * 并且通常都是在 producer 回调逻辑触发之前调用。</span></span><br><span class="line"><span class="comment">     * onAcknowledgement 运行在 producer 的 IO 线程中，因此不要在该方法中放入很重的逻辑，否则会拖慢 producer 的消息 发送效率。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> metadata</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAcknowledgement</span><span class="params">(RecordMetadata metadata, Exception exception)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(exception)) &#123;</span><br><span class="line">            <span class="comment">// TODO  出错了</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭 interceptor，主要用于执行一些资源清理工作，只调用一次</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"==========close============"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Kafka-基本配置参数讲解"><a href="#Kafka-基本配置参数讲解" class="headerlink" title="Kafka 基本配置参数讲解"></a>Kafka 基本配置参数讲解</h2><ul>
<li><p>配置文件: <code>$KAFKA_HOME/config/server.properties</code></p>
<ul>
<li><p>zookeeper.connect</p>
<p>CS格式参数，可以指定值为zk1:2181,zk2:2181,zk3:2181，不同Kafka集群可以指定：zk1:2181,zk2:2181,zk3:2181/kafka1，chroot只需要写一次</p>
</li>
<li><p>listeners</p>
<p>设置内网访问Kafka服务的监听器</p>
</li>
<li><p>broker.id</p>
<p>每个broker都可以用一个唯一的非负整数id进行标识；这个id可以作为broker的“名字”，并且它的存在使得broker无须混淆consumers就可以迁移到不同的host/port上。你可以选择任意你喜欢的数字作为id，只要id是唯一的即可。</p>
</li>
<li><p>log.dir 和 log.dirs</p>
<p>kafka存放数据的路径。这个路径并不是唯一的，可以是多个，路径之间只需要使用逗号分隔即可；每当创建新partition时，都会选择在包含最少partitions的路径下进行。</p>
</li>
<li><p>message.max.bytes</p>
<p>server可以接收的消息最大尺寸。重要的是，consumer和producer有关这个属性的设置必须同步，否则producer发布的消息对consumer来说太大。</p>
</li>
</ul>
</li>
</ul>
<h2 id="Kafka-之生产者"><a href="#Kafka-之生产者" class="headerlink" title="Kafka 之生产者"></a>Kafka 之生产者</h2><h3 id="发送消息：ProducerRecord"><a href="#发送消息：ProducerRecord" class="headerlink" title="发送消息：ProducerRecord"></a>发送消息：ProducerRecord</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerRecord</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String topic;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Integer partition;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Headers headers;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> V value;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Long timestamp;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="必要的参数配置项"><a href="#必要的参数配置项" class="headerlink" title="必要的参数配置项"></a>必要的参数配置项</h3><ul>
<li>bootstrap.servers, key.serializer, value.serializer, client.id</li>
<li>简化的配置Key: ProducerConfig</li>
<li>KafkaProducer 是线程安全的</li>
</ul>
<h3 id="KafkaProducer-消息发送重试机制"><a href="#KafkaProducer-消息发送重试机制" class="headerlink" title="KafkaProducer 消息发送重试机制"></a>KafkaProducer 消息发送重试机制</h3><ul>
<li>retries 参数</li>
<li>可重试异常(例如：网络抖动) &amp; 不可重试异常(例如：磁盘满了、消息体积太大)</li>
</ul>
<h2 id="Kafka-之生产者重要参数详解"><a href="#Kafka-之生产者重要参数详解" class="headerlink" title="Kafka 之生产者重要参数详解"></a>Kafka 之生产者重要参数详解</h2><h2 id="Kafka-之拦截器"><a href="#Kafka-之拦截器" class="headerlink" title="Kafka 之拦截器"></a>Kafka 之拦截器</h2><h2 id="Kafka-之序列化和反序列化"><a href="#Kafka-之序列化和反序列化" class="headerlink" title="Kafka 之序列化和反序列化"></a>Kafka 之序列化和反序列化</h2><h2 id="Kafka-之分区器"><a href="#Kafka-之分区器" class="headerlink" title="Kafka 之分区器"></a>Kafka 之分区器</h2><h2 id="Kafka-之消费器"><a href="#Kafka-之消费器" class="headerlink" title="Kafka 之消费器"></a>Kafka 之消费器</h2><h2 id="Kafka-高级应用整合-Spring-Boot"><a href="#Kafka-高级应用整合-Spring-Boot" class="headerlink" title="Kafka 高级应用整合 Spring Boot"></a>Kafka 高级应用整合 Spring Boot</h2><h1 id="Kafka-海量日志收集系统实战"><a href="#Kafka-海量日志收集系统实战" class="headerlink" title="Kafka 海量日志收集系统实战"></a>Kafka 海量日志收集系统实战</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://littlefxc.gitee.io/blog/passages/设计模式学习记录-工厂模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="冯雪超">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="littlefxc's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/passages/设计模式学习记录-工厂模式/" class="post-title-link" itemprop="url">设计模式学习记录-工厂模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-01-29 14:07:40 / 修改时间：14:15:31" itemprop="dateCreated datePublished" datetime="2021-01-29T14:07:40+08:00">2021-01-29</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="创建者模式"><a href="#创建者模式" class="headerlink" title="创建者模式"></a>创建者模式</h1><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p><img src="https://gitee.com/littlefxc/oss/raw/master/images/工厂模式类图.png" alt="https://gitee.com/littlefxc/oss/raw/master/images/工厂模式类图.png"></p>
<h2 id="抽象工厂方法模式"><a href="#抽象工厂方法模式" class="headerlink" title="抽象工厂方法模式"></a>抽象工厂方法模式</h2><p><img src="https://gitee.com/littlefxc/oss/raw/master/images/抽象工厂模式.png" alt="https://gitee.com/littlefxc/oss/raw/master/images/抽象工厂模式.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://littlefxc.gitee.io/blog/passages/RabbitMQ基础组件封装-24/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="冯雪超">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="littlefxc's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/passages/RabbitMQ基础组件封装-24/" class="post-title-link" itemprop="url">RabbitMQ基础组件封装(24)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-27 22:02:43" itemprop="dateCreated datePublished" datetime="2021-01-27T22:02:43+08:00">2021-01-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-02 23:20:16" itemprop="dateModified" datetime="2021-02-02T23:20:16+08:00">2021-02-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/mq/" itemprop="url" rel="index"><span itemprop="name">mq</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h1 id="1-整体功能概述"><a href="#1-整体功能概述" class="headerlink" title="1. 整体功能概述"></a>1. 整体功能概述</h1><p><img src="https://gitee.com/littlefxc/oss/raw/master/images/rabbitmq_24_1.png" alt="rabbitmq_24_1"></p>
<p><img src="https://gitee.com/littlefxc/oss/raw/master/images/rabbitmq_24_2.png" alt="rabbitmq_24_2"></p>
<h1 id="2-基础组件模块划分"><a href="#2-基础组件模块划分" class="headerlink" title="2. 基础组件模块划分"></a>2. 基础组件模块划分</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rabbit-parent</span><br><span class="line">- rabbit-api           对外提供统一的API接口</span><br><span class="line">- rabbit-commmon       公共包</span><br><span class="line">- rabbit-core-producer 核心包</span><br><span class="line">- rabbit-task          es-job</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/littlefxc/foodie.git" target="_blank" rel="noopener">Github 地址</a></p>
<h1 id="3-可靠性消息投递"><a href="#3-可靠性消息投递" class="headerlink" title="3. 可靠性消息投递"></a>3. 可靠性消息投递</h1><p><img src="https://gitee.com/littlefxc/oss/raw/master/images/rabbitmq_19_13.png" alt="rabbitmq_19_13"></p>
<p><img src="https://gitee.com/littlefxc/oss/raw/master/images/rabbitmq_24_4.png" alt="rabbitmq_24_4"></p>
<h1 id="4-思维导图"><a href="#4-思维导图" class="headerlink" title="4. 思维导图"></a>4. 思维导图</h1><p><img src="https://gitee.com/littlefxc/oss/raw/master/images/rabbitmq_xmind.png" alt="rabbitmq_xmind.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://littlefxc.gitee.io/blog/passages/rabbitmq整合springboot2-x23/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="冯雪超">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="littlefxc's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/passages/rabbitmq整合springboot2-x23/" class="post-title-link" itemprop="url">rabbitmq整合springboot2.x(23)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-01-27 20:18:21 / 修改时间：21:22:44" itemprop="dateCreated datePublished" datetime="2021-01-27T20:18:21+08:00">2021-01-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/mq/" itemprop="url" rel="index"><span itemprop="name">mq</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="https://gitee.com/littlefxc/oss/raw/master/images/rabbitmq_23_3.png" alt="rabbitmq_23_3"></p>
<p><img src="https://gitee.com/littlefxc/oss/raw/master/images/rabbitmq_23_4.png" alt="rabbitmq_23_4"></p>
<p><img src="https://gitee.com/littlefxc/oss/raw/master/images/rabbitmq_23_5.png" alt="rabbitmq_23_5"></p>
<p><img src="https://gitee.com/littlefxc/oss/raw/master/images/rabbitmq_23_6.png" alt="rabbitmq_23_6"></p>
<p><img src="https://gitee.com/littlefxc/oss/raw/master/images/rabbitmq_23_8.png" alt="rabbitmq_23_8"></p>
<h2 id="生产者关键代码"><a href="#生产者关键代码" class="headerlink" title="生产者关键代码"></a>生产者关键代码</h2><h3 id="application-properties"><a href="#application-properties" class="headerlink" title="application.properties"></a>application.properties</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">server.servlet.context-path=/</span><br><span class="line">server.port=<span class="number">8001</span></span><br><span class="line"></span><br><span class="line">spring.rabbitmq.addresses=<span class="number">192.168</span>.11.71:<span class="number">5672</span>,<span class="number">192.168</span>.11.72:<span class="number">5672</span>,<span class="number">192.168</span>.11.71:<span class="number">5673</span></span><br><span class="line">spring.rabbitmq.username=guest</span><br><span class="line">spring.rabbitmq.password=guest</span><br><span class="line">spring.rabbitmq.virtual-host=/</span><br><span class="line">spring.rabbitmq.connection-timeout=<span class="number">15000</span></span><br><span class="line"></span><br><span class="line">##	使用启用消息确认模式</span><br><span class="line">spring.rabbitmq.publisher-confirms=<span class="keyword">true</span></span><br><span class="line"></span><br><span class="line">## 	设置return消息模式，注意要和mandatory一起去配合使用</span><br><span class="line">##spring.rabbitmq.publisher-returns=true</span><br><span class="line">##spring.rabbitmq.template.mandatory=true</span><br><span class="line"></span><br><span class="line">spring.application.name=rabbit-producer</span><br><span class="line">spring.http.encoding.charset=UTF-<span class="number">8</span></span><br><span class="line">spring.jackson.date-format=yyyy-MM-dd HH:mm:ss</span><br><span class="line">spring.jackson.time-zone=GMT+<span class="number">8</span></span><br><span class="line">spring.jackson.<span class="keyword">default</span>-property-inclusion=NON_NULL</span><br></pre></td></tr></table></figure>
<h3 id="RabbitSender"><a href="#RabbitSender" class="headerlink" title="RabbitSender"></a>RabbitSender</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.AmqpException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.MessagePostProcessor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.connection.CorrelationData;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate.ConfirmCallback;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.Message;</span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.MessageHeaders;</span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.support.MessageBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitSender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 	这里就是确认消息的回调监听接口，用于确认消息是否被broker所收到</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">final</span> ConfirmCallback confirmCallback = <span class="keyword">new</span> RabbitTemplate.ConfirmCallback() &#123;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 	<span class="doctag">@param</span> CorrelationData 作为一个唯一的标识</span></span><br><span class="line"><span class="comment">		 * 	<span class="doctag">@param</span> ack broker 是否落盘成功 </span></span><br><span class="line"><span class="comment">		 * 	<span class="doctag">@param</span> cause 失败的一些异常信息</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> ack, String cause)</span> </span>&#123;</span><br><span class="line">			System.err.println(<span class="string">"消息ACK结果:"</span> + ack + <span class="string">", correlationData: "</span> + correlationData.getId());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 	对外发送消息的方法</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> message 	具体的消息内容</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> properties	额外的附加属性</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Object message, Map&lt;String, Object&gt; properties)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		</span><br><span class="line">		MessageHeaders mhs = <span class="keyword">new</span> MessageHeaders(properties);</span><br><span class="line">		Message&lt;?&gt; msg = MessageBuilder.createMessage(message, mhs);</span><br><span class="line">		</span><br><span class="line">		rabbitTemplate.setConfirmCallback(confirmCallback);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 	指定业务唯一的iD</span></span><br><span class="line">		CorrelationData correlationData = <span class="keyword">new</span> CorrelationData(UUID.randomUUID().toString());</span><br><span class="line">		</span><br><span class="line">		MessagePostProcessor mpp = <span class="keyword">new</span> MessagePostProcessor() &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> org.springframework.amqp.core.<span class="function">Message <span class="title">postProcessMessage</span><span class="params">(org.springframework.amqp.core.Message message)</span></span></span><br><span class="line"><span class="function">					<span class="keyword">throws</span> AmqpException </span>&#123;</span><br><span class="line">				System.err.println(<span class="string">"---&gt; post to do: "</span> + message);</span><br><span class="line">				<span class="keyword">return</span> message;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		</span><br><span class="line">		rabbitTemplate.convertAndSend(<span class="string">"exchange-1"</span>,</span><br><span class="line">				<span class="string">"springboot.rabbit"</span>, </span><br><span class="line">				msg, mpp, correlationData);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="消费者关键代码"><a href="#消费者关键代码" class="headerlink" title="消费者关键代码"></a>消费者关键代码</h2><h3 id="application-properties-1"><a href="#application-properties-1" class="headerlink" title="application.properties"></a>application.properties</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">server.servlet.context-path=/</span><br><span class="line">server.port=<span class="number">8002</span></span><br><span class="line"></span><br><span class="line">spring.rabbitmq.addresses=<span class="number">192.168</span>.11.71:<span class="number">5672</span>,<span class="number">192.168</span>.11.72:<span class="number">5672</span>,<span class="number">192.168</span>.11.71:<span class="number">5673</span></span><br><span class="line">spring.rabbitmq.username=guest</span><br><span class="line">spring.rabbitmq.password=guest</span><br><span class="line">spring.rabbitmq.virtual-host=/</span><br><span class="line">spring.rabbitmq.connection-timeout=<span class="number">15000</span></span><br><span class="line"></span><br><span class="line">## 	表示消费者消费成功消息以后需要手工的进行签收(ack)，默认为auto</span><br><span class="line">spring.rabbitmq.listener.simple.acknowledge-mode=manual</span><br><span class="line">spring.rabbitmq.listener.simple.concurrency=<span class="number">5</span></span><br><span class="line">spring.rabbitmq.listener.simple.max-concurrency=<span class="number">10</span></span><br><span class="line">spring.rabbitmq.listener.simple.prefetch=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##	作业：</span><br><span class="line">##	最好不要在代码里写死配置信息，尽量使用这种方式也就是配置文件的方式</span><br><span class="line">##	在代码里使用 	$&#123;&#125;	方式进行设置配置: $&#123;spring.rabbitmq.listener.order.exchange.name&#125;</span><br><span class="line">spring.rabbitmq.listener.order.exchange.name=order-exchange</span><br><span class="line">spring.rabbitmq.listener.order.exchange.durable=<span class="keyword">true</span></span><br><span class="line">spring.rabbitmq.listener.order.exchange.type=topic</span><br><span class="line">spring.rabbitmq.listener.order.exchange.key=order.*</span><br><span class="line"></span><br><span class="line">spring.application.name=rabbit-producer</span><br><span class="line">spring.http.encoding.charset=UTF-<span class="number">8</span></span><br><span class="line">spring.jackson.date-format=yyyy-MM-dd HH:mm:ss</span><br><span class="line">spring.jackson.time-zone=GMT+<span class="number">8</span></span><br><span class="line">spring.jackson.<span class="keyword">default</span>-property-inclusion=NON_NULL</span><br></pre></td></tr></table></figure>
<h3 id="RabbitReceive"><a href="#RabbitReceive" class="headerlink" title="RabbitReceive"></a>RabbitReceive</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitReceive</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 	组合使用监听</span></span><br><span class="line"><span class="comment">	 * 	<span class="doctag">@RabbitListener</span> <span class="doctag">@QueueBinding</span> <span class="doctag">@Queue</span> <span class="doctag">@Exchange</span></span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> channel</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@RabbitListener</span>(bindings = <span class="meta">@QueueBinding</span>(</span><br><span class="line">					value = <span class="meta">@Queue</span>(value = <span class="string">"queue-1"</span>, durable = <span class="string">"true"</span>),</span><br><span class="line">					exchange = <span class="meta">@Exchange</span>(name = <span class="string">"exchange-1"</span>,</span><br><span class="line">					durable = <span class="string">"true"</span>,</span><br><span class="line">					type = <span class="string">"topic"</span>,</span><br><span class="line">					ignoreDeclarationExceptions = <span class="string">"true"</span>),</span><br><span class="line">					key = <span class="string">"springboot.*"</span></span><br><span class="line">				)</span><br><span class="line">			)</span><br><span class="line">	<span class="meta">@RabbitHandler</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">//	1. 收到消息以后进行业务端消费处理</span></span><br><span class="line">		System.err.println(<span class="string">"-----------------------"</span>);</span><br><span class="line">		System.err.println(<span class="string">"消费消息:"</span> + message.getPayload());</span><br><span class="line"></span><br><span class="line">		<span class="comment">//  2. 处理成功之后 获取deliveryTag 并进行手工的ACK操作, 因为我们配置文件里配置的是 手工签收</span></span><br><span class="line">		<span class="comment">//	spring.rabbitmq.listener.simple.acknowledge-mode=manual</span></span><br><span class="line">		Long deliveryTag = (Long)message.getHeaders().get(AmqpHeaders.DELIVERY_TAG);</span><br><span class="line">		channel.basicAck(deliveryTag, <span class="keyword">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/blog/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/15/">15</a><a class="extend next" rel="next" href="/blog/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">冯雪超</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">144</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">84</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/littlefxc" title="GitHub → https://github.com/littlefxc" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:2575974990@qq.com" title="E-Mail → mailto:2575974990@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">冯雪超</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>
  <script src="/blog/lib/velocity/velocity.min.js"></script>
  <script src="/blog/lib/velocity/velocity.ui.min.js"></script>
<script src="/blog/js/utils.js"></script><script src="/blog/js/motion.js"></script>
<script src="/blog/js/schemes/muse.js"></script>
<script src="/blog/js/next-boot.js"></script>



  















  

  

</body>
</html>
