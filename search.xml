<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring-Security-Oauth2如何增加自定义授权模式]]></title>
    <url>%2Fpassages%2FSpring-Security-Oauth2%E5%A6%82%E4%BD%95%E5%A2%9E%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%88%E6%9D%83%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在 oauth2 的授权模式中有4种： 授权码模式 隐式授权模式 密码模式 客户端模式 但如果我们想要增加一个自定义的授权模式，又该怎么做呢？ 相关的源码是这样的： 123456789101112131415161718192021222324252627public class CompositeTokenGranter implements TokenGranter &#123; private final List&lt;TokenGranter&gt; tokenGranters; public CompositeTokenGranter(List&lt;TokenGranter&gt; tokenGranters) &#123; this.tokenGranters = new ArrayList&lt;TokenGranter&gt;(tokenGranters); &#125; //四种授权模式+刷新令牌的模式根据grant_type判断 public OAuth2AccessToken grant(String grantType, TokenRequest tokenRequest) &#123; for (TokenGranter granter : tokenGranters) &#123; OAuth2AccessToken grant = granter.grant(grantType, tokenRequest); if (grant!=null) &#123; return grant; &#125; &#125; return null; &#125; public void addTokenGranter(TokenGranter tokenGranter) &#123; if (tokenGranter == null) &#123; throw new IllegalArgumentException("Token granter is null"); &#125; tokenGranters.add(tokenGranter); &#125;&#125; oauth2 端点配置类部分源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public final class AuthorizationServerEndpointsConfigurer &#123; // 省略部分代码 private TokenGranter tokenGranter; public AuthorizationServerEndpointsConfigurer tokenGranter(TokenGranter tokenGranter) &#123; this.tokenGranter = tokenGranter; return this; &#125; // 默认的四种授权模式+刷新令牌的模式的配置 private TokenGranter tokenGranter() &#123; if (tokenGranter == null) &#123; tokenGranter = new TokenGranter() &#123; private CompositeTokenGranter delegate; @Override public OAuth2AccessToken grant(String grantType, TokenRequest tokenRequest) &#123; if (delegate == null) &#123; delegate = new CompositeTokenGranter(getDefaultTokenGranters()); &#125; return delegate.grant(grantType, tokenRequest); &#125; &#125;; &#125; return tokenGranter; &#125; // 默认的四种授权模式+刷新令牌的模式的配置 private List&lt;TokenGranter&gt; getDefaultTokenGranters() &#123; ClientDetailsService clientDetails = clientDetailsService(); AuthorizationServerTokenServices tokenServices = tokenServices(); AuthorizationCodeServices authorizationCodeServices = authorizationCodeServices(); OAuth2RequestFactory requestFactory = requestFactory(); List&lt;TokenGranter&gt; tokenGranters = new ArrayList&lt;TokenGranter&gt;(); // 添加授权码模式 tokenGranters.add(new AuthorizationCodeTokenGranter(tokenServices, authorizationCodeServices, clientDetails, requestFactory)); // 添加刷新令牌的模式 tokenGranters.add(new RefreshTokenGranter(tokenServices, clientDetails, requestFactory)); // 添加隐式授权模式 ImplicitTokenGranter implicit = new ImplicitTokenGranter(tokenServices, clientDetails, requestFactory); tokenGranters.add(implicit); // 添加客户端模式 tokenGranters.add(new ClientCredentialsTokenGranter(tokenServices, clientDetails, requestFactory)); if (authenticationManager != null) &#123; // 添加密码模式 tokenGranters.add(new ResourceOwnerPasswordTokenGranter(authenticationManager, tokenServices, clientDetails, requestFactory)); &#125; // 可以复制相关代码，然后这里添加自定义的授权模式 return tokenGranters; &#125;&#125; 看到这里就可以发现 spring 已经把默认的四种授权模式+刷新令牌的模式的配置在代码中写死了! 那又如何添加自定义的授权模式呢？ 我的思路是这样的： 直接把这部分的代码复制，在其中添加自定义的授权模式。 我直接把密码模式复制，将其中的 GRANT_TYPE 的值改为 sms_code,然后使用 /oauth/token?grant_type=sms_code&amp;scope=read&amp;username=user&amp;password=123456 来验证结果。 自定义授权模式：SmsCodeTokenGranter12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * @author fengxuechao * @version 0.1 * @date 2019/5/17 */public class SmsCodeTokenGranter extends AbstractTokenGranter &#123; // 仅仅复制了 ResourceOwnerPasswordTokenGranter，只是改变了 GRANT_TYPE 的值，来验证自定义授权模式的可行性 private static final String GRANT_TYPE = "sms_code"; private final AuthenticationManager authenticationManager; public SmsCodeTokenGranter( AuthenticationManager authenticationManager, AuthorizationServerTokenServices tokenServices, ClientDetailsService clientDetailsService, OAuth2RequestFactory requestFactory) &#123; this(authenticationManager, tokenServices, clientDetailsService, requestFactory, GRANT_TYPE); &#125; protected SmsCodeTokenGranter( AuthenticationManager authenticationManager, AuthorizationServerTokenServices tokenServices, ClientDetailsService clientDetailsService, OAuth2RequestFactory requestFactory, String grantType) &#123; super(tokenServices, clientDetailsService, requestFactory, grantType); this.authenticationManager = authenticationManager; &#125; @Override protected OAuth2Authentication getOAuth2Authentication(ClientDetails client, TokenRequest tokenRequest) &#123; Map&lt;String, String&gt; parameters = new LinkedHashMap&lt;String, String&gt;(tokenRequest.getRequestParameters()); String username = parameters.get("username"); String password = parameters.get("password"); // Protect from downstream leaks of password parameters.remove("password"); Authentication userAuth = new UsernamePasswordAuthenticationToken(username, password); ((AbstractAuthenticationToken) userAuth).setDetails(parameters); try &#123; userAuth = authenticationManager.authenticate(userAuth); &#125; catch (AccountStatusException ase) &#123; //covers expired, locked, disabled cases (mentioned in section 5.2, draft 31) throw new InvalidGrantException(ase.getMessage()); &#125; catch (BadCredentialsException e) &#123; // If the username/password are wrong the spec says we should send 400/invalid grant throw new InvalidGrantException(e.getMessage()); &#125; if (userAuth == null || !userAuth.isAuthenticated()) &#123; throw new InvalidGrantException("Could not authenticate user: " + username); &#125; OAuth2Request storedOAuth2Request = getRequestFactory().createOAuth2Request(client, tokenRequest); return new OAuth2Authentication(storedOAuth2Request, userAuth); &#125;&#125; 授权模式配置类：TokenGranterConfig123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148/** * @author fengxuechao * @version 0.1 * @date 2019/5/17 */@Configuration@Profile("inMemory")public class TokenGranterConfig &#123; @Autowired private ClientDetailsService clientDetailsService; @Autowired private UserDetailsService userDetailsService; @Autowired private AuthenticationManager authenticationManager; @Autowired private TokenStore tokenStore; @Autowired TokenEnhancer tokenEnhancer; private AuthorizationCodeServices authorizationCodeServices; private boolean reuseRefreshToken = true; private AuthorizationServerTokenServices tokenServices; private TokenGranter tokenGranter; /** * 授权模式 * * @return */ @Bean public TokenGranter tokenGranter() &#123; if (tokenGranter == null) &#123; tokenGranter = new TokenGranter() &#123; private CompositeTokenGranter delegate; @Override public OAuth2AccessToken grant(String grantType, TokenRequest tokenRequest) &#123; if (delegate == null) &#123; delegate = new CompositeTokenGranter(getDefaultTokenGranters()); &#125; return delegate.grant(grantType, tokenRequest); &#125; &#125;; &#125; return tokenGranter; &#125; /** * 程序支持的授权类型 * * @return */ private List&lt;TokenGranter&gt; getDefaultTokenGranters() &#123; AuthorizationServerTokenServices tokenServices = tokenServices(); AuthorizationCodeServices authorizationCodeServices = authorizationCodeServices(); OAuth2RequestFactory requestFactory = requestFactory(); List&lt;TokenGranter&gt; tokenGranters = new ArrayList&lt;TokenGranter&gt;(); // 添加授权码模式 tokenGranters.add(new AuthorizationCodeTokenGranter(tokenServices, authorizationCodeServices, clientDetailsService, requestFactory)); // 添加刷新令牌的模式 tokenGranters.add(new RefreshTokenGranter(tokenServices, clientDetailsService, requestFactory)); // 添加隐士授权模式 tokenGranters.add(new ImplicitTokenGranter(tokenServices, clientDetailsService, requestFactory)); // 添加客户端模式 tokenGranters.add(new ClientCredentialsTokenGranter(tokenServices, clientDetailsService, requestFactory)); if (authenticationManager != null) &#123; // 添加密码模式 tokenGranters.add(new ResourceOwnerPasswordTokenGranter(authenticationManager, tokenServices, clientDetailsService, requestFactory)); // 添加自定义授权模式（实际是密码模式的复制） tokenGranters.add(new SmsCodeTokenGranter(authenticationManager, tokenServices, clientDetailsService, requestFactory)); &#125; return tokenGranters; &#125; /** * TokenServices * * @return */ private AuthorizationServerTokenServices tokenServices() &#123; if (tokenServices != null) &#123; return tokenServices; &#125; this.tokenServices = createDefaultTokenServices(); return tokenServices; &#125; /** * 授权码API * * @return */ private AuthorizationCodeServices authorizationCodeServices() &#123; if (authorizationCodeServices == null) &#123; authorizationCodeServices = new InMemoryAuthorizationCodeServices(); &#125; return authorizationCodeServices; &#125; /** * OAuth2RequestFactory的默认实现，它初始化参数映射中的字段， * 验证授权类型(grant_type)和范围(scope)，并使用客户端的默认值填充范围(scope)（如果缺少这些值）。 * * @return */ private OAuth2RequestFactory requestFactory() &#123; return new DefaultOAuth2RequestFactory(clientDetailsService); &#125; /** * 默认 TokenService * * @return */ private DefaultTokenServices createDefaultTokenServices() &#123; DefaultTokenServices tokenServices = new DefaultTokenServices(); tokenServices.setTokenStore(tokenStore); tokenServices.setSupportRefreshToken(true); tokenServices.setReuseRefreshToken(reuseRefreshToken); tokenServices.setClientDetailsService(clientDetailsService); tokenServices.setTokenEnhancer(tokenEnhancer); addUserDetailsService(tokenServices, this.userDetailsService); return tokenServices; &#125; /** * 添加预身份验证 * * @param tokenServices * @param userDetailsService */ private void addUserDetailsService(DefaultTokenServices tokenServices, UserDetailsService userDetailsService) &#123; if (userDetailsService != null) &#123; PreAuthenticatedAuthenticationProvider provider = new PreAuthenticatedAuthenticationProvider(); provider.setPreAuthenticatedUserDetailsService(new UserDetailsByNameServiceWrapper&lt;PreAuthenticatedAuthenticationToken&gt;(userDetailsService)); tokenServices.setAuthenticationManager(new ProviderManager(Arrays.&lt;AuthenticationProvider&gt;asList(provider))); &#125; &#125;&#125; 授权认证服务端点配置12345678910111213141516171819202122232425262728293031323334package com.fengxuechao.examples.auth.config.inmemory;/** * @author fengxuechao * @version 0.1 * @date 2019/5/8 */@Slf4j@EnableAuthorizationServer@Configuration@Profile("inMemory")public class AuthorizationServerConfigInMemory extends AuthorizationServerConfigurerAdapter &#123; // 省略部分代码 @Autowired private TokenGranter tokenGranter; /** * 认证服务器节点配置 * * @param endpoints * @throws Exception */ @Override public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception &#123; endpoints .tokenGranter(tokenGranter) // 四种授权模式+刷新令牌的模式+自定义授权模式 .tokenStore(tokenStore) .approvalStore(approvalStore) .userDetailsService(userDetailsService) .authenticationManager(authenticationManager) .setClientDetailsService(clientDetailsService); &#125;&#125; 演示效果 request1234567891011121314151617181920212223POST http://localhost:8080/oauth/token?grant_type=sms_code&amp;scope=read&amp;username=user&amp;password=123456HTTP/1.1 200 X-Application-Context: application:inMemoryCache-Control: no-storePragma: no-cacheX-Content-Type-Options: nosniffX-XSS-Protection: 1; mode=blockX-Frame-Options: DENYContent-Type: application/json;charset=UTF-8Transfer-Encoding: chunkedDate: Tue, 18 Jun 2019 07:13:12 GMT&#123; "access_token": "19f2e44a-6c9a-45c4-be7e-0aada6a0a9e6", "token_type": "bearer", "refresh_token": "f59336a8-03c4-4c85-bc31-16c6d80f1381", "expires_in": 359, "scope": "read", "organization": "userWqTI"&#125;Response code: 200; Time: 335ms; Content length: 190 bytes]]></content>
      <categories>
        <category>oauth2</category>
      </categories>
      <tags>
        <tag>oauth2</tag>
        <tag>spring-boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring-Security-Oauth2添加自定义过滤器和oauth2认证后API权限控制]]></title>
    <url>%2Fpassages%2FSpring-Security-Oauth2%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8Coauth2%E8%AE%A4%E8%AF%81%E5%90%8EAPI%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[在搭建完 spring-security-oauth2 整个微服务框架后，来了一个需求： 每个微服务都需要对访问进行鉴权，每个微服务应用都需要明确当前访问用户和他的权限。 auth 系统的主要功能是授权认证和鉴权。 授权认证已经完成，那么如何对用户的访问进行鉴权呢？ 首先需要明确什么时候发生鉴权？ 鉴权发生在用户已经认证后携带了 access_token 信息但还没用访问到目标资源的时候。 知道了鉴权发生的时间，需要明白怎么鉴权？ 我的想法是添加一个用于鉴权的过滤器，Spring Security 默认的过滤器链(官网)： 别名 类名称 Namespace Element or Attribute CHANNEL_FILTER ChannelProcessingFilter http/intercept-url@requires-channel SECURITY_CONTEXT_FILTER SecurityContextPersistenceFilter http CONCURRENT_SESSION_FILTER ConcurrentSessionFilter session-management/concurrency-control HEADERS_FILTER HeaderWriterFilter http/headers CSRF_FILTER CsrfFilter http/csrf LOGOUT_FILTER LogoutFilter http/logout X509_FILTER X509AuthenticationFilter http/x509 PRE_AUTH_FILTER AbstractPreAuthenticatedProcessingFilter( Subclasses) N/A CAS_FILTER CasAuthenticationFilter N/A FORM_LOGIN_FILTER UsernamePasswordAuthenticationFilter http/form-login BASIC_AUTH_FILTER BasicAuthenticationFilter http/http-basic SERVLET_API_SUPPORT_FILTER SecurityContextHolderAwareRequestFilter http/@servlet-api-provision JAAS_API_SUPPORT_FILTER JaasApiIntegrationFilter http/@jaas-api-provision REMEMBER_ME_FILTER RememberMeAuthenticationFilter http/remember-me ANONYMOUS_FILTER AnonymousAuthenticationFilter http/anonymous SESSION_MANAGEMENT_FILTER SessionManagementFilter session-management EXCEPTION_TRANSLATION_FILTER ExceptionTranslationFilter http FILTER_SECURITY_INTERCEPTOR FilterSecurityInterceptor http SWITCH_USER_FILTER SwitchUserFilter N/A 过滤器顺序从上到下 FilterSecurityInterceptor 是 filterchain 中比较复杂，也是比较核心的过滤器，主要负责web应用安全授权的工作。 我想添加的过滤器是添加在 FilterSecurityInterceptor 之后。 Oauth2FilterSecurityInterceptor 是模仿 FilterSecurityInterceptor 实现，继承 AbstractSecurityInterceptor 和实现 Filter 接口。 整个过程需要依赖 AuthenticationManager、AccessDecisionManager 和 FilterInvocationSecurityMetadataSource。 AuthenticationManager是认证管理器，实现用户认证的入口； AccessDecisionManager是访问决策器，决定某个用户具有的角色，是否有足够的权限去访问某个资源； FilterInvocationSecurityMetadataSource是资源源数据定义，即定义某一资源可以被哪些角色访问。 自定义鉴权过滤器 Oauth2FilterSecurityInterceptor 的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990package com.fengxuechao.examples.auth.authorization;import lombok.extern.slf4j.Slf4j;import org.springframework.security.access.SecurityMetadataSource;import org.springframework.security.access.intercept.AbstractSecurityInterceptor;import org.springframework.security.access.intercept.InterceptorStatusToken;import org.springframework.security.authentication.AuthenticationManager;import org.springframework.security.web.FilterInvocation;import javax.servlet.*;import java.io.IOException;/** * 比较核心的过滤器: 主要负责web应用鉴权的工作。 * 需要依赖: * - AuthenticationManager:认证管理器，实现用户认证的入口; * - AccessDecisionManager:访问决策器，决定某个用户具有的角色，是否有足够的权限去访问某个资源; * - FilterInvocationSecurityMetadataSource:资源源数据定义，即定义某一资源可以被哪些角色访问. * * @author fengxuechao * @version 0.1 * @date 2019/6/17 */@Slf4jpublic class Oauth2FilterSecurityInterceptor extends AbstractSecurityInterceptor implements Filter &#123; private Oauth2FilterInvocationSecurityMetadataSource securityMetadataSource; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; if (log.isInfoEnabled()) &#123; log.info("Oauth2FilterSecurityInterceptor init"); &#125; &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; if (log.isInfoEnabled()) &#123; log.info("Oauth2FilterSecurityInterceptor doFilter"); &#125; FilterInvocation filterInvocation = new FilterInvocation(request, response, chain); invoke(filterInvocation); &#125; public void invoke(FilterInvocation filterInvocation) throws IOException, ServletException &#123; // filterInvocation里面有一个被拦截的url // 里面调用 Oauth2AccessDecisionManager 的 getAttributes(Object object) 这个方法获取 filterInvocation 对应的所有权限 // 再调用 Oauth2AccessDecisionManager 的 decide方法来校验用户的权限是否足够 InterceptorStatusToken interceptorStatusToken = super.beforeInvocation(filterInvocation); try &#123; // 执行下一个拦截器 filterInvocation.getChain().doFilter(filterInvocation.getRequest(), filterInvocation.getResponse()); &#125; finally &#123; super.afterInvocation(interceptorStatusToken, null); &#125; &#125; @Override public void destroy() &#123; &#125; @Override public Class&lt;?&gt; getSecureObjectClass() &#123; return FilterInvocation.class; &#125; /** * 资源源数据定义，设置为自定义的 SecureResourceFilterInvocationDefinitionSource * * @return */ @Override public SecurityMetadataSource obtainSecurityMetadataSource() &#123; return securityMetadataSource; &#125; public void setOauth2AccessDecisionManager(Oauth2AccessDecisionManager accessDecisionManager) &#123; super.setAccessDecisionManager(accessDecisionManager); &#125; @Override public void setAuthenticationManager(AuthenticationManager authenticationManager) &#123; super.setAuthenticationManager(authenticationManager); &#125; public void setSecurityMetadataSource(Oauth2FilterInvocationSecurityMetadataSource securityMetadataSource) &#123; this.securityMetadataSource = securityMetadataSource; &#125;&#125; 看下父类的 beforeInvocation 方法，其中省略了一些不重要的代码片段: 12345678910111213141516171819202122232425262728public abstract class AbstractSecurityInterceptor implements InitializingBean, ApplicationEventPublisherAware, MessageSourceAware &#123; protected InterceptorStatusToken beforeInvocation(Object object) &#123; // 代码省略 // 根据 SecurityMetadataSource 获取配置的权限属性 Collection&lt;ConfigAttribute&gt; attributes = this.obtainSecurityMetadataSource() .getAttributes(object); // 代码省略 // 判断是否需要对认证实体重新认证，默认为否 Authentication authenticated = authenticateIfRequired(); // Attempt authorization try &#123; // 决策管理器开始决定是否授权，如果授权失败，直接抛出 AccessDeniedException this.accessDecisionManager.decide(authenticated, object, attributes); &#125; catch (AccessDeniedException accessDeniedException) &#123; publishEvent(new AuthorizationFailureEvent(object, attributes, authenticated, accessDeniedException)); throw accessDeniedException; &#125; // 代码省略 &#125;&#125; 自定义资源源数据定义 Oauth2FilterInvocationSecurityMetadataSource1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.fengxuechao.examples.auth.authorization;import com.fengxuechao.examples.auth.service.UserRolePermissionService;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.InitializingBean;import org.springframework.security.access.ConfigAttribute;import org.springframework.security.access.SecurityConfig;import org.springframework.security.web.FilterInvocation;import org.springframework.security.web.access.intercept.FilterInvocationSecurityMetadataSource;import org.springframework.stereotype.Component;import java.util.Collection;/** * 资源源数据定义，即定义某一资源可以被哪些角色访问 * * @author fengxuechao * @version 0.1 * @date 2019/6/14 */@Slf4j@Componentpublic class Oauth2FilterInvocationSecurityMetadataSource implements FilterInvocationSecurityMetadataSource, InitializingBean &#123; private UserRolePermissionService service; public Oauth2FilterInvocationSecurityMetadataSource(UserRolePermissionService service) &#123; this.service = service; &#125; @Override public Collection&lt;ConfigAttribute&gt; getAttributes(Object object) throws IllegalArgumentException &#123; if ("/user/profile".equals(((FilterInvocation) object).getRequestUrl())) &#123; // [/user/profile] 不需要鉴权 return null; &#125; /*if (object instanceof FilterInvocation) &#123; FilterInvocation fi = (FilterInvocation) object; String requestUrl = fi.getRequestUrl(); // 返回请求所需的权限 List&lt;Role&gt; roleList = service.findRoleListByPermissionUrl(requestUrl); String[] roleArray = new String[roleList.size()]; roleArray = roleList.toArray(roleArray); return SecurityConfig.createList(roleArray); &#125; return Collections.EMPTY_LIST;*/ return SecurityConfig.createList("ROLE_ADMIN"); &#125; @Override public Collection&lt;ConfigAttribute&gt; getAllConfigAttributes() &#123; return null; &#125; @Override public boolean supports(Class&lt;?&gt; clazz) &#123; return true; &#125; @Override public void afterPropertiesSet() throws Exception &#123; &#125;&#125; 为了调试的方便，直接定死任何访问请求都需要管理员权限(/user/profile 除外)，调试通过后，再往里面添加业务逻辑代码。 自定义决策管理器 Oauth2AccessDecisionManager1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package com.fengxuechao.examples.auth.authorization;import lombok.extern.slf4j.Slf4j;import org.springframework.security.access.AccessDecisionManager;import org.springframework.security.access.AccessDeniedException;import org.springframework.security.access.ConfigAttribute;import org.springframework.security.authentication.InsufficientAuthenticationException;import org.springframework.security.core.Authentication;import org.springframework.security.core.GrantedAuthority;import org.springframework.security.web.FilterInvocation;import org.springframework.stereotype.Component;import java.util.Collection;import java.util.Iterator;/** * 访问决策器，决定某个用户具有的角色，是否有足够的权限去访问某个资源 * * @author fengxuechao * @version 0.1 * @date 2019/6/14 */@Slf4j@Componentpublic class Oauth2AccessDecisionManager implements AccessDecisionManager &#123; /** * @param authentication 用户凭证 * @param resource 资源 URL * @param configAttributes 资源 URL 所需要的权限 * @throws AccessDeniedException 资源拒绝访问 * @throws InsufficientAuthenticationException 用户凭证不符 */ @Override public void decide(Authentication authentication, Object resource, Collection&lt;ConfigAttribute&gt; configAttributes) throws AccessDeniedException, InsufficientAuthenticationException &#123; log.info("[决策管理器]:开始判断请求 &#123;&#125; 需要的权限", ((FilterInvocation) resource).getRequestUrl()); if (configAttributes == null || configAttributes.isEmpty()) &#123; log.info("[决策管理器]:请求 &#123;&#125; 无需权限", ((FilterInvocation) resource).getRequestUrl()); return; &#125; log.info("[决策管理器]:请求 &#123;&#125; 需要的权限 - &#123;&#125;", ((FilterInvocation) resource).getRequestUrl(), configAttributes); // 判断用户所拥有的权限，是否符合对应的Url权限，用户权限是实现 UserDetailsService#loadUserByUsername 返回用户所对应的权限 Iterator&lt;ConfigAttribute&gt; ite = configAttributes.iterator(); log.info("[决策管理器]:用户 &#123;&#125; 拥有的权限 - &#123;&#125;", authentication.getName(), authentication.getAuthorities()); while (ite.hasNext()) &#123; ConfigAttribute neededAuthority = ite.next(); String neededAuthorityStr = neededAuthority.getAttribute(); for (GrantedAuthority existingAuthority : authentication.getAuthorities()) &#123; if (neededAuthorityStr.equals(existingAuthority.getAuthority())) &#123; return; &#125; &#125; &#125; log.info("[决策管理器]:用户 &#123;&#125; 没有访问资源 &#123;&#125; 的权限!", authentication.getName(), ((FilterInvocation) resource).getRequestUrl()); throw new AccessDeniedException("权限不足!"); &#125; @Override public boolean supports(ConfigAttribute attribute) &#123; return true; &#125; /** * 是否支持 FilterInvocationSecurityMetadataSource 需要将这里的false改为true * * @param clazz * @return */ @Override public boolean supports(Class&lt;?&gt; clazz) &#123; return true; &#125;&#125; 配置自定义鉴权过滤器 Oauth2FilterSecurityInterceptor 在 Spring Security 过滤器链中的位置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.fengxuechao.examples.auth.config;import com.fengxuechao.examples.auth.authorization.Oauth2AccessDecisionManager;import com.fengxuechao.examples.auth.authorization.Oauth2FilterInvocationSecurityMetadataSource;import com.fengxuechao.examples.auth.authorization.Oauth2FilterSecurityInterceptor;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Configuration;import org.springframework.security.authentication.AuthenticationManager;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.oauth2.config.annotation.web.configuration.EnableResourceServer;import org.springframework.security.oauth2.config.annotation.web.configuration.ResourceServerConfigurerAdapter;import org.springframework.security.web.access.intercept.FilterSecurityInterceptor;/** * @author fengxuechao * @version 0.1 * @date 2019/5/8 */@Slf4j@EnableResourceServer@Configurationpublic class ResourceServerConfig extends ResourceServerConfigurerAdapter &#123; @Autowired AuthenticationManager manager; @Autowired Oauth2AccessDecisionManager accessDecisionManager; @Autowired Oauth2FilterInvocationSecurityMetadataSource securityMetadataSource; @Override public void configure(HttpSecurity http) throws Exception &#123; http.authorizeRequests().anyRequest().authenticated(); http.addFilterAfter(createApiAuthenticationFilter(), FilterSecurityInterceptor.class); &#125; /** * API权限控制 * 过滤器优先度在 FilterSecurityInterceptor 之后 * spring-security 的默认过滤器列表见 https://docs.spring.io/spring-security/site/docs/5.0.0.M1/reference/htmlsingle/#ns-custom-filters * * @return */ private Oauth2FilterSecurityInterceptor createApiAuthenticationFilter() &#123; Oauth2FilterSecurityInterceptor interceptor = new Oauth2FilterSecurityInterceptor(); interceptor.setAuthenticationManager(manager); interceptor.setAccessDecisionManager(accessDecisionManager); interceptor.setSecurityMetadataSource(securityMetadataSource); return interceptor; &#125;&#125; 配置用户权限12345678910111213141516171819202122package com.fengxuechao.examples.auth.userdetails;import org.springframework.security.core.authority.AuthorityUtils;import org.springframework.security.core.userdetails.User;import org.springframework.security.core.userdetails.UserDetails;import org.springframework.security.core.userdetails.UserDetailsService;import org.springframework.security.core.userdetails.UsernameNotFoundException;import org.springframework.stereotype.Component;/** * @author fengxuechao * @version 0.1 * @date 2019/5/15 */@Componentpublic class UserDetailsServiceImpl implements UserDetailsService &#123; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; return new User(username, "123456", AuthorityUtils.commaSeparatedStringToAuthorityList("ROLE_USER")); &#125;&#125; 演示结果用户拥有资源所需权限请求： request1234567891011121314151617GET http://localhost:8080/order/1HTTP/1.1 200 X-Application-Context: application:inMemoryX-Content-Type-Options: nosniffX-XSS-Protection: 1; mode=blockCache-Control: no-cache, no-store, max-age=0, must-revalidatePragma: no-cacheExpires: 0X-Frame-Options: DENYContent-Type: text/plain;charset=UTF-8Content-Length: 12Date: Tue, 18 Jun 2019 01:50:48 GMTorder id : 1Response code: 200; Time: 57ms; Content length: 12 bytes 日志： 123456782019-06-18 09:50:48.955 INFO 5288 --- [nio-8080-exec-3] .f.e.a.a.Oauth2FilterSecurityInterceptor : Oauth2FilterSecurityInterceptor doFilter2019-06-18 09:50:48.955 DEBUG 5288 --- [nio-8080-exec-3] .f.e.a.a.Oauth2FilterSecurityInterceptor : Secure object: FilterInvocation: URL: /order/1; Attributes: [ROLE_USER]2019-06-18 09:50:48.956 DEBUG 5288 --- [nio-8080-exec-3] .f.e.a.a.Oauth2FilterSecurityInterceptor : Previously Authenticated: org.springframework.security.oauth2.provider.OAuth2Authentication@f5aeefea: Principal: org.springframework.security.core.userdetails.User@36ebcb: Username: user; Password: [PROTECTED]; Enabled: true; AccountNonExpired: true; credentialsNonExpired: true; AccountNonLocked: true; Granted Authorities: ROLE_USER; Credentials: [PROTECTED]; Authenticated: true; Details: remoteAddress=127.0.0.1, tokenType=bearertokenValue=&lt;TOKEN&gt;; Granted Authorities: ROLE_USER2019-06-18 09:50:48.956 INFO 5288 --- [nio-8080-exec-3] c.f.e.a.a.Oauth2AccessDecisionManager : [决策管理器]:开始判断请求 /order/1 需要的权限2019-06-18 09:50:48.956 INFO 5288 --- [nio-8080-exec-3] c.f.e.a.a.Oauth2AccessDecisionManager : [决策管理器]:请求 /order/1 需要的权限 - [ROLE_USER]2019-06-18 09:50:48.956 INFO 5288 --- [nio-8080-exec-3] c.f.e.a.a.Oauth2AccessDecisionManager : [决策管理器]:用户 user 拥有的权限 - [ROLE_USER]2019-06-18 09:50:48.956 DEBUG 5288 --- [nio-8080-exec-3] .f.e.a.a.Oauth2FilterSecurityInterceptor : Authorization successful2019-06-18 09:50:48.957 DEBUG 5288 --- [nio-8080-exec-3] .f.e.a.a.Oauth2FilterSecurityInterceptor : RunAsManager did not change Authentication object 用户没有资源所需权限请求： request123456789101112131415161718GET http://localhost:8080/order/1HTTP/1.1 403 Cache-Control: no-storePragma: no-cacheX-Content-Type-Options: nosniffX-XSS-Protection: 1; mode=blockX-Frame-Options: DENYContent-Type: application/json;charset=UTF-8Transfer-Encoding: chunkedDate: Tue, 18 Jun 2019 01:44:49 GMT&#123; "error": "access_denied", "error_description": "权限不足!"&#125;Response code: 403; Time: 35ms; Content length: 53 bytes 日志： 1234567892019-06-18 09:44:44.684 INFO 10624 --- [nio-8080-exec-2] .f.e.a.a.Oauth2FilterSecurityInterceptor : Oauth2FilterSecurityInterceptor doFilter2019-06-18 09:44:44.685 DEBUG 10624 --- [nio-8080-exec-2] .f.e.a.a.Oauth2FilterSecurityInterceptor : Public object - authentication not attempted2019-06-18 09:44:49.448 INFO 10624 --- [nio-8080-exec-6] .f.e.a.a.Oauth2FilterSecurityInterceptor : Oauth2FilterSecurityInterceptor doFilter2019-06-18 09:44:49.449 DEBUG 10624 --- [nio-8080-exec-6] .f.e.a.a.Oauth2FilterSecurityInterceptor : Secure object: FilterInvocation: URL: /order/1; Attributes: [ROLE_ADMIN]2019-06-18 09:44:49.449 DEBUG 10624 --- [nio-8080-exec-6] .f.e.a.a.Oauth2FilterSecurityInterceptor : Previously Authenticated: org.springframework.security.oauth2.provider.OAuth2Authentication@22d262ad: Principal: org.springframework.security.core.userdetails.User@36ebcb: Username: user; Password: [PROTECTED]; Enabled: true; AccountNonExpired: true; credentialsNonExpired: true; AccountNonLocked: true; Granted Authorities: ROLE_USER; Credentials: [PROTECTED]; Authenticated: true; Details: remoteAddress=127.0.0.1, tokenType=bearertokenValue=&lt;TOKEN&gt;; Granted Authorities: ROLE_USER2019-06-18 09:44:49.450 INFO 10624 --- [nio-8080-exec-6] c.f.e.a.a.Oauth2AccessDecisionManager : [决策管理器]:开始判断请求 /order/1 需要的权限2019-06-18 09:44:49.450 INFO 10624 --- [nio-8080-exec-6] c.f.e.a.a.Oauth2AccessDecisionManager : [决策管理器]:请求 /order/1 需要的权限 - [ROLE_ADMIN]2019-06-18 09:44:49.450 INFO 10624 --- [nio-8080-exec-6] c.f.e.a.a.Oauth2AccessDecisionManager : [决策管理器]:用户 user 拥有的权限 - [ROLE_USER]2019-06-18 09:44:49.451 INFO 10624 --- [nio-8080-exec-6] c.f.e.a.a.Oauth2AccessDecisionManager : [决策管理器]:用户 user 没有访问资源 /order/1 的权限! 返回结果和日志符合期望结果 参考资源http://www.spring4all.com/article/422]]></content>
      <categories>
        <category>oauth2</category>
      </categories>
      <tags>
        <tag>oauth2</tag>
        <tag>spring-boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring-Security-Oauth2令牌增加额外信息]]></title>
    <url>%2Fpassages%2FSpring-Security-Oauth2%E4%BB%A4%E7%89%8C%E5%A2%9E%E5%8A%A0%E9%A2%9D%E5%A4%96%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[在实现了 Oauth2 后，我想要在令牌增加中额外信息，那么该怎么做？ 下面是我的做法，首先实现 org.springframework.security.oauth2.provider.token.TokenEnhancer 接口： 12345678910111213141516171819202122232425262728package com.fengxuechao.examples.auth.config;import org.springframework.security.oauth2.common.DefaultOAuth2AccessToken;import org.springframework.security.oauth2.common.OAuth2AccessToken;import org.springframework.security.oauth2.provider.OAuth2Authentication;import org.springframework.security.oauth2.provider.token.TokenEnhancer;import java.util.HashMap;import java.util.Map;import static org.apache.commons.lang3.RandomStringUtils.randomAlphabetic;/** * token 额外信息 * * @author fengxuechao * @version 0.1 * @date 2019/5/16 */public class CustomTokenEnhancer implements TokenEnhancer &#123; @Override public OAuth2AccessToken enhance(OAuth2AccessToken accessToken, OAuth2Authentication authentication) &#123; Map&lt;String, Object&gt; additionalInfo = new HashMap&lt;String, Object&gt;(); additionalInfo.put("organization", authentication.getName() + randomAlphabetic(4)); ((DefaultOAuth2AccessToken) accessToken).setAdditionalInformation(additionalInfo); return accessToken; &#125;&#125; 然后在 AuthorizationServerConfigurerAdapter 认证服务代码中配置： 1234567891011121314151617181920212223242526272829303132333435363738394041public class AuthorizationServerConfigInJwt extends AuthorizationServerConfigurerAdapter &#123; @Override public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception &#123; // token 携带额外信息 TokenEnhancerChain tokenEnhancerChain = new TokenEnhancerChain(); tokenEnhancerChain.setTokenEnhancers(Arrays.asList(tokenEnhancer(), jwtTokenEnhancer())); endpoints .tokenStore(tokenStore()) .tokenEnhancer(tokenEnhancerChain) .userDetailsService(userDetailsService) .authenticationManager(authenticationManager) .setClientDetailsService(clientDetailsService); &#125; /** * Token 额外信息 * * @return */ @Bean public TokenEnhancer tokenEnhancer() &#123; return new CustomTokenEnhancer(); &#125; /** * jwt token：使用了非对称密钥对来签署令牌: * 1.生成 JKS Java KeyStore 文件：keytool -genkeypair -alias jwt_rsa -keyalg RSA -keypass 123456 -keystore jwt_rsa.jks -storepass 123456 * 2.导出公钥：keytool -list -rfc --keystore jwt_rsa.jks | openssl x509 -inform pem -pubkey * 3.将 PUBLIC KEY 保存至 public.txt * * @return */ @Bean public JwtAccessTokenConverter jwtTokenEnhancer() &#123; JwtAccessTokenConverter converter = new JwtAccessTokenConverter(); converter.setKeyPair(new KeyStoreKeyFactory(resource, keyStorePass.toCharArray()).getKeyPair(keyPairAlias)); // 使用对称密钥来签署令牌 // converter.setSigningKey("fengxuechao.littlefxc"); return converter; &#125;&#125; 或者 tokenServices.setTokenEnhancer(tokenEnhancer); 最后演示一下最终效果： 12345678&#123; "access_token": "4aae3856-bc33-4e4d-86bc-eb475fc45569", "token_type": "bearer", "refresh_token": "fe2ed35d-5c53-4610-abb7-c1053cba6803", "expires_in": 119, "scope": "read", "organization": "userAKqz"&#125; jwt 123456789&#123; "access_token": "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX25hbWUiOiJ1c2VyIiwic2NvcGUiOlsicmVhZCJdLCJvcmdhbml6YXRpb24iOiJ1c2VyZWx2ayIsImV4cCI6MTU2MDQ4NDI0OCwiYXV0aG9yaXRpZXMiOlsiUk9MRV9VU0VSIl0sImp0aSI6IjliNTU2ZTBiLTZlZmQtNDkwZC05OGMwLWIzYzYwNjM2ZDczMCIsImNsaWVudF9pZCI6ImNsaWVudCJ9.oaqlviXcQPCLAZP8cV7v-WA75AoiodiG6d2WR9yqJhOFCg7LDsnCjk63J59sq434CZHRIOkCgMi2hVJHOc4MTIFce61Kk046G3-yK313CtMy5LWeVXdKbAHH0gcuoDO3OCJ7u7GzngPtA6bVfxjJFNJ6MmFxEnFPjB5dos9Bb8zYduE2ELMH2aTCS-67R_aQ0BCZaYo5NMH1_jqz9d1hI_kpBx3auR_d2Vh1eJiC_f9Z-rTmRvXdwQefhwgXZ1UCWjV0NuoCqFO3KicEhjGOkqXZ5eh0vGR5zKwKJfCys1lNgXjXVVntHYkXt96ymQ9477pCAWCONZsbkM7244500Q", "token_type": "bearer", "refresh_token": "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX25hbWUiOiJ1c2VyIiwic2NvcGUiOlsicmVhZCJdLCJvcmdhbml6YXRpb24iOiJ1c2VyZWx2ayIsImF0aSI6IjliNTU2ZTBiLTZlZmQtNDkwZC05OGMwLWIzYzYwNjM2ZDczMCIsImV4cCI6MTU2MDQ4NzcyOCwiYXV0aG9yaXRpZXMiOlsiUk9MRV9VU0VSIl0sImp0aSI6IjJhNTUxOWJjLWUzYTAtNGJjOC1hNTRkLTlmMDNiMjYwNjZkNCIsImNsaWVudF9pZCI6ImNsaWVudCJ9.BgY6N0kzxVApFD-C7UVMDmczSoMY9tglnKzTkybfneoeAAs8ljftIwA5sPWua28Xhl-MNAQ9HL6Q6ou-EbgFlcHC2uPPbJ5silnPLPdTnvVko9l-8w-3WLPk96YbODdQemqFZHSrR1lPmXHB5sR7QjncxGxvuSYZEtPXxZz39lJbyQLSflXADqlk4ZV3BxS-M7d8FcTJEM1uTgwUBSns2N6AZnTkd2FnGskadaV2qhky5TznJjQqRETVS8xCiZCFYwCq5sAMHOj-_BrwlmCeoPfcy38ofbql-qVWfQJiAeU7yWLlAu_hd-zRIIbv-dqRmSF9T9rCxVPv84ptddO1Hw", "expires_in": 119, "scope": "read", "organization": "userelvk", "jti": "9b556e0b-6efd-490d-98c0-b3c60636d730"&#125; 最终返回的 Token 信息中多了一个属性 organization，结果符合期望结果。]]></content>
      <categories>
        <category>oauth2</category>
      </categories>
      <tags>
        <tag>oauth2</tag>
        <tag>spring-boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Springboot使用@JsonView过滤对象属性]]></title>
    <url>%2Fpassages%2FSpringboot%E4%BD%BF%E7%94%A8-JsonView%E8%BF%87%E6%BB%A4%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[简介@JsonView是Jackson的一个注解，可以用来过滤序列化对象的字段属性，是你可以选择序列化对象哪些属性，哪些过滤掉。 使用步骤 使用接口来声明多个视图 在值对象的get方法上指定视图 在Controller方法上指定视图 步骤 1：使用接口来声明多个视图使用同一个对象，面对不同的场景，去声明多个视图。 例如： 有一个 User 对象，里面有id、username、password、birthday等属性 场景1：获得对象的用户名、密码 场景2：获得对象的全部属性 为了测试，创建一个User实体对象，加入两个接口 UserSimpleView，UserDetailView 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class User &#123; public interface UserSimpleView &#123;&#125;; public interface UserDetailView extends UserSimpleView &#123;&#125;; private String id; private String username; @NotBlank(message = "密码不能为空") private String password; @Past(message = "生日必须是过去的时间") private Date birthday; @JsonView(UserSimpleView.class) public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @JsonView(UserSimpleView.class) public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; @JsonView(UserSimpleView.class) public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125;&#125; 步骤 2：在值对象的get方法上指定视图在实体类 User 里的 get 方法上面加上 @JsonView 注解，并将它绑定到一个指定接口 分两类 @JsonView(UserSimpleView.class)：绑定 id、username、birthday属性 @JsonView(UserDetailView.class)：绑定 password 属性，继承 UserSimpleView 接口（相当于绑了 UserSimpleView 绑定的属性） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class User &#123; public interface UserSimpleView &#123;&#125;; public interface UserDetailView extends UserSimpleView &#123;&#125;; private String id; private String username; @NotBlank(message = "密码不能为空") private String password; @Past(message = "生日必须是过去的时间") private Date birthday; @JsonView(UserSimpleView.class) public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @JsonView(UserSimpleView.class) public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; @JsonView(UserSimpleView.class) public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125;&#125; 步骤 3：在Controller方法上指定视图在controller中俩个方法分别加上@JsonView注解，在分配上不同场景的接口 user1：输出视图1 user2：输出视图2 1234567891011121314151617181920212223242526272829303132@RestController@RequestMapping("user")public class UserController &#123; @GetMapping @JsonView(User.UserSimpleView.class) public List&lt;User&gt; query(UserQueryCondition condition) &#123; System.out.println(ReflectionToStringBuilder.toString(condition, ToStringStyle.MULTI_LINE_STYLE)); List&lt;User&gt; users = new ArrayList&lt;&gt;(); users.add(new User()); users.add(new User()); users.add(new User()); return users; &#125; /** * &#123;id:\d+&#125;:正则表示只接受数字 * * @param id * @return */ @GetMapping("&#123;id:\\d+&#125;") @JsonView(User.UserDetailView.class) public User getInfo(@PathVariable String id) &#123; User user = new User(); user.setId(id); user.setUsername("tom"); user.setPassword("tom"); return user; &#125;&#125; 测试request123456789101112131415161718192021222324GET http://localhost:8080/userHTTP/1.1 200 Content-Type: application/json;charset=UTF-8Transfer-Encoding: chunkedDate: Wed, 26 Jun 2019 00:41:03 GMT[ &#123; "id": null, "username": null, "birthday": null &#125;, &#123; "id": null, "username": null, "birthday": null &#125;, &#123; "id": null, "username": null, "birthday": null &#125;] 返回结果中没有密码属性 request12345678910111213GET http://localhost:8080/user/1HTTP/1.1 200 Content-Type: application/json;charset=UTF-8Transfer-Encoding: chunkedDate: Wed, 26 Jun 2019 00:41:56 GMT&#123; "id": "1", "username": "tom", "password": "tom", "birthday": null&#125; 返回结果中包含了密码字段。 总结说明 @OneView 只会序列化 username、password 属性，TwoView 会序列化username、password、realName、sex属性。 因此想设置不同接口的不同场景,可以用 @JsonView 达到某些目的。]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>jackson</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL数据类型]]></title>
    <url>%2Fpassages%2FMySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[MySQL数据类型 数字类型 整数: tinyint、smallint、mediumint、int、bigint 浮点数: float、double、real、decimal 日期和时间: date、time、datetime、timestamp、year 字符串类型 字符串: char、varchar 文本: tinytext、text、mediumtext、longtext 二进制(可用来存储图片、音乐等): tinyblob、blob、mediumblob、longblob 数字类型整型 type Storage(Bytes) Signed Range Unsigned Range TINYINT 1 -128-127 0-255 SMALLINT 2 -32768-32767 0-65535 MEDIUMINT 3 -8388608-8388607 0-16777215 INT 4 -2147483648-2147483647 0-4294967295 BIGINT 8 -9223372036854775808-9223372036854775807 0-18446744073709551615 浮点型 属性 存储空间 精度 精确性 说明 FLOAT(M, D) 4 bytes 单精度 非精确 单精度浮点型，m总个数，d小数位 DOUBLE(M, D) 8 bytes 双精度 比Float精度高 双精度浮点型，m总个数，d小数位 FLOAT容易造成精度丢失 定点数DECIMAL 高精度的数据类型，常用来存储交易相关的数据 DECIMAL(M,N).M代表总精度，N代表小数点右侧的位数（标度） 1 &lt; M &lt; 254, 0 &lt; N &lt; 60; 存储空间变长 时间类型 类型 字节 例 精确性 DATE 三字节 2015-05-01 精确到年月日 TIME 三字节 11:12:00 精确到时分秒 DATETIME 八字节 2015-05-01 11::12:00 精确到年月日时分秒 TIMESTAMP 2015-05-01 11::12:00 精确到年月日时分秒 MySQL在5.6.4版本之后，TIMESTAMP和DATETIME支持到微秒。 TIMESTAMP会根据系统时区进行转换，DATETIME则不会 存储范围的区别 TIMESTAMP存储范围：1970-01-01 00::00:01 to 2038-01-19 03:14:07 DATETIME的存储范围：1000-01-01 00:00:00 to 9999-12-31 23:59:59 一般使用TIMESTAMP国际化 如存时间戳使用数字类型BIGINT 字符串类型 类型 单位 最大 特性 CHAR 字符 最大为255字符 存储定长，容易造成空间的浪费 VARCHAR 字符 可以超过255个字符 存储变长，节省存储空间 TEXT 字节 总大小为65535字节，约为64KB - TEXT在MySQL内部大多存储格式为溢出页，效率不如CHAR Mysql默认为utf-8，那么在英文模式下1个字符=1个字节，在中文模式下1个字符=3个字节。 其它SERIAL 是 BIGINT UNSIGNED NOT NULL AUTO_INCREMENT UNIQUE 的别名。]]></content>
      <categories>
        <category>RDBMS</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人知识体系整理]]></title>
    <url>%2Fpassages%2F%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[个人知识体系整理Java多线程 线程间通信 volatile synchronized wait/notify机制 RDBMSSQL反模式MySQL MySQL数据类型 日志系列logbackappender ConsoleAppender RollingFileAppender KafkaAppender log4j2sl4j2中间件系列消息中间件Kafka]]></content>
      <categories>
        <category>知识体系</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[]]></title>
    <url>%2Fpassages%2FSQL%E5%8F%8D%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[《SQL反模式》 阅读笔记反模式分类 逻辑数据库设计反模式 物理书库设计反模式 查询反模式 应用程序开发反模式 反模式分解 目的 反模式 如何识别反模式 合理使用反模式 解决方案 ER 图示例 范例数据库SERIAL 是 MySQL 中 BIGINT UNSIGNED NOT NULL AUTO_INCREMENT UNIQUE 的别名 1234567891011121314151617181920212223242526272829303132333435363738394041CREATE TABLE Accounts ( account_id SERIAL PRIMARY KEY, account_name VARCHAR(20), first_name VARCHAR(20), last_name VARCHAR(20), email VARCHAR(100), password_hash CHAR(64), portrait_image BLOB, hourly_rate NUMERIC(9,2));CREATE BugStatus ( status VARCHAR(20) PRIMARY KEY);CREATE TABLE Bugs ( bug_id SERIAL PRIMARY KEY, date_reported DATE NOT NULL, summary VARCHAR(80), description VARCHAR(1000), resolition VARCHAR(1000), reported_by BIGINT UNSINGNED NOT NULL, assigned_to BIGINT UNSINGNED, verified_by BIGINT UNSINGNED, status VARCHAR(20) NOT NULL DEFAULT 'NEW', priority VARCHAR(20), hours NUMERIC(9,2), FOREIGN KEY (reported_by) REFERENCES Accounts(account_id), FOREIGN KEY (assigned_to) REFERENCES Accounts(account_id), FOREIGN KEY (verified_by) REFERENCES Accounts(account_id), FOREIGN KEY (status) REFERENCES BugStatus(status));CREATE TABLE Comments ( comment_id SERIAL PRIMARY KEY, bug_id BIGINT UNSINGNED NOT NULL, author BIGINT UNSINGNED NOT NULL, comment_date DATETIME NOT NULL, comment TEXT NOT NULL, FOREIGN KEY TEXT NOT NULL,);]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>阅读笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux常用命令]]></title>
    <url>%2Fpassages%2Flinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[文件系统常用命令ls / : 查看根目录下的子节点（文件夹和文件）信息 ls -al : -a 显示隐藏文件 -l 以更详细的列表形式显示 mkdir aaa : 创建相对路径文件夹的写法 mkdir -p aaa/bbb/ccc rmdir : 可以删除空目录 rm -r aaa : 可以把 aaa 整个文件夹及其中的所有子节点全都删除 rm -fr aaa : 强制删除 aaa touch somefile.txt : 创建一个空文件 &gt; : 重定向 echo &quot;利用 &gt; 重定向的功能，将一定指令的输出结果写入到一个文件中，会覆盖原文件内容&quot; &gt; somefile.txt &gt;&gt; : 追加 echo &quot;利用 &gt;&gt; 可以把字符串追加到一个文件中，不会覆盖原文件内容&quot; &gt;&gt; somefile.txt vi 编辑器的一些快捷键一般模式a : 在光标后一位开始插入 A : 在该行的最后插入 I : 在该行的最前面插入 gg : 直接跳到文件的首行 G : 编辑模式]]></content>
  </entry>
  <entry>
    <title><![CDATA[nginx]]></title>
    <url>%2Fpassages%2Fnginx%2F</url>
    <content type="text"><![CDATA[nginx 介绍]]></content>
  </entry>
  <entry>
    <title><![CDATA[zookeeper]]></title>
    <url>%2Fpassages%2Fzookeeper%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[搭建ELK日志分析平台]]></title>
    <url>%2Fpassages%2F%E6%90%AD%E5%BB%BAELK%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%2F</url>
    <content type="text"><![CDATA[搭建ELK日志分析平台Logstash下载直接下载官方发布的二进制包的，可以访问 https://www.elastic.co/downloads/logstash 页面找对应操作系统和版本，点击下载即可。不过更推荐使用软件仓库完成安装。 安装 确保系统环境中安装了 JDK8 及以上 在 Linux 中配置 JAVA 环境： 123export JAVA_HOME=/usr/local/java/jdk1.8.0_112export PATH=$JAVA_HOME/bin:$PATHexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar 安装 Logstash 手动安装 Logstash 12 APT 工具安装 12345678# 下载并安装公共签名密钥：wget -qO - https://artifacts.elastic.co/GPG-KEY-elasticsearch | sudo apt-key add -# 可能需要安装 apt-transport-httpssudo apt-get install apt-transport-https# 添加库定义文件到 /etc/apt/sources.list.d/elastic-7.x.listecho "deb https://artifacts.elastic.co/packages/7.x/apt stable main" | sudo tee -a /etc/apt/sources.list.d/elastic-7.x.list# 更新并安装sudo apt-get update &amp;&amp; sudo apt-get install logstash YUM 工具安装 下载并安装公共签名密钥： 1rpm --import https://artifacts.elastic.co/GPG-KEY-elasticsearch 在 /etc/yum.repos.d/ 文件夹中将下面的内容添加到 logstash.repo 文件中 12345678[logstash-7.x]name=Elastic repository for 7.x packagesbaseurl=https://artifacts.elastic.co/packages/7.x/yumgpgcheck=1gpgkey=https://artifacts.elastic.co/GPG-KEY-elasticsearchenabled=1autorefresh=1type=rpm-md 安装 Logstash 1sudo yum install logstash Docker 拉取镜像 1docker pull docker.elastic.co/logstash/logstash:7.1.1 安装 elasticsearch 集群]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>ELK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Consul使用记录]]></title>
    <url>%2Fpassages%2FConsul%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[1. consul 集群模式1consul agent -server -data-dir=./data/ -node=s1 -bind=192.168.217.86 -ui -rejoin -client=0.0.0.0 -bootstrap-expect=1 -ui 参数介绍： -server 表示是以服务端身份启动，去掉这个参数表示 client 模式 -bind 表示绑定到哪个ip（有些服务器会绑定多块网卡，可以通过bind参数强制指定绑定的ip），一般是本机IP -client 指定客户端访问的ip(consul有丰富的api接口，这里的客户端指浏览器或调用方)，0.0.0.0表示不限客户端ip -bootstrap-expect=3 表示server集群最低节点数为3，低于这个值将工作不正常(注：类似zookeeper一样，通常集群数为奇数，方便选举，consul采用的是raft算法) -data-dir 表示指定数据的存放(持久化)目录（该目录必须存在） -node 表示节点在web ui中显示的名称 启动成功后，终端窗口不要关闭，可以在浏览器里，访问下，类似 http://192.168.212.73:8500/， 正常的话，可以正常打开web界面。 为了防止终端关闭后，consul退出，可以在刚才命令上，加点东西，类似：nohup xxx &gt; /dev/null 2&gt;&amp;1 &amp; 1.1. 命令行建立 consul 集群服务端1： 1consul agent -server -bootstrap-expect=2 -data-dir=./data/ -bind=192.168.217.134 -client=0.0.0.0 -node=s1 -ui 服务端2： 1consul agent -server -bootstrap-expect=2 -data-dir=./data/ -bind=192.168.217.72 -client=0.0.0.0 -join 192.168.217.134 -node=s2 -ui 服务端3： 1consul agent -server -bootstrap-expect=2 -data-dir=./data/ -bind=192.168.217.86 -client=0.0.0.0 -join 192.168.217.134 -node=s3 -ui 客户端1： 1consul agent -data-dir=./data/ -bind=192.168.217.87 -client=0.0.0.0 -join 192.168.217.134 -node=c1 -ui 1.2. 配置文件方式建立 consul 集群 例： 123456789101112131415161718192021222324252627282930&#123; /* 表示server集群最低节点数 */ "bootstrap_expect": 2, /* 表示该节点绑定的地址, 默认0.0.0.0 */ "bind_addr": "192.168.217.86", /* 访问该节点的地址, 默认127.0.0.1*/ "client_addr": "0.0.0.0", /* 访问该节点的数据中心*/ "datacenter": "data-center-1", /* 必须, 数据保存的地址*/ "data_dir": "/home/awifi/consul-server/data", "addresses": &#123; /* 表示该节点绑定的dns地址, 以空格分隔的要绑定的地址列表*/ "dns": "192.168.217.86", /* 表示该节点绑定的http地址, 以空格分隔的要绑定的地址列表*/ "http": "192.168.217.86 127.0.0.1" &#125;, /* 节点名，必须*/ "node_name": "server:192.168.212.73:8500", "rejoin_after_leave": true, /* 表示该节点类型是server*/ "server": true, /* 允许在第一次尝试失败时重试连接 */"retry_join": [ "192.168.217.72", "192.168.217.134" ], /* 表示开启web界面*/ "ui": true&#125; 然后在另一台机器上执行./consul join 192.168.217.86或者可以加入配置 1234&#123; "start_join":[], "retry_join":[]&#125; start_join：等同于 命令行参数-join : 表示启动时加入的集群地址retry_join：等同于 命令行参数-retry-join : 允许在第一次尝试失败时重试连接，该列表可以包含IPv4，IPv6或DNS地址。 1.2.1. 为什么 http 地址要绑定 127.0.0.1 ？如果不绑定127.0.0.1，在该服务器上就会无法使用除 ./consul agent 以外的命令， 例如:组建集群模式的核心命令：consul join 192.168.217.86优雅的注销节点的命令： consul leave 2. 查看集群状态1consul operator raft list-peers 运行结果： 运行结果红色方框部分可以看出集群模式中谁是 leader]]></content>
      <categories>
        <category>注册中心</category>
      </categories>
      <tags>
        <tag>consul</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合学习之LinkedList]]></title>
    <url>%2Fpassages%2FJava%E9%9B%86%E5%90%88%E5%AD%A6%E4%B9%A0%E4%B9%8BLinkedList%2F</url>
    <content type="text"><![CDATA[概述双链表实现了List和Deque接口。 实现所有可选列表操作，并允许所有元素（包括null ）。 所有的操作都能像双向列表一样预期。 索引到列表中的操作将从开始或结束遍历列表，以更接近指定的索引为准。 请注意，此实现不同步。 如果多个线程同时访问链接列表，并且至少有一个线程在结构上修改列表，则必须在外部进行同步。 （结构修改是添加或删除一个或多个元素的任何操作;仅设置元素的值不是结构修改。）这通常通过在自然封装列表的对象上进行同步来实现。 如果没有这样的对象存在，列表应该使用 Collections.synchronizedList 方法“包装”。 这最好在创建时完成，以防止意外的不同步访问列表： List list = Collections.synchronizedList(new LinkedList(...)); 这个类的 iterator 和 listIterator 方法返回的迭代器是故障快速的 ：如果列表在迭代器创建之后的任何时间被结构化地修改，除了通过迭代器自己的remove或add方法之外，迭代器将会抛出一个ConcurrentModificationException 。 因此，面对并发修改，迭代器将快速而干净地失败，而不是在未来未确定的时间冒着任意的非确定性行为。 请注意，迭代器的故障快速行为无法保证，因为一般来说，在不同步并发修改的情况下，无法做出任何硬性保证。失败快速迭代器尽力投入ConcurrentModificationException 。 因此，编写依赖于此异常的程序的正确性将是错误的：迭代器的故障快速行为应仅用于检测错误。 （以上来自 Java8 api） 分析首先看一下 LinkedList 的继承关系： 定义123public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable&#123;&#125; LinkedList 是一个继承于 AbstractSequentialList 的双向链表。它也可以被当作堆栈、队列或双端队列进行操作。最大限度地减少了实现受“连续访问”数据存储（如链接列表）支持的此接口所需的工作,从而以减少实现 List 接口的复杂度。 LinkedList 实现 List 接口，能对它进行序列（有序集合）操作。 LinkedList 实现 Deque 接口，即能将LinkedList当作双端队列使用。 LinkedList 实现了 Cloneable 接口，即覆盖了函数 clone()，能克隆。 LinkedList 实现 java.io.Serializable 接口，这意味着 LinkedList 支持序列化，能通过序列化去传输。 LinkedList 是非同步的。 属性1234567891011121314151617181920212223242526272829public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable&#123; transient int size = 0;// list中的元素个数 /** * 链表头节点 * 不变式: (first == null &amp;&amp; last == null) || (first.prev == null &amp;&amp; first.item != null) */ transient Node&lt;E&gt; first; /** * 链表尾节点 * 不变式: (first == null &amp;&amp; last == null) || (last.next == null &amp;&amp; last.item != null) */ transient Node&lt;E&gt; last; private static class Node&lt;E&gt; &#123; E item;// 实际存放的元素 Node&lt;E&gt; next;// 后一个节点 Node&lt;E&gt; prev;// 前一个节点 // 构造函数元素顺序分别为前，自己，后。就像排队一样 Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125; &#125; &#125; 构造方法由于采用的是链表结构，所以不像 ArrayList 一样，有指定容量的构造方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable&#123; /** * 构造一个空列表. */ public LinkedList() &#123; &#125; /** * 构造一个包含指定 collection 中的元素的列表，这些元素按其 collection 的迭代器返回的顺序排列 */ public LinkedList(Collection&lt;? extends E&gt; c) &#123; this();// 什么都不做 addAll(c);// 将 c 集合里的元素添加进链表 &#125; /** * 按照指定集合的迭代器返回的顺序将指定集合中的所有元素追加到此列表的末尾。 */ public boolean addAll(Collection&lt;? extends E&gt; c) &#123; return addAll(size, c); &#125; private void checkPositionIndex(int index) &#123; if (!isPositionIndex(index)) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; /** * 判断参数是迭代器或添加操作的有效位置的索引。 */ private boolean isPositionIndex(int index) &#123; return index &gt;= 0 &amp;&amp; index &lt;= size; &#125; /** * 从指定位置开始，将指定集合中的所有元素插入此列表。 * 将当前位置的元素（如果有）和任何后续元素向右移动（增加其索引）。 * 新元素将按照指定集合的迭代器返回的顺序出现在列表中。 */ public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; checkPositionIndex(index);// 检查索引是否正确，即在 0 &lt;= index &lt;= size Object[] a = c.toArray();// 将 collection 转为数组 int numNew = a.length; if (numNew == 0) return false; Node&lt;E&gt; pred, succ;// 声明 pred 为"当前要插入节点的前一个节点"，succ 为"当前要插入节点的后一个节点" if (index == size) &#123;// 说明要插入元素的位置就在链表的末尾，后置元素为null，前一个元素就是last succ = null; pred = last; &#125; else &#123; // 说明在链表的中间插入，这时 pred 为原来 index 的 prev，succ 为原来的元素 succ = node(index);// 利用双向链表的特性，进行更快的遍历 pred = succ.prev; &#125; for (Object o : a) &#123;// 遍历数组，逐个添加 @SuppressWarnings("unchecked") E e = (E) o; Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null); if (pred == null) first = newNode; else pred.next = newNode; pred = newNode;// 将新节点作为pred，为下一个元素插入做准备 &#125; if (succ == null) &#123;// 如果后继元素为空，那么插入完后的最后一个元素，就 pred 就是 last last = pred; &#125; else &#123;// 否则就维护最后一个元素和之前的元素之间的关系 pred.next = succ; succ.prev = pred; &#125; size += numNew; modCount++;// 链表结构发生改动 return true; &#125; /** * 返回指定元素索引处的(非空)节点 * 利用双向链表的特性，进行更快的遍历 * 双向链表和索引值联系起来：通过一个计数索引值来实现 * 当我们调用get(int index)时，首先会比较“index”和“双向链表长度的1/2”； * 若前者大，则从链表头开始往后查找，直到 index 位置； * 否则，从链表末尾开始先前查找，直到 index 位置. */ Node&lt;E&gt; node(int index) &#123; // assert isElementIndex(index); if (index &lt; (size &gt;&gt; 1)) &#123;// 如果index在链表的前半部分，则从头部节点开始遍历 Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123;// 如果index在链表的后半部分，则从尾部节点开始遍历 Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125; &#125;&#125; 增加 add(E e)作为链表，添加新元素就是在链表的末尾插入新元素。 注意，如果末尾元素是 null ，又该如何处理？ 12345678910111213141516171819202122232425public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable&#123; /** * 将指定的元素追加到此列表的末尾。 */ public boolean add(E e) &#123; linkLast(e); return true; &#125; /** * 链接 e 作为最后一个元素。 */ void linkLast(E e) &#123; final Node&lt;E&gt; l = last;// 记录last节点 final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);// 初始化新的节点 last = newNode; if (l == null)// 末尾元素是 null,是个空列表 first = newNode; else l.next = newNode; size++; modCount++;// 链表结构发生改动 &#125;&#125; LinkedList 还有其他的增加方法： add(int index, E element)：在此列表中指定的位置插入指定的元素。 addAll(Collection&lt;? extends E&gt; c)：添加指定 collection 中的所有元素到此列表的结尾，顺序是指定 collection 的迭代器返回这些元素的顺序。 addAll(int index, Collection&lt;? extends E&gt; c)：将指定 collection 中的所有元素从指定位置开始插入此列表。 AddFirst(E e): 将指定元素插入此列表的开头。 addLast(E e): 将指定元素添加到此列表的结尾。 移除处理思路： 由于插入的元素可能为null，所以要对o进行判断，否则不论是o为null还是遍历的时候元素为null，都会导致报空指针异常 找到元素后，对前后的元素关系重新维护，要考虑到元素是否在头尾的情况 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable&#123; public boolean remove(Object o) &#123; if (o == null) &#123;// 是否为 null 的判断 // 从头节点遍历链表寻找第一个 x(null) 元素 for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) &#123; unlink(x);// 取消链接 x(null) 元素，重新维护删除元素后的前后关系 return true; &#125; &#125; &#125; else &#123;// 与上面的逻辑相同 for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) &#123; unlink(x); return true; &#125; &#125; &#125; return false; &#125; /** * Unlinks non-null node x. */ E unlink(Node&lt;E&gt; x) &#123; // assert x != null; final E element = x.item; // 局部保存被删除节点的前后节点 final Node&lt;E&gt; next = x.next; final Node&lt;E&gt; prev = x.prev; if (prev == null) &#123;// prev 为 null 说明 x 节点为 first 节点，则删除后，next 为 first first = next; &#125; else &#123;// 否则 prev的下一个元素为x的next prev.next = next; x.prev = null;// 设为 null，方便GC &#125; if (next == null) &#123;// next 为null说明x节点为 last 节点，则删除后，next 为 prev last = prev; &#125; else &#123;// 否则 next 的上一个元素为x的prev next.prev = prev; x.next = null;// 设为 null，方便GC &#125; x.item = null;// 设为 null，方便GC size--; modCount++;// 链表结构发生改变 return element;//返回被删除节点的数据体 &#125;&#125; 其他的移除方法： clear()： 从此列表中移除所有元素。 remove()：获取并移除此列表的头（第一个元素）。 remove(int index)：移除此列表中指定位置处的元素。 remove(Objec o)：从此列表中移除首次出现的指定元素（如果存在）。 removeFirst()：移除并返回此列表的第一个元素。 removeFirstOccurrence(Object o)：从此列表中移除第一次出现的指定元素（从头部到尾部遍历列表时）。 removeLast()：移除并返回此列表的最后一个元素。 removeLastOccurrence(Object o)：从此列表中移除最后一次出现的指定元素（从头部到尾部遍历列表时）。 查询查询的方法非常简单， 1234567public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable&#123; public E get(int index) &#123; checkElementIndex(index);// 检查索引index 是否在 [0,size] 区间内 return node(index).item;//利用双向链表的特性，进行更快的遍历 &#125;&#125; 其它的查询方法： getFirst()：返回此列表的第一个元素。 getLast()：返回此列表的最后一个元素。 indexOf(Object o)：返回此列表中首次出现的指定元素的索引，如果此列表中不包含该元素，则返回 -1。 lastIndexOf(Object o)：返回此列表中最后出现的指定元素的索引，如果此列表中不包含该元素，则返回 -1。 迭代器 listIterator关于集合的快速失败机制的详细了解可以看这里 iterator() 调用的其实是 listIterator() 方法，对于不同的实现类，都会实现不同的方法，但是其原理是一致的，都是为了防止多线程操作同一个集合而出现的问题 123456789101112131415161718192021222324252627282930313233343536373839404142public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable&#123; public ListIterator&lt;E&gt; listIterator(int index) &#123; checkPositionIndex(index);// 检查索引的正确性[0, size] return new ListItr(index); &#125; private class ListItr implements ListIterator&lt;E&gt; &#123; private Node&lt;E&gt; lastReturned;// 记录上次返回的元素 private Node&lt;E&gt; next;// 记录下一个元素 private int nextIndex; private int expectedModCount = modCount;// 用来判断迭代过程中，是否有对元素的改动(fail-fast) ListItr(int index) &#123; // assert isPositionIndex(index); next = (index == size) ? null : node(index);//初始化next，以便在next方法中返回 nextIndex = index; &#125; public boolean hasNext() &#123; return nextIndex &lt; size; &#125; public E next() &#123; checkForComodification();// 判断是否有对元素的改动，有则抛出异常 if (!hasNext()) throw new NoSuchElementException(); lastReturned = next;// next()当中的next元素就是要返回的结果 next = next.next; nextIndex++; return lastReturned.item; &#125; // 省略其它代码。。。 final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; &#125;&#125; 有关队列、栈的方法 peek():返回第一个节点,若LinkedList的大小为0,则返回null peekFirst():返回第一个节点,若LinkedList的大小为0,则返回null peekLast():返回最后一个节点,若LinkedList的大小为0,则返回null element():返回第一个节点,若LinkedList的大小为0,则抛出异常 poll():删除并返回第一个节点,若LinkedList的大小为0,则返回null pollFirst():删除并返回第一个节点,若LinkedList的大小为0,则返回null pollLast():删除并返回最后一个节点,若LinkedList的大小为0,则返回null offer(E e):将e添加双向链表末尾 offerFirst(E e):将e添加双向链表开头 offerLast(E e):将e添加双向链表末尾 push(E e):将e插入到双向链表开头 pop():删除并返回第一个节点 LinkedList 作为 FIFO(先进先出) 的队列, 下表的方法等效： 队列方法 等效方法 add(e) addLast(e) offer(e) offerLast(e) remove() removeFirst() poll() pollFirst() element() getFirst() peek() peekFirst() LinkedList 作为 LIFO(后进先出) 的栈, 下表的方法等效： 栈方法 等效方法 push(e) addFirst(e) pop() removeFirst() peek() peekFirst() LinkedList 的遍历方法和性能比较使用示例总结 LinkedList 实际上是通过双向链表去实现的。它包含一个非常重要的内部类：Node。Node 是双向链表节点所对应的数据结构，它包括的属性有：当前节点所包含的值，上一个节点，下一个节点。 从 LinkedList 的实现方式中可以发现，它不存在LinkedList容量不足的问题。 LinkedList 的克隆函数，即是将全部元素克隆到一个新的LinkedList对象中。 LinkedList 实现java.io.Serializable。当写入到输出流时，先写入“容量”，再依次写入“每一个节点保护的值”；当读出输入流时，先读取“容量”，再依次读取“每一个元素”。 由于 LinkedList 实现了Deque，而 Deque 接口定义了在双端队列两端访问元素的方法。提供插入、移除和检查元素的方法。每种方法都存在两种形式：一种形式在操作失败时抛出异常，另一种形式返回一个特殊值（null 或 false，具体取决于操作）。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合学习之fail-fast]]></title>
    <url>%2Fpassages%2FJava%E9%9B%86%E5%90%88%E5%AD%A6%E4%B9%A0%E4%B9%8Bfail-fast%2F</url>
    <content type="text"><![CDATA[[TOC] 概要本文主要以 ArrayList 为例，对 Iterator 的快速失败(fail-fast), 也就是 Java 集合的错误检测机制进行学习总结。主要内容有： 简介 错误展示 问题解决 理解原理 JDK的解决办法 简介“快速失败”也就是 fail-fast，它是 Java 集合的一种错误检测机制。当多个线程对集合进行结构上的改变的操作时，有可能会产生 fail-fast 机制。记住是有可能，而不是一定。例如：假设存在两个线程（线程 1、线程 2），线程 1 通过 Iterator 在遍历集合 A 中的元素，在某个时候线程 2 修改了集合 A 的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生 fail-fast 机制。 错误示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.littlefxc.examples.base.collections;import java.util.ArrayList;import java.util.Iterator;import java.util.List;/** * Java 集合的错误检测机制 fail-fast 的示例 * * @author fengxuechao */public class FailFastTest &#123; private static List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); //private static List&lt;String&gt; list = new CopyOnWriteArrayList&lt;String&gt;(); /** * 线程one迭代list */ private static class threadOne extends Thread &#123; @Override public void run() &#123; Iterator&lt;Integer&gt; iterator = list.iterator(); while (iterator.hasNext()) &#123; int i = iterator.next(); System.out.println("ThreadOne 遍历:" + i); try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; /** * 当i == 3时，修改list */ private static class threadTwo extends Thread &#123; @Override public void run() &#123; int i = 0; while (i &lt; 6) &#123; System.out.println("ThreadTwo run：" + i); if (i == 3) &#123; list.remove(i); &#125; i++; &#125; &#125; &#125; public static void main(String[] args) &#123; for (int i = 0; i &lt; 10; i++) &#123; list.add(i); &#125; new threadOne().start(); new threadTwo().start(); &#125;&#125; 运行结果： 12345678910111213ThreadOne 遍历:0ThreadTwo run：0ThreadTwo run：1ThreadTwo run：2ThreadTwo run：3ThreadTwo run：4ThreadTwo run：5Exception in thread &quot;Thread-0&quot; java.util.ConcurrentModificationException at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:901) at java.util.ArrayList$Itr.next(ArrayList.java:851) at com.littlefxc.examples.base.collections.FailFastTest$threadOne.run(FailFastTest.java:25)Process finished with exit code 0 问题解决先说解决办法： 在遍历过程中所有涉及到改变 modCount 值得地方全部加上 synchronized 或者直接使用 Collections.synchronizedList，这样就可以解决。但是不推荐，因为增删造成的同步锁可能会阻塞遍历操作。 使用 CopyOnWriteArrayList 来替换 ArrayList。推荐使用该方案。 理解原理同过上面的错误示例和问题解决，可以初步了解到产生 fail-fast 的原因就在于当某一个线程遍历list的过程中，list的内容被另外一个线程所改变了；就会抛出 ConcurrentModificationException 异常，产生fail-fast事件。 ConcurrentModificationException 的产生：当方法检测到对象的并发修改，但不允许这种修改时就抛出该异常。 也就是说，即便是在单线程环境中，只要违反了规则，同样也可能会抛出异常。 当我对代码运行多次时，发现代码运行有几率不抛出异常，这就说明迭代器的快速失败行为并不能得到保证，所以，不要写依赖这个异常的程序代码。正确的做法是：ConcurrentModificationException 应该仅用于检测 bug。 AbstractList 抛出 ConcurrentModificationException 的部分代码(Java8)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package java.util;public abstract class AbstractList&lt;E&gt; extends AbstractCollection&lt;E&gt; implements List&lt;E&gt; &#123; //神略代码... // AbstractList中唯一的属性 // 用来记录List修改的次数：每修改一次(添加/删除等操作)，将modCount+1 protected transient int modCount = 0; // 返回List对应迭代器。实际上，是返回Itr对象。 public Iterator&lt;E&gt; iterator() &#123; return new Itr(); &#125; // Itr是Iterator(迭代器)的实现类 private class Itr implements Iterator&lt;E&gt; &#123; int cursor = 0; int lastRet = -1; // 修改数的记录值。 // 每次新建Itr()对象时，都会保存新建该对象时对应的modCount； // 以后每次遍历List中的元素的时候，都会比较expectedModCount和modCount是否相等； // 若不相等，则抛出ConcurrentModificationException异常，产生fail-fast事件。 int expectedModCount = modCount; public boolean hasNext() &#123; return cursor != size(); &#125; public E next() &#123; // 获取下一个元素之前，都会判断“新建Itr对象时保存的modCount”和“当前的modCount”是否相等； // 若不相等，则抛出ConcurrentModificationException异常，产生fail-fast事件。 checkForComodification(); try &#123; E next = get(cursor); lastRet = cursor++; return next; &#125; catch (IndexOutOfBoundsException e) &#123; checkForComodification(); throw new NoSuchElementException(); &#125; &#125; public void remove() &#123; if (lastRet == -1) throw new IllegalStateException(); checkForComodification(); try &#123; AbstractList.this.remove(lastRet); if (lastRet &lt; cursor) cursor--; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException e) &#123; throw new ConcurrentModificationException(); &#125; &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; &#125; //省略代码...&#125; 从中，我们可以发现在调用 next() 和 remove()时，都会执行 checkForComodification()。若 “modCount 不等于 expectedModCount”，则抛出ConcurrentModificationException异常，产生fail-fast事件。 要搞明白 fail-fast机制，我们就要需要理解什么时候“modCount 不等于 expectedModCount”！从Itr类中，我们知道 expectedModCount 在创建Itr对象时，被赋值为 modCount。通过Itr，我们知道：expectedModCount不可能被修改为不等于 modCount。所以，需要考证的就是modCount何时会被修改。 那么它(modCount)在什么时候因为什么原因而发生改变呢？ ArrayList部分源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123; /** * 最小化列表容量 */ public void trimToSize() &#123; modCount++; if (size &lt; elementData.length) &#123; elementData = (size == 0) ? EMPTY_ELEMENTDATA : Arrays.copyOf(elementData, size); &#125; &#125; /** * 确定动态扩容所需容量 */ public void ensureCapacity(int minCapacity) &#123; int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) // any size if not default element table ? 0 // larger than default for default empty table. It's already // supposed to be at default size. : DEFAULT_CAPACITY; if (minCapacity &gt; minExpand) &#123; ensureExplicitCapacity(minCapacity); &#125; &#125; /** * 确定动态扩容所需容量 */ private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity); &#125; /** * 动态扩容 */ private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; /** * 1. 将指定元素的索引及后续元素的索引向右移动(索引+1) * 2. 在指定的索引插入元素 */ public void add(int index, E element) &#123; rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; &#125; /** * 1. 将指定索引及后续元素的索引向左移动 * 2. 数组元素实际数量 - 1 */ public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue; &#125; // 循环比较元素，获取要移除元素的索引，然后将该索引及后续元素的索引向左移动 public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false; &#125; private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work &#125; /** * 循环设置所有元素值为null, 加快垃圾回收 */ public void clear() &#123; modCount++; // clear to let GC do its work for (int i = 0; i &lt; size; i++) elementData[i] = null; size = 0; &#125;&#125; 从上面的源代码我们可以看出，ArrayList 中无论 add、remove、clear 方法只要是涉及了改变 ArrayList 元素的个数的方法都会导致 modCount 的改变。所以我们这里可以初步判断由于 expectedModCount 得值与 modCount 的改变不同步，导致两者之间不等从而产生 fail-fast 机制。 场景还原： 有两个线程（线程 A，线程 B），其中线程 A 负责遍历 list、线程B修改 list。线程 A 在遍历 list 过程的某个时候（此时 expectedModCount = modCount=N），线程启动，同时线程B增加一个元素，这是 modCount 的值发生改变（modCount + 1 = N + 1）。线程 A 继续遍历执行 next 方法时，通告 checkForComodification 方法发现 expectedModCount = N ，而 modCount = N + 1，两者不等，这时就抛出ConcurrentModificationException 异常，从而产生 fail-fast 机制。 至此，我们就完全了解了fail-fast是如何产生的！ 也就是，当多个线程对同一个集合进行操作的时候，某线程访问集合的过程中，该集合的内容被其他线程所改变(即其它线程通过add、remove、clear等方法，改变了modCount的值)；这时，就会抛出ConcurrentModificationException异常，产生fail-fast事件。 JDK的解决办法：CopyOnWriteArrayListCopyOnWriteArrayList 是 ArrayList 的一个线程安全的变体，其中所有可变操作（add、set 等等）都是通过对底层数组进行一次新的复制来实现的。该类产生的开销比较大，但是在两种情况下，它非常适合使用。 在不能或不想进行同步遍历，但又需要从并发线程中排除冲突时。 当遍历操作的数量大大超过可变操作的数量时。 遇到这两种情况使用 CopyOnWriteArrayList 来替代 ArrayList 再适合不过了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package java.util.concurrent;import java.util.*;import java.util.concurrent.locks.*;import sun.misc.Unsafe;public class CopyOnWriteArrayList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123; // 省略代码... // 返回集合对应的迭代器 public Iterator&lt;E&gt; iterator() &#123; return new COWIterator&lt;E&gt;(getArray(), 0); &#125; // 省略代码... private static class COWIterator&lt;E&gt; implements ListIterator&lt;E&gt; &#123; private final Object[] snapshot; private int cursor; private COWIterator(Object[] elements, int initialCursor) &#123; cursor = initialCursor; // 新建COWIterator时，将集合中的元素保存到一个新的拷贝数组中。 // 这样，当原始集合的数据改变，拷贝数据中的值也不会变化。 snapshot = elements; &#125; public boolean hasNext() &#123; return cursor &lt; snapshot.length; &#125; public boolean hasPrevious() &#123; return cursor &gt; 0; &#125; public E next() &#123; if (! hasNext()) throw new NoSuchElementException(); return (E) snapshot[cursor++]; &#125; public E previous() &#123; if (! hasPrevious()) throw new NoSuchElementException(); return (E) snapshot[--cursor]; &#125; public int nextIndex() &#123; return cursor; &#125; public int previousIndex() &#123; return cursor-1; &#125; public void remove() &#123; throw new UnsupportedOperationException(); &#125; public void set(E e) &#123; throw new UnsupportedOperationException(); &#125; public void add(E e) &#123; throw new UnsupportedOperationException(); &#125; &#125; // 省略代码...&#125; 可以从上面的源码中可以看出： 和 ArrayList 继承于 AbstractList 不同，CopyOnWriteArrayList 没有继承于 AbstractList，它仅仅只是实现了 List 接口。 ArrayList 的 iterator() 函数返回的 Iterator 是在 AbstractList 中实现的；而 CopyOnWriteArrayList 是自己实现 Iterator。 ArrayList 的 Iterator 实现类中调用 next() 时，会“调用 checkForComodification() 比较 expectedModCount 和 modCount 的大小”；但是，CopyOnWriteArrayList 的 Iterator 实现类中，没有所谓的 checkForComodification()，更不会抛出 ConcurrentModificationException 异常！ CopyOnWriterArrayList 的 add 方法与 ArrayList 的 add 方法有一个最大的不同点就在于，下面三句代码： 123Object[] newElements = Arrays.copyOf(elements, len + 1);newElements[len] = e;setArray(newElements); 就是这三句代码使得 CopyOnWriterArrayList 不会抛 ConcurrentModificationException 异常。它们就是 copy 原来的 array，再在 copy 数组上进行 add 操作，这样做就完全不会影响 COWIterator 中的 array 了 CopyOnWriterArrayList 的核心概念就是： 任何对 array 在结构上有所改变的操作（add、remove、clear 等），CopyOnWriterArrayList 都会 copy 现有的数据，再在 copy 的数据上修改，这样就不会影响 COWIterator 中的数据了，修改完成之后改变原有数据的引用即可。同时这样造成的代价就是产生大量的对象，同时数组的 copy 也是相当有损耗的。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring+MyBatis+MySQL主从分离]]></title>
    <url>%2Fpassages%2FSpring-MyBatis-MySQL%E4%B8%BB%E4%BB%8E%E5%88%86%E7%A6%BB%2F</url>
    <content type="text"><![CDATA[Spring + MyBatis + MySQL主从分离基于 Docker 的 MySQL 主从复制搭建基于 Docker 的 MySQL 主从复制搭建 前言在大型应用程序中，配置主从数据库并使用读写分离是常见的设计模式。而要对现有的代码在不多改变源码的情况下，可以使用 Spring 的 AbstractRoutingDataSource 和 Mybatis 的 Interceptor 为核心做到感知mysql读写分离 配置多数据源使用了 druid 数据库连接池，配置 master datasource 为写数据库，配置 slave datasource 为读数据库。 1234567891011121314151617181920212223242526272829303132spring.datasource.druid.filter.slf4j.enabled=truespring.datasource.druid.filter.slf4j.statement-create-after-log-enabled=falsespring.datasource.druid.filter.slf4j.statement-close-after-log-enabled=falsespring.datasource.druid.filter.slf4j.result-set-open-after-log-enabled=falsespring.datasource.druid.filter.slf4j.result-set-close-after-log-enabled=false# master datasourcespring.datasource.druid.master.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.druid.master.url=jdbc:mysql://localhost:3306/learn?useSSl=falsespring.datasource.druid.master.password=rootspring.datasource.druid.master.username=root# slave datasourcespring.datasource.druid.slave.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.druid.slave.url=jdbc:mysql://localhost:3307/learn?useSSl=falsespring.datasource.druid.slave.password=rootspring.datasource.druid.slave.username=rootspring.jackson.date-format=yyyy-MM-dd HH:mm:ssspring.jackson.time-zone=GMT+8spring.jackson.default-property-inclusion=alwaysspring.jackson.property-naming-strategy=SNAKE_CASEmybatis.type-aliases-package=com.fengxuechao.examples.rwdb.entitymybatis.configuration.use-generated-keys=truemybatis.configuration.map-underscore-to-camel-case=truemybatis.configuration.default-fetch-size=100mybatis.configuration.default-statement-timeout=30mybatis.configuration.cache-enabled=truelogging.level.root=infologging.level.com.fengxuechao.examples.rwdb=debuglogging.level.druid.sql.Statement=error 使用 Spring 的 AbstractRoutingDataSource 动态切换数据源用枚举标记读写数据源1234567891011public enum RoutingType &#123; /** * 代表写数据库 */ MASTER, /** * 代表读数据库 */ SLAVE;&#125; 用 ThreadLocal 记录当前线程数据源在Servlet的线程模型中，使用ThreadLocal存储key最合适，因此，编写一个RoutingDataSourceContext，来设置并动态存储key： 1234567891011121314151617181920212223242526public class RoutingDataSourceContext implements AutoCloseable &#123; private static final ThreadLocal&lt;RoutingType&gt; contextHolder = new ThreadLocal&lt;&gt;(); public RoutingDataSourceContext(RoutingType routingType) &#123; contextHolder.set(routingType); &#125; public static void setRoutingType(RoutingType routingType) &#123; Assert.notNull(routingType, "routingType cannot be null"); contextHolder.set(routingType); &#125; public static RoutingType getRoutingType() &#123; return contextHolder.get(); &#125; public static void clear() &#123; contextHolder.remove(); &#125; @Override public void close() throws Exception &#123; clear(); &#125;&#125; 自定义路由数据源实现用Spring内置的RoutingDataSource，把两个真实的数据源代理为一个动态数据源： 1234567public class RoutingDataSource extends AbstractRoutingDataSource &#123; @Override protected Object determineCurrentLookupKey() &#123; return RoutingDataSourceContext.getRoutingType(); &#125;&#125; 配置路由数据源对于 RoutingDataSource 需要在SpringBoot中配置好并设置为主数据源： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * @author fengxuechao */@Slf4j@Configuration@EnableTransactionManagementpublic class DbConfig &#123; /** * 写数据库 * * @return */ @Bean @ConfigurationProperties("spring.datasource.druid.master") public DataSource masterDataSource() &#123; return DruidDataSourceBuilder.create().build(); &#125; /** * 读数据库 * * @return */ @Bean @ConfigurationProperties("spring.datasource.druid.slave") public DataSource slaveDataSource() &#123; return DruidDataSourceBuilder.create().build(); &#125; /** * 路由数据源 * 一定要加 @Primary 使得 &#123;@link MybatisInterceptor&#125; 插件生效 * * @return */ @Bean @Primary public DataSource dataSource() &#123; log.info("create routing datasource..."); Map&lt;Object, Object&gt; map = new HashMap&lt;&gt;(); map.put(RoutingType.MASTER, masterDataSource()); map.put(RoutingType.SLAVE, slaveDataSource()); RoutingDataSource routing = new RoutingDataSource(); routing.setTargetDataSources(map); routing.setDefaultTargetDataSource(masterDataSource()); return routing; &#125; /** * 添加 MybatisInterceptor 拦截器 * @param dataSource * @return */ @Bean public SqlSessionFactoryBean sqlSessionFactory(DataSource dataSource) &#123; SqlSessionFactoryBean sfb = new SqlSessionFactoryBean(); sfb.setDataSource(dataSource); sfb.setPlugins(new Interceptor[]&#123;new MybatisInterceptor()&#125;); return sfb; &#125;&#125; 使用 MyBatis 的 Interceptor 拦截器对update使用写库，对query使用读库原理： 查看 org.apache.ibatis.executor.Executor 可以发现 MyBatis 执行 sql 的语句都在这里边了： 123456789101112public interface Executor &#123; // 执行sql 的 update, delete, insert int update(MappedStatement ms, Object parameter) throws SQLException; // 执行sql 的 select &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey cacheKey, BoundSql boundSql) throws SQLException; // 执行sql 的 select &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException;&#125; 只要拦截这三个方法，是的 update() 方法使用写数据库，query() 方法使用读数据库就可以做到在不改写原业务代码的情况下使用多数据源，同时让Spring事务也正常运行。 拦截器： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/** * 拦截器，对update使用写库，对query使用读库 * 优势：源代码不变（通过mybatis拦截器），易扩展 * * @author fengxuechao * @date 2019-03-22 */@Intercepts(&#123; @Signature( type = Executor.class, method = "update", args = &#123;MappedStatement.class, Object.class&#125;), @Signature( type = Executor.class, method = "query", args = &#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class&#125;),&#125;)@Slf4jpublic class MybatisInterceptor implements Interceptor &#123; /** * 用map对象缓存数据，数据量大的话，此处需要优化。 */ private static final Map&lt;String, RoutingType&gt; cacheMap = new ConcurrentHashMap&lt;&gt;(); /** * 通过正则表达式，拦截sql语句匹配类型设置数据源。 */ private static final String REGEX = ".*insert\\u0020.*|.*delete\\u0020.*|.*update\\u0020.*"; @Override public Object intercept(Invocation invocation) throws Throwable &#123; boolean synchronizationActive = TransactionSynchronizationManager.isSynchronizationActive(); if (!synchronizationActive) &#123; Object[] objects = invocation.getArgs(); MappedStatement ms = (MappedStatement) objects[0]; RoutingType routingType; if ((routingType = cacheMap.get(ms.getId())) == null) &#123; //读方法 if (ms.getSqlCommandType().equals(SqlCommandType.SELECT)) &#123; //!selectKey 为自增id查询主键(SELECT LAST_INSERT_ID() )方法，使用主库 if (ms.getId().contains(SelectKeyGenerator.SELECT_KEY_SUFFIX)) &#123; routingType = RoutingType.MASTER; &#125; else &#123; BoundSql boundSql = ms.getSqlSource().getBoundSql(objects[1]); String sql = boundSql.getSql().toLowerCase(Locale.CHINA).replaceAll("[\\t\\n\\r]", " "); if (sql.matches(REGEX)) &#123; routingType = RoutingType.MASTER; &#125; else &#123; routingType = RoutingType.SLAVE; &#125; &#125; &#125; else &#123; routingType = RoutingType.MASTER; &#125; if (log.isDebugEnabled())&#123; log.debug("设置方法[&#123;&#125;] use [&#123;&#125;] Strategy, SqlCommandType [&#123;&#125;]..", ms.getId(), routingType.name(), ms.getSqlCommandType().name()); &#125; cacheMap.put(ms.getId(), routingType); &#125; RoutingDataSourceContext.setRoutingType(routingType); &#125; return invocation.proceed(); &#125; @Override public Object plugin(Object target) &#123; if (target instanceof Executor) &#123; return Plugin.wrap(target, this); &#125; else &#123; return target; &#125; &#125; @Override public void setProperties(Properties properties) &#123; &#125;&#125; 注意：需要在 Mybatis 的 SqlSessionFactory 中将此拦截器放入 123456789101112/** * 添加 MybatisInterceptor 拦截器 * @param dataSource * @return */@Beanpublic SqlSessionFactoryBean sqlSessionFactory(DataSource dataSource) &#123; SqlSessionFactoryBean sfb = new SqlSessionFactoryBean(); sfb.setDataSource(dataSource); sfb.setPlugins(new Interceptor[]&#123;new MybatisInterceptor()&#125;); return sfb;&#125; 测试12345678910111213141516171819/** * @author fengxuechao */@Repositorypublic interface CityMapper &#123; @Select("SELECT id,name,city_code as cityCode,post_code as postCode FROM city WHERE id = #&#123;id&#125; limit 1") City findById(Integer id); @Insert("INSERT INTO city(name, city_code, post_code) VALUES(#&#123;name&#125;, #&#123;cityCode&#125;, #&#123;postCode&#125;)") @Options(useGeneratedKeys = true, keyProperty = "id") int insert(City city); @Select("SELECT * FROM city WHERE id = #&#123;id&#125; limit 100") List&lt;City&gt; findAll(); @Update("UPDATE city SET name=#&#123;name&#125;,city_code=#&#123;cityCode&#125;,post_code=#&#123;postCode&#125; WHERE id =#&#123;id&#125;") int update(City city);&#125; 12345678910111213141516171819202122232425262728293031323334/** * @author fengxuechao * @date 2019/3/22 */@RestController@RequestMapping("/city")@Slf4jpublic class CityController &#123; @Autowired CityMapper cityMapper; // @RoutingWith(value = RoutingType.SLAVE) @GetMapping("/&#123;id&#125;") public City get(@PathVariable Integer id) &#123; return cityMapper.findById(id); &#125; @GetMapping public List&lt;City&gt; list() &#123; return cityMapper.findAll(); &#125; @PutMapping public City update(@RequestBody City city) &#123; if (city.getId() != null) &#123; cityMapper.update(city); cityMapper.findById(city.getId()); return city; &#125; return null; &#125;&#125; 日志： 参考： https://www.liaoxuefeng.com/article/00151054582348974482c20f7d8431ead5bc32b30354705000 https://www.cnblogs.com/fangjian0423/p/mybatis-interceptor.html]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>mybatis</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker+mysql主从配置]]></title>
    <url>%2Fpassages%2FDocker-mysql%E4%B8%BB%E4%BB%8E%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Docker + mysql主从配置文件结构 主 mysql 的配置:master.cnf12345678910111213141516[mysqld]## 设置server_id，一般设置为IP，注意要唯一server_id=100## 复制过滤：也就是指定哪个数据库不用同步（mysql库一般不同步）binlog-ignore-db=mysql## 开启二进制日志功能，可以随便取，最好有含义（关键就是这里了）log-bin=replicas-mysql-bin## 为每个session分配的内存，在事务过程中用来存储二进制日志的缓存binlog_cache_size=1M## 主从复制的格式（mixed,statement,row，默认格式是statement）binlog_format=mixed## 二进制日志自动删除/过期的天数。默认值为0，表示不自动删除。expire_logs_days=7## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致slave_skip_errors=1062 从 mysql 的配置:slave.cnf12345678910111213141516171819202122[mysqld]## 设置server_id，一般设置为IP，注意要唯一server_id=101## 复制过滤：也就是指定哪个数据库不用同步（mysql库一般不同步）binlog-ignore-db=mysql## 开启二进制日志功能，以备Slave作为其它Slave的Master时使用log-bin=replicas-mysql-slave1-bin## 为每个session 分配的内存，在事务过程中用来存储二进制日志的缓存binlog_cache_size=1M## 主从复制的格式（mixed,statement,row，默认格式是statement）binlog_format=mixed## 二进制日志自动删除/过期的天数。默认值为0，表示不自动删除。expire_logs_days=7## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致slave_skip_errors=1062## relay_log配置中继日志relay_log=replicas-mysql-relay-bin## log_slave_updates表示slave将复制事件写进自己的二进制日志log_slave_updates=1## 防止改变数据(除了特殊的线程)read_only=1 配置mysql主从的脚本：mysql_connector.sh12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#!/bin/bashBASE_PATH=$(dirname $0)echo "Waiting for mysql to get up"# Give 60 seconds for master and slave to come upsleep 60echo "Create MySQL Servers (master / slave repl)"echo "-----------------"echo "* Create replication user"mysql --host mysqlslave -uroot -p$MYSQL_SLAVE_PASSWORD -AN -e 'STOP SLAVE;';mysql --host mysqlmaster -uroot -p$MYSQL_MASTER_PASSWORD -AN -e 'RESET SLAVE ALL;';mysql --host mysqlmaster -uroot -p$MYSQL_MASTER_PASSWORD -AN -e "CREATE USER '$MYSQL_REPLICATION_USER'@'%';"mysql --host mysqlmaster -uroot -p$MYSQL_MASTER_PASSWORD -AN -e "GRANT REPLICATION SLAVE ON *.* TO '$MYSQL_REPLICATION_USER'@'%' IDENTIFIED BY '$MYSQL_REPLICATION_PASSWORD';"mysql --host mysqlmaster -uroot -p$MYSQL_MASTER_PASSWORD -AN -e 'flush privileges;'echo "* Set MySQL01 as master on MySQL02"MYSQL01_Position=$(eval "mysql --host mysqlmaster -uroot -p$MYSQL_MASTER_PASSWORD -e 'show master status \G' | grep Position | sed -n -e 's/^.*: //p'")MYSQL01_File=$(eval "mysql --host mysqlmaster -uroot -p$MYSQL_MASTER_PASSWORD -e 'show master status \G' | grep File | sed -n -e 's/^.*: //p'")MASTER_IP=$(eval "getent hosts mysqlmaster|awk '&#123;print \$1&#125;'")echo $MASTER_IPmysql --host mysqlslave -uroot -p$MYSQL_SLAVE_PASSWORD -AN -e "CHANGE MASTER TO master_host='mysqlmaster', master_port=3306, \ master_user='$MYSQL_REPLICATION_USER', master_password='$MYSQL_REPLICATION_PASSWORD', master_log_file='$MYSQL01_File', \ master_log_pos=$MYSQL01_Position;"echo "* Set MySQL02 as master on MySQL01"MYSQL02_Position=$(eval "mysql --host mysqlslave -uroot -p$MYSQL_SLAVE_PASSWORD -e 'show master status \G' | grep Position | sed -n -e 's/^.*: //p'")MYSQL02_File=$(eval "mysql --host mysqlslave -uroot -p$MYSQL_SLAVE_PASSWORD -e 'show master status \G' | grep File | sed -n -e 's/^.*: //p'")SLAVE_IP=$(eval "getent hosts mysqlslave|awk '&#123;print \$1&#125;'")echo $SLAVE_IPmysql --host mysqlmaster -uroot -p$MYSQL_MASTER_PASSWORD -AN -e "CHANGE MASTER TO master_host='mysqlslave', master_port=3306, \ master_user='$MYSQL_REPLICATION_USER', master_password='$MYSQL_REPLICATION_PASSWORD', master_log_file='$MYSQL02_File', \ master_log_pos=$MYSQL02_Position;"echo "* Start Slave on both Servers"mysql --host mysqlslave -uroot -p$MYSQL_SLAVE_PASSWORD -AN -e "start slave;"echo "Increase the max_connections to 2000"mysql --host mysqlmaster -uroot -p$MYSQL_MASTER_PASSWORD -AN -e 'set GLOBAL max_connections=2000';mysql --host mysqlslave -uroot -p$MYSQL_SLAVE_PASSWORD -AN -e 'set GLOBAL max_connections=2000';mysql --host mysqlslave -uroot -p$MYSQL_SLAVE_PASSWORD -e "show slave status \G"echo "MySQL servers created!"echo "--------------------"echoecho Variables available fo you :-echoecho MYSQL01_IP : mysqlmasterecho MYSQL02_IP : mysqlslave docker-compose 配置文件12345678910111213141516171819202122232425262728293031323334version: &apos;2&apos;services: mysqlmaster: image: mysql:5.7.15 container_name: &quot;mysql_master1&quot; environment: - &quot;MYSQL_ROOT_PASSWORD=root&quot; volumes: - &quot;./data/mysql-master:/var/lib/mysql/&quot; - &quot;./config/mysql-master:/etc/mysql/conf.d/&quot; ports: - &quot;3306:3306&quot; mysqlslave: image: mysql:5.7.15 container_name: &quot;mysql_slave1&quot; environment: - &quot;MYSQL_ROOT_PASSWORD=root&quot; volumes: - &quot;./data/mysql-slave:/var/lib/mysql/&quot; - &quot;./config/mysql-slave:/etc/mysql/conf.d/&quot; ports: - &quot;3307:3306&quot; mysqlconfigure: image: mysql:5.7.15 container_name: &quot;mysql_configure&quot; environment: - &quot;MYSQL_SLAVE_PASSWORD=root&quot; - &quot;MYSQL_MASTER_PASSWORD=root&quot; - &quot;MYSQL_ROOT_PASSWORD=root&quot; - &quot;MYSQL_REPLICATION_USER=repl&quot; - &quot;MYSQL_REPLICATION_PASSWORD=repl&quot; volumes: - &quot;./mysql_connector.sh:/tmp/mysql_connector.sh&quot; command: /bin/bash -x /tmp/mysql_connector.sh]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JedisCommand接口说明]]></title>
    <url>%2Fpassages%2FJedisCommand%E6%8E%A5%E5%8F%A3%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>jedis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring-Security-Oauth2第二篇之配置客户端]]></title>
    <url>%2Fpassages%2FSpring-Security-Oauth2%E7%AC%AC%E4%BA%8C%E7%AF%87%E4%B9%8B%E9%85%8D%E7%BD%AE%E5%AE%A2%E6%88%B7%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[Spring-Security-Oauth2第二篇之配置客户端@[toc]在第一篇中，描述的都是授权服务器和资源服务器。本篇要描述的是关于如何配置客户端的示例。 首先，需要考虑在OAuth2中有四种不同的角色： 资源所有者 - 能够授予对其受保护资源的访问权限的实体 授权服务器 -在成功验证资源所有者 并获得其授权后， 向客户端授予访问令牌 资源服务器 - 需要访问令牌以允许或至少考虑访问其资源的组件 客户端 - 能够从授权服务器获取访问令牌的实体 使用 @EnableResourceServer 表示资源服务器 使用 @EnableOAuth2Sso 表示授权码类型的客户端 使用 @EnableOAuth2Client 表示客户端凭据类型的客户端 1. 项目结构实在抱歉，之前的关于客户端的项目结构图片贴错了（是第一篇的项目结构图）,下面换上正确的图片 2. maven 依赖12345678910111213141516171819202122232425262728293031&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.19.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security.oauth&lt;/groupId&gt; &lt;artifactId&gt;spring-security-oauth2&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-springsecurity4&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 3. 使用 @EnableOAuth2Sso 注解安全配置3.1. 客户端安全配置12345678910111213141516171819202122/** * 配置最核心的部分是用于启动单点登陆 @EnableOAuth2Sso 注解。 * 这里要注意，我们需要重写WebSecurityConfigurerAdapter 否则所有的路径都会受到SSO的保护， * 这样无论用户访问哪个页面都会被重定向到登录页面，在这个例子里，index和login页面是唯一不需要被防护的。 * * @author fengxuechao * @date 2019/3/27 */@EnableOAuth2Sso@Configurationpublic class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.antMatcher("/**") .authorizeRequests() .antMatchers("/", "/login**") .permitAll() .anyRequest() .authenticated(); http.csrf().disable(); &#125;&#125; 同时必须在授权服务器中的授权类型中添加授权码类型，同时添加回调链接(核心代码见 3.2. 授权服务器核心代码)。 3.2. 授权服务器核心代码123456789101112131415161718192021222324252627282930313233@Configuration@EnableAuthorizationServerpublic class AuthServerConfig extends AuthorizationServerConfigurerAdapter &#123; /** * 第三方用户客户端详情 * Grant Type代表当前授权的类型： * &lt;p&gt; * authorization_code：传统的授权码模式&lt;br&gt; * implicit：隐式授权模式&lt;br&gt; * password：资源所有者（即用户）密码模式&lt;br&gt; * client_credentials：客户端凭据（客户端ID以及Key）模式&lt;br&gt; * refresh_token：获取access token时附带的用于刷新新的token模式 * &lt;/p&gt; * * @param clients * @throws Exception */ @Override public void configure(ClientDetailsServiceConfigurer clients) throws Exception &#123; clients.jdbc(dataSource) .withClient("client_1") .secret("123456") .resourceIds(DEMO_RESOURCE_ID) .redirectUris("https://www.baidu.com", "http://localhost:8081/product/1", "http://localhost:8083/login") .accessTokenValiditySeconds(1200) .refreshTokenValiditySeconds(50000) .authorizedGrantTypes("client_credentials", "refresh_token", "password", "authorization_code") .scopes("all") .authorities("client") .autoApprove(true) .and().build(); &#125;&#125; redirectUris() 中的链接表示回调接口，其中 http://localhost:8083/login 是本次需要添加的 authorizedGrantTypes() 表示授权服务器支持的授权类型，本次添加了 authorization_code。 autoApprove(true) 表示自动授权 3.3. 配置文件123456789101112131415server.port=8083server.session.cookie.name=CLIENTSESSIONsecurity.oauth2.client.client-id=client_1security.oauth2.client.client-secret=123456security.oauth2.client.access-token-uri=http://localhost:8081/oauth/tokensecurity.oauth2.client.user-authorization-uri=http://localhost:8081/oauth/authorizesecurity.oauth2.client.scope=all# userInfoUri用户端点的URI，用于获取当前用户详细信息security.oauth2.resource.user-info-uri=http://localhost:8081/user/me# 解析令牌的地址security.oauth2.authorization.check-token-access=http://localhost:8001/oauth/check_tokensecurity.basic.enabled=falsespring.thymeleaf.cache=false 注意：在配置文件中要注意 server.session.cookie.name 的配置，因为 cookie 不会保存端口，所以要注意客户端的 cookie 名和授权服务器的 cookie 名的不同。 4. MVC 配置4.1. 客户端 API12345678910111213141516171819202122232425262728293031/** * @author fengxuechao * @date 2019/3/27 */@RestController@SpringBootApplicationpublic class ClientApp &#123; public static void main(String[] args) &#123; SpringApplication.run(ClientApp.class); &#125; @Autowired OAuth2RestTemplate restTemplate; @GetMapping("/securedPage") public ModelAndView securedPage(OAuth2Authentication authentication) &#123; return new ModelAndView("securedPage").addObject("authentication", authentication); &#125; @GetMapping("/remoteCall") public Map remoteCall() &#123; ResponseEntity&lt;Map&gt; responseEntity = restTemplate.getForEntity("http://127.0.0.1:8082/api/userinfo", Map.class); return responseEntity.getBody(); &#125; @Bean public OAuth2RestTemplate oauth2RestTemplate( OAuth2ClientContext oAuth2ClientContext, OAuth2ProtectedResourceDetails details) &#123; return new OAuth2RestTemplate(details, oAuth2ClientContext); &#125;&#125; 4.2. 客户端 MVC 映射1234567891011121314151617181920/** * @author fengxuechao * @date 2019/3/27 */@Configuration@EnableWebMvcpublic class WebMvcConfig extends WebMvcConfigurerAdapter &#123; @Bean public RequestContextListener requestContextListener() &#123; return new RequestContextListener(); &#125; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController("/").setViewName("forward:/index"); registry.addViewController("/index"); &#125;&#125; 4.3. 前端index.html123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"/&gt; &lt;title&gt;Spring Security SSO Client&lt;/title&gt; &lt;link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/css/bootstrap.min.css"/&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="container"&gt; &lt;div class="col-sm-12"&gt; &lt;h1&gt;Spring Security SSO Client&lt;/h1&gt; &lt;a class="btn btn-primary" href="securedPage"&gt;Login&lt;/a&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; securedPage.html1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"/&gt; &lt;title&gt;Spring Security SSO Client&lt;/title&gt; &lt;link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/css/bootstrap.min.css"/&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="container"&gt; &lt;div class="col-sm-12"&gt; &lt;h1&gt;Secured Page&lt;/h1&gt; Welcome, &lt;span th:text="$&#123;authentication.name&#125;"&gt;Name&lt;/span&gt; &lt;br/&gt; Your authorities are &lt;span th:text="$&#123;authentication.authorities&#125;"&gt;authorities&lt;/span&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 5. 测试启动授权服务器，资源服务器和客户端，进入客户端首页： 点击登陆，重定向到授权服务器的登陆页面,输入授权服务器信任的用户名(user_1)和密码(123456): 点击登陆，重定向到安全页面： 调用资源服务器资源： 6. 使用 @EnableOAuth2Client 注解安全配置如果使用客户端凭据模式就足够的话，那么对上文中的代码只需很少的配置即可完成客户端凭据模式的客户端。 6.1. 客户端安全配置1234567891011121314151617181920212223/** * 使用 @EnableOAuth2Client 注解来开启 client_credentials。 * 这里要注意的是要明确在配置文件中配置 security.oauth2.client.grant-type=client_credentials 。 * 同时允许要调用的接口，注意对比与 WebSecurityConfig 类的不同点。 * * @author fengxuechao * @date 2019/3/27 */@EnableOAuth2Client@Configurationpublic class WebSecurityConfig2 extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.antMatcher("/**") .authorizeRequests() .antMatchers("/", "/login**", "/remoteCall") .permitAll() .anyRequest() .authenticated(); http.csrf().disable(); &#125;&#125; 注意，因为客户端凭据模式信任持有客户端凭证的客户端发出的任何请求，将远程调用资源服务器的请求 “/remoteCall” 允许访问。 配置文件 application.properties 中添加 security.oauth2.client.grant-type=client_credentials 6.2. 测试 7. 参考资源Simple Single Sign-On with Spring Security OAuth2 https://spring.io/guides/tutorials/spring-boot-oauth2/]]></content>
      <categories>
        <category>oauth2</category>
      </categories>
      <tags>
        <tag>oauth2</tag>
        <tag>spring-boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring-Security-Oauth2第一篇之授权认证]]></title>
    <url>%2Fpassages%2FSpring-Security-Oauth2%E7%AC%AC%E4%B8%80%E7%AF%87%E4%B9%8B%E6%8E%88%E6%9D%83%E8%AE%A4%E8%AF%81%2F</url>
    <content type="text"><![CDATA[Spring-Security-Oauth2第一篇@[toc] 1. Oauth 介绍OAuth 是一个关于授权（authorization）的开放网络标准，在全世界得到广泛应用，目前的版本是2.0版。 OAuth 是一个开放标准，允许用户让第三方应用访问该用户在某一网站上存储的私密的资源（如照片，视频，联系人列表），而不需要将用户名和密码提供给第三方应用。OAuth允许用户提供一个令牌，而不是用户名和密码来访问他们存放在特定服务提供者的数据。每一个令牌授权一个特定的网站在特定的时段内访问特定的资源。这样，OAuth让用户可以授权第三方网站访问他们存储在另外服务提供者的某些特定信息。更多OAuth2请参考理解OAuth 2.0 2. Spring Security Oauth2 的使用2.1. 使用MySQL存储 access_token 和 client 信息在学习过程中，很多示例中，所有的token信息都是保存在内存中的，这显然无法在生产环境中使用(进程结束后所有token丢失, 用户需要重新授权)，也不利于我们的学习，因此需要将这些信息进行持久化操作。 授权服务器中的数据存储到数据库中并不难 spring-security-oauth2 已经为我们设计好了一套Schema和对应的DAO对象。但在使用之前，我们需要先对相关的类有一定的了解。 2.2. 数据结构脚本spring-security-oauth2 为我们提供了 Schema： https://github.com/spring-projects/spring-security-oauth/blob/master/spring-security-oauth2/src/test/resources/schema.sql 注意: 框架所提供的数据脚本适用于 HSQL，语句中会有某些字段为 LONGVARBINARY 类型，它对应 MYSQL 的 BLOB 类型。 2.3. 相关的接口spring-security-oauth2 通过 DefaultTokenServices 类来完成 token 生成、过期等 OAuth2 标准规定的业务逻辑，而 DefaultTokenServices 又是通过 TokenStore 接口完成对生成数据的持久化。 对于 Token 信息，本篇文章使用 JdbcTokenStore，在生产环境中更喜爱使用 RedisTokenStore。 对于 Client 信息，本篇文章使用 JdbcClientDetailsService。 2.4. 服务类型OAuth2 在服务提供者上可分为两类： 授权认证服务：AuthenticationServer 123@Configuration@EnableAuthorizationServerpublic class AuthServerConfig extends AuthorizationServerConfigurerAdapter &#123;&#125; 资源获取服务：ResourceServer 123@Configuration@EnableResourceServerpublic class ResourceServerConfiguration extends ResourceServerConfigurerAdapter &#123;&#125; 注意：这两者有时候可能存在同一个应用程序中（即SOA架构）。在Spring OAuth中可以简便的将其分配到两个应用中（即微服务），而且可多个资源获取服务共享一个授权认证服务。 2.5. 项目结构和 maven 依赖前面浅尝辄止的讲述了一些原理，下面的内容是示例展示。 123456789101112131415161718192021222324252627282930313233&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- oauth2 核心依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security.oauth&lt;/groupId&gt; &lt;artifactId&gt;spring-security-oauth2&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 将token存储在redis中 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2.5.1. 配置授权认证服务123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100package com.fengxuechao.examples.sso.server.configuration;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.security.authentication.AuthenticationManager;import org.springframework.security.oauth2.config.annotation.configurers.ClientDetailsServiceConfigurer;import org.springframework.security.oauth2.config.annotation.web.configuration.AuthorizationServerConfigurerAdapter;import org.springframework.security.oauth2.config.annotation.web.configuration.EnableAuthorizationServer;import org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerEndpointsConfigurer;import org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerSecurityConfigurer;import org.springframework.security.oauth2.provider.client.JdbcClientDetailsService;import org.springframework.security.oauth2.provider.token.TokenStore;import org.springframework.security.oauth2.provider.token.store.JdbcTokenStore;import javax.sql.DataSource;/** * @author fengxuechao * @date 2019/3/26 */@Configuration@EnableAuthorizationServerpublic class AuthServerConfig extends AuthorizationServerConfigurerAdapter &#123; private static final String DEMO_RESOURCE_ID = "*"; @Autowired AuthenticationManager authenticationManager; @Autowired private DataSource dataSource; /** * 声明TokenStore实现 * * @return */ @Bean public TokenStore tokenStore() &#123; return new JdbcTokenStore(dataSource); &#125; /** * 声明 ClientDetails实现 * * @return */ @Bean public JdbcClientDetailsService clientDetailsService() &#123; return new JdbcClientDetailsService(dataSource); &#125; /** * 第三方用户客户端详情 * Grant Type代表当前授权的类型： * &lt;p&gt; * authorization_code：传统的授权码模式&lt;br&gt; * implicit：隐式授权模式&lt;br&gt; * password：资源所有者（即用户）密码模式&lt;br&gt; * client_credentials：客户端凭据（客户端ID以及Key）模式&lt;br&gt; * refresh_token：获取access token时附带的用于刷新新的token模式 * &lt;/p&gt; * * @param clients * @throws Exception */ @Override public void configure(ClientDetailsServiceConfigurer clients) throws Exception &#123; clients.jdbc(dataSource) .withClient("client_1") .secret("123456") .resourceIds(DEMO_RESOURCE_ID) .redirectUris("https://www.baidu.com", "http://localhost:8081/product/1") .accessTokenValiditySeconds(1200) .refreshTokenValiditySeconds(50000) .authorizedGrantTypes("client_credentials", "refresh_token", "password", "authorization_code") .scopes("all") .authorities("client").and().build(); &#125; @Override public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception &#123; // redis保存token // endpoints.tokenStore(new RedisTokenStore(redisConnectionFactory)) // JDBC 保存 token endpoints.tokenStore(new JdbcTokenStore(dataSource)); endpoints.setClientDetailsService(clientDetailsService()); endpoints.authenticationManager(authenticationManager); &#125; @Override public void configure(AuthorizationServerSecurityConfigurer oauthServer) throws Exception &#123; // 允许表单认证 oauthServer.allowFormAuthenticationForClients(); // 授权认证服务需要把 /oauth/check_toke 暴露出来，并且附带上权限访问。 oauthServer.checkTokenAccess("isAuthenticated()"); &#125;&#125; 2.5.2. 配置用户权限|拦截保护的请求1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.fengxuechao.examples.sso.server.configuration;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.core.annotation.Order;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;import org.springframework.security.core.userdetails.User;import org.springframework.security.core.userdetails.UserDetailsService;import org.springframework.security.provisioning.InMemoryUserDetailsManager;/** * @author fengxuechao * @date 2019/3/26 */@Order(2)@Configuration@EnableWebSecuritypublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; /** * 具体的用户权限控制实现类 * * @return */ @Bean @Override protected UserDetailsService userDetailsService() &#123; InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager(); manager.createUser(User.withUsername("user_1").password("123456").authorities("USER").build()); manager.createUser(User.withUsername("user_2").password("123456").authorities("USER").build()); return manager; &#125; /** * 用来配置拦截保护的请求 * * @param http * @throws Exception */ @Override protected void configure(HttpSecurity http) throws Exception &#123; http .csrf().disable() .requestMatchers().antMatchers("/oauth/**", "/login/**", "/logout/**") .and().authorizeRequests().antMatchers("/oauth/*").authenticated() .and().formLogin().permitAll(); &#125;&#125; 2.5.3. 配置资源获取服务1234567891011121314151617181920212223242526272829303132package com.fengxuechao.examples.sso.server.configuration;import org.springframework.context.annotation.Configuration;import org.springframework.core.annotation.Order;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.http.SessionCreationPolicy;import org.springframework.security.oauth2.config.annotation.web.configuration.EnableResourceServer;import org.springframework.security.oauth2.config.annotation.web.configuration.ResourceServerConfigurerAdapter;import org.springframework.security.oauth2.config.annotation.web.configurers.ResourceServerSecurityConfigurer;@Order(6)@Configuration@EnableResourceServerpublic class ResourceServerConfiguration extends ResourceServerConfigurerAdapter &#123; private static final String DEMO_RESOURCE_ID = "*"; @Override public void configure(ResourceServerSecurityConfigurer resources) &#123; resources.resourceId(DEMO_RESOURCE_ID).stateless(true); &#125; @Override public void configure(HttpSecurity http) throws Exception &#123; http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED) .and().requestMatchers().anyRequest() .and().anonymous() .and().authorizeRequests()// .antMatchers("/product/**").access("#oauth2.hasScope('select') and hasRole('ROLE_USER')") .antMatchers("/**").authenticated(); //配置访问权限控制，必须认证过后才可以访问 &#125;&#125; 注意：ResourceServerConfiguration 和 SecurityConfiguration上配置的顺序SecurityConfiguration 一定要在 ResourceServerConfiguration 之前，因为 spring 实现安全是通过添加过滤器(Filter)来实现的，基本的安全过滤应该在oauth过滤之前, 所以在 SecurityConfiguration 设置 @Order(2) , 在 ResourceServerConfiguration 上设置 @Order(6) 2.5.4. 受保护的资源12345678910111213141516171819202122232425262728293031323334package com.fengxuechao.examples.sso.server.web;import org.springframework.security.core.Authentication;import org.springframework.security.core.context.SecurityContextHolder;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RestController;import java.security.Principal;/** * @author fengxuechao * @date 2019/3/26 */@RestControllerpublic class AuthEndpoints &#123; @GetMapping("/product/&#123;id&#125;") public String getProduct(@PathVariable String id) &#123; Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); return "product id : " + id; &#125; @GetMapping("/order/&#123;id&#125;") public String getOrder(@PathVariable String id) &#123; Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); return "order id : " + id; &#125; @GetMapping("/user/me") public Principal user(Principal principal) &#123; return principal; &#125;&#125; 2.5.5. 测试 客户端凭据（客户端ID以及Key）模式 发送 POST 请求获取 access_token request1POST http://localhost:8081/oauth/token?grant_type=client_credentials&amp;scope=all&amp;client_id=client_1&amp;client_secret=123456 请求结果： 123456&#123; "access_token": "d3025813-fd1f-4ccb-9faa-495cad16deff", "token_type": "bearer", "expires_in": 1199, "scope": "all"&#125; 将请求结果中的 access_token 取出并作为请求受保护资源 api 的请求参数 request1GET http://localhost:8081/order/1?access_token=d3025813-fd1f-4ccb-9faa-495cad16deff 授权码模式 授权链接 1http://localhost:8081/oauth/authorize?response_type=code&amp;client_id=client_1&amp;scope=all&amp;redirect_uri=http://localhost:8081/product/1 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190327141038943.png) 登陆后，同意授权 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190327141100319.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xpdHRsZV9meGM=,size_16,color_FFFFFF,t_70) ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190327141113939.png) 将请求连接中的 `code` 作为请求令牌的请求参数 1POST http://localhost:8081/oauth/token?client_id=client_1&amp;grant_type=authorization_code&amp;redirect_uri=http://localhost:8081/product/1&amp;client_secret=123456&amp;code=7fTmqZ 请求结果： 1234567&#123; "access_token": "b485ed7c-3c92-43b0-97f2-0dc54da61d80", "token_type": "bearer", "refresh_token": "02b204ea-31f5-45c0-809e-ef2693117d31", "expires_in": 1199, "scope": "all"&#125; 取出 access_token 作为受保护的请求资源的令牌 request1GET http://localhost:8081/product/1?access_token=b485ed7c-3c92-43b0-97f2-0dc54da61d80 2.5.6. 如何分离授权服务和资源服务在上文 2.4. 服务类型 章节中，提过 在Spring OAuth中可以简便的将其分配到两个应用中（即微服务），而且可多个资源获取服务共享一个授权认证服务。 ResourceServerTokenServices 是组成授权服务的另一半。 若是资源服务器和授权服务在同一个应用，可以使用 DefaultTokenServices 若是分离的。ResourceServerTokenServices 必须知道令牌的如何解码。 ResourceServerTokenServices 解析令牌的方法： 使用 RemoteTokenServices，资源服务器通过HTTP请求来解码令牌。每次都请求授权服务器的端点 /oauth/check_toke，以此来解码令牌 若是访问量大，则通过http获取之后，换成令牌的结果 若是 jwt 令牌，需请求授权服务的 /oauth/token_key，来获取 key 进行解码 注意：授权认证服务需要把/oauth/check_toke暴露出来，并且附带上权限访问。 项目结构 独立资源服务器配置 12345678910111213141516171819202122232425262728293031323334353637package com.fengxuechao.examples.sso.res.configuration;import org.springframework.context.annotation.Configuration;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.http.SessionCreationPolicy;import org.springframework.security.oauth2.config.annotation.web.configuration.EnableResourceServer;import org.springframework.security.oauth2.config.annotation.web.configuration.ResourceServerConfigurerAdapter;import org.springframework.security.oauth2.config.annotation.web.configurers.ResourceServerSecurityConfigurer;@Configuration@EnableResourceServerpublic class ResourceServerConfig extends ResourceServerConfigurerAdapter &#123; private static final String DEMO_RESOURCE_ID = "*"; @Override public void configure(ResourceServerSecurityConfigurer resources) &#123; resources.resourceId(DEMO_RESOURCE_ID).stateless(true); &#125; @Override public void configure(HttpSecurity http) throws Exception &#123; http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED) .and().requestMatchers().anyRequest() .and().anonymous() .and().authorizeRequests().antMatchers("/**").authenticated(); &#125; /*@Primary @Bean public RemoteTokenServices tokenServices() &#123; RemoteTokenServices tokenServices = new RemoteTokenServices(); tokenServices.setCheckTokenEndpointUrl("http://localhost:8081/oauth/check_token"); tokenServices.setClientId("client_1"); tokenServices.setClientSecret("123456"); return tokenServices; &#125;*/&#125; 配置文件 application.properties 1234567server.port=8082security.oauth2.client.client-id=client_1security.oauth2.client.client-secret=123456# userInfoUri用户端点的URI，用于获取当前用户详细信息security.oauth2.resource.user-info-uri=http://localhost:8081/user/me# 解析令牌的地址security.oauth2.authorization.check-token-access=http://localhost:8001/oauth/check_token 受保护资源 1234567891011121314151617181920212223242526272829303132333435package com.fengxuechao.examples.sso.res;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.http.ResponseEntity;import org.springframework.security.core.context.SecurityContextHolder;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.HashMap;import java.util.Map;/** * @author fengxuechao * @date 2019/3/26 */@SpringBootApplication@RestControllerpublic class ClientApp &#123; public static void main(String[] args) &#123; SpringApplication.run(ClientApp.class, args); &#125; // 资源API @RequestMapping("/api/userinfo") public ResponseEntity&lt;Map&gt; getUserInfo() &#123; String user = (String) SecurityContextHolder.getContext().getAuthentication().getPrincipal(); String email = user + "@test.com"; Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put("name", user); map.put("email", email); return ResponseEntity.ok(map); &#125;&#125; 参考资源 https://projects.spring.io/spring-security-oauth/docs/oauth2.html https://juejin.im/post/5a3cbce05188252582279467#heading-6 http://www.spring4all.com/article/582]]></content>
      <categories>
        <category>oauth2</category>
      </categories>
      <tags>
        <tag>oauth2</tag>
        <tag>spring-boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring-boot配置文件的优先级]]></title>
    <url>%2Fpassages%2Fspring-boot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[SpringBoot配置文件的优先级项目结构 配置文件的优先级application.properties 和 application.yml 文件按照优先级从大到小顺序排列在以下四个位置： file:./config/ (当前项目路径config目录下); file:./ (当前项目路径下); classpath:/config/ (类路径config目录下); classpath:/ (类路径config下). 源代码展示： 1234567public class ConfigFileApplicationListener implements EnvironmentPostProcessor, SmartApplicationListener, Ordered &#123;// Note the order is from least to most specific (last one wins)private static final String DEFAULT_SEARCH_LOCATIONS = "classpath:/,classpath:/config/,file:./,file:./config/";// 省略其它代码&#125; 以端口配置为例 在resources/config目录下配置文件设置端口为8888; 在resources/目录下配置文件设置端口为8080; 在类路径config目录下配置文件设置端口为6666; 在类路径下配置文件设置端口为5555; 运行结果： 自定义配置文件的绑定 CustomizedFile 类 1234567891011121314/** * 自定义配置文件, 需要配合使用后@Configuration和@PropertySource("classpath:customized-file.properties")来指定 * @author fengxuechao */@Configuration@ConfigurationProperties(prefix = "customizedFile")@PropertySource("classpath:customized-file-$&#123;spring.profiles.active&#125;.properties")public class CustomizedFile &#123; private String name; private String author; private String path; private String description; // 省略 setter/getter&#125; 看到 `${spring.profiles.active}`，聪明的你一定知道这是 spring boot多环境自定义配置文件的实现方式。 生效的配置文件是 `${spring.profiles.active}` 所指定的配置文件，本文案例中生效的是 `customized-file-dev.properties`。 接下来继续创建配置文件验证 customized-file.properties 1234customizedFile.name=自定义配置文件名customizedFile.author=作者名customizedFile.path=路径地址customizedFile.description=看到这个就表明自定义配置文件成功了 customized-file-dev.properties 1customizedFile.description=DEV:看到这个就表明自定义配置文件成功了 运行结果： 结论：只有 customized-file-dev.properties 中配置的属性生效]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>spring-boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合学习之ArrayList]]></title>
    <url>%2Fpassages%2FJava%E9%9B%86%E5%90%88%E5%AD%A6%E4%B9%A0%E4%B9%8BArrayList%2F</url>
    <content type="text"><![CDATA[Java源码学习之ArrayList123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224package java.util;import java.util.function.Consumer;import java.util.function.Predicate;import java.util.function.UnaryOperator;public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123; private static final long serialVersionUID = 8683452581122892189L; /** * 默认容量 */ private static final int DEFAULT_CAPACITY = 10; /** * 空数组, new ArrayList(0)的时候默认数组构建一个空数组 */ private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; /** * 空数组, 调用无参构造函数的时候默认给一个空数组 */ private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; /** * 保存数据的数组 */ transient Object[] elementData; // non-private to simplify nested class access /** * ArrayList的实际元素数量 * * @serial */ private int size; /** * 给定一个初始容量来构造一个空数组 */ public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); &#125; &#125; /** * 无参数构造方法默认为空数组 */ public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; &#125; /** * 构造方法传入一个Collection， 则将Collection里面的值copy到arrayList */ public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125; &#125; /** * 调整当前实例的容量为实际数组的大小，用于最小化实例的内存空间。 * 可以解决平时新增、删除元素后elementData过大的问题。 */ public void trimToSize() &#123; modCount++; if (size &lt; elementData.length) &#123; elementData = (size == 0) ? EMPTY_ELEMENTDATA : Arrays.copyOf(elementData, size); &#125; &#125; /** * 确定动态扩容所需容量 */ private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity); &#125; private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // 超出了数组可容纳的长度，需要进行动态扩展 if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; /** * 1. 一些JVM可能存储Headerwords * 2. 避免一些机器内存溢出，减少出错几率 */ private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; /** * 动态扩容的核心方法。 * * @param minCapacity the desired minimum capacity */ private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; // 先对容量扩大1.5倍, 这里 oldCapacity &gt;&gt; 1 是二进制操作右移，相当于除以2, 我称之为期望容量 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); // minCapacity 我称之为最小容量 // 比较期望容量与最小容量 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; // 判断期望容量是否超过 Integer.MAX_VALUE - 8. 一般很少用到，那么多数据也不会用ArrayList来做容器了吧 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125; // 这辈子都不太有机会用到吧 private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; &#125; public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; &#125; /** * 1. 将指定元素的索引及后续元素的索引向右移动(索引+1) * 2. 在指定的索引插入元素 */ public void add(int index, E element) &#123; rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; &#125; /** * 1. 将指定索引及后续元素的索引向左移动 * 2. 数组元素实际数量 - 1 */ public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue; &#125; // 循环比较元素，获取要移除元素的索引，然后将该索引及后续元素的索引向左移动 public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false; &#125; private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work &#125; /** * 循环设置所有元素值为null, 加快垃圾回收 */ public void clear() &#123; modCount++; // clear to let GC do its work for (int i = 0; i &lt; size; i++) elementData[i] = null; size = 0; &#125; // 只要将前面的源码读懂，后面的都是类似的&#125; 从上面的源码分析中就可以看出 ArrayList 的本质就是数组。ArrayList 的一些特性都来源于数组：有序、元素可重复、插入慢、 索引快。而所谓的动态扩容不就是复制原数组到扩容后的数组。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发学习记录之Lock锁]]></title>
    <url>%2Fpassages%2FJava%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B9%8BLock%E9%94%81%2F</url>
    <content type="text"><![CDATA[锁是用于通过多个线程控制对共享资源的访问的工具。一般来说，锁提供对共享资源的独占访问：一次只能有一个线程可以获取锁，并且对共享资源的所有访问都要求首先获取锁。 但是，一些锁可能允许并发访问共享资源，如ReadWriteLock的读写锁。 Java 并发学习记录之 Lock 锁@[toc] Lock 接口锁是用于通过多个线程控制对共享资源的访问的工具。一般来说，锁提供对共享资源的独占访问：一次只能有一个线程可以获取锁，并且对共享资源的所有访问都要求首先获取锁。 但是，一些锁可能允许并发访问共享资源，如ReadWriteLock的读写锁。 在Lock接口出现之前，Java程序是靠synchronized关键字实现锁功能的。JDK1.5之后并发包中新增了Lock接口以及相关实现类来实现锁功能。虽然缺少了隐式获取释放锁的便捷性，但是却拥有了锁获取与释放的可操作性、可中断的获取锁以及超时获取锁等多种 synchronized 关键字所不具备的同步特性。 简单用法1234567Lock lock=new ReentrantLock();lock.lock();try&#123; &#125; finally &#123; lock.unlock();&#125; 因为 Lock 是接口所以使用时要结合它的实现类，另外在 finall 语句块中释放锁的目的是保证获取到锁之后，最终能够被释放。同时注意最好不要把获取锁的过程写在 try 语句块中，因为如果在获取锁时发生了异常，异常抛出的同时也会导致锁无故释放。 Lock接口提供的synchronized关键字不具备的主要特性： 特性 描述 尝试非阻塞地获取锁 当前线程尝试获取锁，如果这一时刻锁没有被其他线程获取到，则成功获取并持有锁 能被中断地获取锁 获取到锁的线程能够响应中断，当获取到锁的线程被中断时，中断异常将会被抛出，同时锁会被释放 超时获取锁 在指定的截止时间之前获取锁， 超过截止时间后仍旧无法获取则返回 Lock接口基本的方法： 方法名称 描述 void lock() 获得锁。如果锁不可用，则当前线程将被禁用以进行线程调度，并处于休眠状态，直到获取锁。 void lockInterruptibly() 获取锁，如果可用并立即返回。如果锁不可用，那么当前线程将被禁用以进行线程调度，并且处于休眠状态，和lock()方法不同的是在锁的获取中可以中断当前线程（相应中断）。 Condition newCondition() 获取等待通知组件，该组件和当前的锁绑定，当前线程只有获得了锁，才能调用该组件的wait()方法，而调用后，当前线程将释放锁。 boolean tryLock() 只有在调用时才可以获得锁。如果可用，则获取锁定，并立即返回值为true；如果锁不可用，则此方法将立即返回值为false 。 boolean tryLock(long time, TimeUnit unit) 超时获取锁，当前线程在一下三种情况下会返回：1. 当前线程在超时时间内获得了锁；2.当前线程在超时时间内被中断；3.超时时间结束，返回false. void unlock() 释放锁。 对同步器 AbstractQueuedSynchronizer 的分析 Java并发学习记录之同步器AbstractQueuedSynchronizer Lock 实现类：ReentrantLock重入锁 ReentrantLock，顾名思义，就是支持重进入的锁，它表示该锁能够支持一个线程对资源的重复加锁。除此之外，还支持获取锁时的公平和非公平锁选择。 加锁2次释放2次123456789101112131415161718192021222324252627282930313233343536373839package com.littlefxc.examples.base.thread.lock;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * @author fengxuechao * @date 2019/2/28 **/public class ReentrantLockR implements Runnable &#123; Lock lock = new ReentrantLock(); @Override public void run() &#123; lock.lock(); System.out.println("线程 " + Thread.currentThread().getId() + " 加锁"); try &#123; lock.lock();// 重进入验证 for (int i = 0; i &lt; 5; i++) &#123; System.out.println("线程 " + Thread.currentThread().getId() + " 循环计数 = " + i); &#125; &#125; finally &#123; lock.unlock();// 锁的释放 System.out.println("线程 " + Thread.currentThread().getId() + " 解锁"); lock.unlock(); &#125; &#125; public static void main(String[] args) &#123; ReentrantLockR lockR = new ReentrantLockR(); Thread t1 = new Thread(lockR); Thread t2 = new Thread(lockR); Thread t3 = new Thread(lockR); t1.start(); t2.start(); t3.start(); &#125;&#125; 运行结果： 可以看到，运行结果是只有当线程运行完毕后才会释放锁，其它线程才能获得锁-&gt;执行业务代码-&gt;释放锁。其他线程的执行顺序是不确定的（为了这个图运行了很多遍）。 仔细观察代码，可以我加了两遍锁，同时也释放了两遍锁。 如果，加锁两次释放一次：123456789101112131415@Overridepublic void run() &#123; lock.lock(); lock.lock();// 重进入验证 System.out.println("线程 " + Thread.currentThread().getId() + " 加锁"); try &#123; for (int i = 0; i &lt; 5; i++) &#123; System.out.println("线程 " + Thread.currentThread().getId() + " 循环计数 = " + i); &#125; &#125; finally &#123;// lock.unlock();// 锁的释放 System.out.println("线程 " + Thread.currentThread().getId() + " 解锁"); lock.unlock(); &#125;&#125; 运行结果： 又如果，加锁1次却释放锁两次，就会抛异常：123456789101112131415@Overridepublic void run() &#123; lock.lock(); //lock.lock();// 重进入验证 System.out.println("线程 " + Thread.currentThread().getId() + " 加锁"); try &#123; for (int i = 0; i &lt; 5; i++) &#123; System.out.println("线程 " + Thread.currentThread().getId() + " 循环计数 = " + i); &#125; &#125; finally &#123; lock.unlock();// 锁的释放 System.out.println("线程 " + Thread.currentThread().getId() + " 解锁"); lock.unlock(); &#125;&#125; 运行结果： 公平与非公平获取锁的区别如果一个锁是公平的，那么锁的获取顺序就应该符合请求的绝对时间顺序，也就是 FIFO。 ReentrantLock 的 非公平锁的获取（源码）： 123456789101112131415161718final boolean nonfairTryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; if (compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) // overflow throw new Error("Maximum lock count exceeded"); setState(nextc); return true; &#125; return false;&#125; ReentrantLock 的 公平锁的获取（源码）： 1234567891011121314151617181920212223/** * Fair version of tryAcquire. Don't grant access unless * recursive call or no waiters or is first. */protected final boolean tryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) throw new Error("Maximum lock count exceeded"); setState(nextc); return true; &#125; return false;&#125; 对比两个方法的不同点只是获取公平锁判断条件多了 hasQueuedPredecessors() 方法，即加入了同步队列中当前是否有前驱结点的判断，如果该方法返回 true，则表示当前线程需要等待前驱线程获取锁并释放锁之后才能继续获取锁。 当你看到 ReentrantLock 的构造函数，为什么非公平锁会被设定为默认的实现呢？ 要知道一个刚释放锁的线程再次获取锁的几率会非常大，使得其他线程只能在同步队列中等待，从而让非公平锁使线程“饥饿”， 这是因为虽然公平锁保证了锁的获取按照 FIFO 原则，但代价是进行了大量的线程切换。非公平锁虽然可能会造成线程“饥饿”，但极少的线程切换，保证了更大的吞吐量。 读写锁：ReadWriteLock之前学习过的如 synchronized 关键字、ReentrantLock 重入锁都是排他锁，这些锁在同一时刻只允许一个线程进行访问。读写锁不同，在同一时刻允许多个读线程访问，但是在写线程访问时，所有的读线程和其它线程均会被阻塞。读写锁维护了一对锁（读锁-&gt;共享锁和写锁-&gt;排他锁），通过分离读锁和写锁，使得并发性相比一般的排他锁有了很大的提升。 假设有这样一种情况，在程序中定义了一个共享的缓存数据结构，它在大部分的时间读服务（如查询）使用的很多，而写的服务很少，但每次写完后数据对读的服务可见。（读：很多；写：很少） 在这种情况下，你很可能会使用等待/通知机制来实现从而保证数据不会出现脏读。 改用读写锁来实现的话，只需在读操作时获取读锁，写操作时获取写锁。当前线程进行写操作时，其它的读写线程阻塞，当档期那线程的写锁释放后，其它线程继续执行，而如果其它线程都是读线程，那么都允许执行。 也就是说，在读大于写的情况下，使用读写锁具有比其他排他锁更好的并发性和吞吐量。 ReadWriteLock 的实现类 ReentrantReadWriteLock 的特性 特性 说明 公平性选择 支持非公平（默认）和公平的锁获取方式，吞吐量上来看还是非公平优于公平 重进入 该锁支持重进入，以读写线程为例：读线程在获取了读锁之后，能够再次获取读锁。而写线程在获取了写锁之后能够再次获取写锁也能够同时获取读锁 锁降级 遵循获取写锁、获取读锁再释放写锁的次序，写锁能够降级称为读锁 读写锁 ReentrantReadWriteLock 的使用测试12345678910111213141516171819202122232425262728293031323334353637383940package com.littlefxc.examples.base.thread.lock;import java.util.concurrent.locks.ReentrantReadWriteLock;/** * @author fengxuechao * @date 2019/3/1 **/public class ReentrantReadWriteLockTest &#123; private ReentrantReadWriteLock lock = new ReentrantReadWriteLock(); public void read() &#123; try &#123; try &#123; lock.readLock().lock(); System.out.println("线程 " + Thread.currentThread().getId() + " 获得读锁 " + System.currentTimeMillis()); Thread.sleep(10000); &#125; finally &#123; lock.readLock().unlock(); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; public void write() &#123; try &#123; try &#123; lock.writeLock().lock(); System.out.println("线程 " + Thread.currentThread().getId() + " 获得写锁 " + System.currentTimeMillis()); Thread.sleep(10000); &#125; finally &#123; lock.writeLock().unlock(); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 上述代码中，read() 方法中是关于读锁的操作， write() 方法中是关于写锁的操作。为了加强效果，分别让两个操作都睡眠 10s。 接下来将使用这两个方法进行组合从而进行三方面的测试：测试多个读锁间的不互斥、测试读锁与写锁互斥、测试写锁与写锁互斥。 测试多个读锁间的不互斥1234567public static void main(String[] args) &#123; ReentrantReadWriteLockTest rwlSample = new ReentrantReadWriteLockTest(); Thread t1 = new Thread(() -&gt; rwlSample.read()); Thread t2 = new Thread(() -&gt; rwlSample.read()); t1.start(); t2.start();&#125; 运行后，发现两个线程几乎同时获得读锁。 测试读锁与写锁互斥1234567public static void main(String[] args) &#123; ReentrantReadWriteLockTest rwlSample = new ReentrantReadWriteLockTest(); Thread t1 = new Thread(() -&gt; rwlSample.read()); Thread t2 = new Thread(() -&gt; rwlSample.write()); t1.start(); t2.start();&#125; 运行后，发现两个线程互斥。 测试写锁与写锁互斥1234567public static void main(String[] args) &#123; ReentrantReadWriteLockTest rwlSample = new ReentrantReadWriteLockTest(); Thread t1 = new Thread(() -&gt; rwlSample.write()); Thread t2 = new Thread(() -&gt; rwlSample.write()); t1.start(); t2.start();&#125; 运行后，发现两个线程互斥。 对读写锁的分析 Java并发学习记录之读写锁分析 Condition 接口synchronized 关键字与 wait() 和 notify/notifyAll() 方法相结合可以实现等待/通知机制，Lock 接口同样定义了等待/通知两种类型的方法，和前者一样，当前线程在调用这些方法前，需要提前获取到 Condition 对象关联的锁。Condition 对象是由 Lock 接口实现类创建出来的Condition condition = lock.newCondition();。 在使用 notify/notifyAll()方法进行通知时，被通知的线程是有JVM选择的，使用 Lock 类结合 Condition 实例可以实现“选择性通知”，这个功能非常重要，而且是 Condition 接口默认提供的。 但是 synchronized 关键字就相当于整个 Lock 对象中只有一个 Condition 实例，所有的线程都注册在它一个身上。如果执行 notifyAll() 方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而 Condition 实例的 signalAll() 方法只会唤醒注册在该 Condition 实例中的所有等待线程。 Condition 定义的（部分）方法介绍： 方法名称 说明 void await() throws InterruptedException 当前线程进入等待状态直到被通知或中断，当前线程将进入运行状态且从 await() 方法返回的情况，包括： 其它线程调用该 Condition 的 signal() 或 signalAll() 方法，而当前线程被选中唤醒其它线程（调用 interrupt() 方法）中断当前线程如果当前等待线程从 await() 方法返回，那么表明该线程已经获取了 Condition 对象所对应的锁 void awaitUninterruptibly() 当前线程进入等待状态直到被通知，对中断不敏感 long awaitNanos(long nanosTimeout) throws InterruptedException 当前线程进入等待状态直到被通知、中断或者到某个时间。返回值表示剩余时间，如果返回值是 0 或者负数，就表示超时 long awaitNanos(long nanosTimeout) throws InterruptedException 当前线程进入等待状态直到被通知、中断或者到某个时间。如果没有到指定时间就被通知返回 true，否则返回 false boolean awaitUntil(Date deadline) throws InterruptedException 遵循获取写锁、获取读锁再释放写锁的次序，写锁能够降级称为读锁 void signal() 唤醒一个等待在 Condition 实例上的线程 void signalAll() 唤醒所有等待在 Condition 实例上的线程 Condition 使用示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.littlefxc.examples.base.thread.lock;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * @author fengxuechao * @date 2019-03-05 */public class ConditionSample &#123; Lock lock = new ReentrantLock(); Condition condition = lock.newCondition(); public void conditionWait() &#123; lock.lock(); try &#123; System.out.println("线程 " + Thread.currentThread().getId() + " 释放锁并开始等待"); long l = System.currentTimeMillis(); condition.await(); long time = System.currentTimeMillis() - l; System.out.println("线程 " + Thread.currentThread().getId() + " 获得锁并结束等待, 等待时间是 " + time + "ms"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; public void conditionSignal() &#123; lock.lock(); try &#123; System.out.println("线程 " + Thread.currentThread().getId() + " 开始释放锁并通知线程等待队列"); condition.signal(); Thread.sleep(2000); System.out.println("线程 " + Thread.currentThread().getId() + " 释放锁并通知线程等待队列"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; public static void main(String[] args) &#123; ConditionSample sample = new ConditionSample(); Thread t1 = new Thread(() -&gt; sample.conditionWait()); Thread t2 = new Thread(() -&gt; sample.conditionSignal()); t1.start(); t2.start(); &#125;&#125; 运行结果： 在使用 wait/notify 实现等待通知机制的时候我们知道必须执行完 notify() 方法所在的 synchronized 代码块后才释放锁。在这里也一样，必须执行完 signal 所在的 try 语句块之后才释放锁，condition.await() 后的语句才能被执行。 参考：《Java并发编程的艺术》《Java并发编程实战》]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发学习记录之ThreadLocal]]></title>
    <url>%2Fpassages%2FJava%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B9%8BThreadLocal%2F</url>
    <content type="text"><![CDATA[Java并发学习记录之ThreadLocalJDK 版本：1.8 我们需要关注的，自然是 ThreadLocal 的 set() 方法和 get() 方法。 ThreadLocal 的 set() 方法：12345678910111213141516public class ThreadLocal&lt;T&gt; &#123; public void set(T value) &#123; // 获取当前线程对象 Thread t = Thread.currentThread(); // 获得当前线程的 ThreadLocalMap ThreadLocalMap map = getMap(t); // 将值放入 ThreadLocalMap 中 if (map != null) map.set(this, value); else createMap(t, value); &#125; // ...&#125; 在 set 时，首先获得当前线程对象，然后通过 getMap() 拿到线程的 ThreadLocalMap，并将值放入 ThreadLocalMap 中。 那么这个 ThreadLocalMap 和 Thread 有什么关系？ 可以理解为一个 Map (虽然不是，但可以简单地理解为 HashMap)，但是它是定义在 Thread 内部的成员。 123456public class Thread implements Runnable &#123; /* 与此线程相关的 ThreadLocal 值。这个 Map 由 ThreadLocal 类维护。 */ ThreadLocal.ThreadLocalMap threadLocals = null; // ...&#125; 而设置到 ThreadLocal 中的值，就是写入 threadLocals 这个 Map。其中 key 为 ThreadLocal 当前对象，value 就是我们需要的值。而 threads 本身就保存了自己所在线程的所有 “局部变量”，也就是一个 ThreadLocal 变量的集合。 而 get() 方法也是先取得当前线程的 ThreadLocalMap 对象。然后，通过将自己作为 key 取得内部的实际数据。 同时也可以看到在 Thread 的 exit() 方法中， Thread 类会进行一些清理工作，注意下述代码： 12345678910111213141516171819public class Thread implements Runnable &#123; /** * 系统调用此方法是为了让线程在实际退出之前有机会进行清理。 */ private void exit() &#123; if (group != null) &#123; group.threadTerminated(this); group = null; &#125; /* 侵略性地清除所有引用字段:参见bug 4006245 */ target = null; /* 加快这些资源的释放 */ threadLocals = null; inheritableThreadLocals = null; inheritedAccessControlContext = null; blocker = null; uncaughtExceptionHandler = null; &#125;&#125; 因此如果我们使用线程池，那就意味着线程未必会退出。如果这样，将一些对象设置到 ThreadLocal 中，可能会使系统出现内存泄漏（JVM无法回收你不再使用的对象）的可能。 但又要及时回收对象，就可以使用 ThreadLocal.remove()，告诉JVM，回收对象，防止内存泄漏。 那么，ThreadLocalMap 是什么鬼？ 首先，通过前面的 ThreadLocal 的核心的 set() 方法分析，ThreadLocal 的 set 方法是通过代理给它的内部类ThreadLocalMap实现的。于是对于 ThreadLocal 的分析就转换为对内部类 ThreadLocalMap 的分析。 对 ThreadLocalMap 的 set() 方法和相关属性/方法的分析：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356/*** ThreadLocalMap是一个定制的哈希映射，只适合维护线程本地值。* 在ThreadLocal类之外不导出任何操作。类是包私有的，允许在类线程中声明字段。* 为了帮助处理非常大且长期存在的使用，哈希表项对键使用弱引用。* 但是，由于没有使用引用队列，因此只有在表开始耗尽空间时才保证删除过时的条目。*/static class ThreadLocalMap &#123; /** * 该类继承了WeakReference是方便垃圾回收，在底层map扩容之前进行entry的回收， * 减少扩容的概率,提高性能 */ static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125; &#125; /** * 初始容量 */ private static final int INITIAL_CAPACITY = 16; /** * 底层数组 */ private Entry[] table; /** * map中entry的个数 */ private int size = 0; /** * 阈值，超过这个阈值之后就需要进行扩容 */ private int threshold; // Default to 0 /** * 阈值是底层数组长度的2/3 */ private void setThreshold(int len) &#123; threshold = len * 2 / 3; &#125; /** * 计算下一个索引，hash算法定位失败的时候（也就是该索引位置存在元素） */ private static int nextIndex(int i, int len) &#123; return ((i + 1 &lt; len) ? i + 1 : 0); &#125; /** * 上一个位置索引，hash算法定位失败的时候（也就是该索引位置存在元素） */ private static int prevIndex(int i, int len) &#123; return ((i - 1 &gt;= 0) ? i - 1 : len - 1); &#125; /** * 根据 key 和 value 构建 ThreadLocalMap */ ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123; //初始化table table = new Entry[INITIAL_CAPACITY]; //计算索引 // &amp; (INITIAL_CAPACITY - 1) 这是取模的一种方式，对于2的幂作为模数取模，用此代替%(2^n) // firstKey.threadLocalHashCode 其主要目的就是为了让哈希码能均匀的分布在2的n次方的数组里, 也就是Entry[] table中 int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1); //设置值 table[i] = new Entry(firstKey, firstValue); size = 1; //设置阈值 setThreshold(INITIAL_CAPACITY); &#125; /** * 根据父容器构造ThreadLocalMap * * @param parentMap the map associated with parent thread. */ private ThreadLocalMap(ThreadLocalMap parentMap) &#123; Entry[] parentTable = parentMap.table; int len = parentTable.length; setThreshold(len); table = new Entry[len]; //复制遍历 for (int j = 0; j &lt; len; j++) &#123; Entry e = parentTable[j]; if (e != null) &#123; @SuppressWarnings("unchecked") ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get(); if (key != null) &#123; Object value = key.childValue(e.value); Entry c = new Entry(key, value); //该句相当于 hashcode % len但是&amp;运算更加高效 int h = key.threadLocalHashCode &amp; (len - 1); //hash算法定位失败，找下一个索引 while (table[h] != null) h = nextIndex(h, len); table[h] = c; size++; &#125; &#125; &#125; &#125; /** * ThreadLocalMap使用线性探测法来解决哈希冲突，线性探测法的地址增量di = 1, 2, … , m-1， * 其中，i为探测次数。该方法一次探测下一个地址，直到有空的地址后插入，若整个空间都找不到空余的地址，则产生溢出。 * 假设当前table长度为16，也就是说如果计算出来key的hash值为14，如果table[14]上已经有值，并且其key与当前key不一致， * 那么就发生了hash冲突，这个时候将14加1得到15，取table[15]进行判断， * 这个时候如果还是冲突会回到0，取table[0],以此类推，直到可以插入。 * */ private void set(ThreadLocal&lt;?&gt; key, Object value) &#123; Entry[] tab = table; int len = tab.length; //计算索引。 int i = key.threadLocalHashCode &amp; (len-1); // 根据获取到的索引进行循环，如果当前索引上的table[i]不为空，在没有return的情况下， // 就使用nextIndex()获取下一个（方法注释上提到到线性探测法）。 for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; ThreadLocal&lt;?&gt; k = e.get(); //table[i]上key不为空，并且和当前key相同，更新value if (k == key) &#123; e.value = value; return; &#125; //table[i]上的key为空，说明被回收了（上面的弱引用中提到过）。 //这个时候说明改table[i]可以重新使用，用新的key-value将其替换,并删除其他无效的entry if (k == null) &#123; replaceStaleEntry(key, value, i); return; &#125; &#125; //找到为空的插入位置，插入值，在为空的位置插入需要对size进行加1操作 tab[i] = new Entry(key, value); int sz = ++size; /** * cleanSomeSlots用于清除那些e.get()==null，也就是table[index] != null &amp;&amp; table[index].get()==null * 之前提到过，这种数据key关联的对象已经被回收，所以这个Entry(table[index])可以被置null。 * 如果没有清除任何entry,并且当前使用量达到了负载因子所定义(长度的2/3)，那么进行rehash() */ if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) rehash(); &#125; /** * 替换无效entry */ private void replaceStaleEntry(ThreadLocal&lt;?&gt; key, Object value, int staleSlot) &#123; Entry[] tab = table; int len = tab.length; Entry e; /** * 根据传入的无效entry的位置（staleSlot）,向前扫描 * 一段连续的entry(这里的连续是指一段相邻的entry并且table[i] != null), * 直到找到一个无效entry，或者扫描完也没找到 */ int slotToExpunge = staleSlot;//之后用于清理的起点 for (int i = prevIndex(staleSlot, len); (e = tab[i]) != null; i = prevIndex(i, len)) if (e.get() == null) slotToExpunge = i; // 向后扫描一段连续的entry for (int i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) &#123; ThreadLocal&lt;?&gt; k = e.get(); // 如果找到了key，将其与传入的无效entry替换，也就是与table[staleSlot]进行替换 if (k == key) &#123; e.value = value; tab[i] = tab[staleSlot]; tab[staleSlot] = e; //如果向前查找没有找到无效entry，则更新slotToExpunge为当前值i if (slotToExpunge == staleSlot) slotToExpunge = i; cleanSomeSlots(expungeStaleEntry(slotToExpunge), len); return; &#125; // 如果向前查找没有找到无效entry，并且当前向后扫描的entry无效，则更新slotToExpunge为当前值i if (k == null &amp;&amp; slotToExpunge == staleSlot) slotToExpunge = i; &#125; // 如果没有找到key,也就是说key之前不存在table中，就直接最开始的无效entry——tab[staleSlot]上直接新增即可 tab[staleSlot].value = null; tab[staleSlot] = new Entry(key, value); // slotToExpunge != staleSlot,说明存在其他的无效entry需要进行清理。 if (slotToExpunge != staleSlot) cleanSomeSlots(expungeStaleEntry(slotToExpunge), len); &#125; /** * 连续段清除 * 根据传入的staleSlot,清理对应的无效entry——table[staleSlot], * 并且根据当前传入的staleSlot,向后扫描一段连续的entry(这里的连续是指一段相邻的entry并且table[i] != null), * 对可能存在hash冲突的entry进行rehash，并且清理遇到的无效entry. * * @param staleSlot key为null,需要无效entry所在的table中的索引 * @return 返回下一个为空的solt的索引。 */ private int expungeStaleEntry(int staleSlot) &#123; Entry[] tab = table; int len = tab.length; // 清理无效entry，置空 tab[staleSlot].value = null; tab[staleSlot] = null; //size减1，置空后table的被使用量减1 size--; // Rehash until we encounter null Entry e; int i; // 从staleSlot开始向后扫描一段连续的entry for (i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) &#123; ThreadLocal&lt;?&gt; k = e.get(); //如果遇到key为null,表示无效entry，进行清理. if (k == null) &#123; e.value = null; tab[i] = null; size--; &#125; else &#123; //如果key不为null,计算索引 int h = k.threadLocalHashCode &amp; (len - 1); /** * 计算出来的索引——h，与其现在所在位置的索引——i不一致，置空当前的table[i] * 从h开始向后线性探测到第一个空的slot，把当前的entry挪过去。 */ if (h != i) &#123; tab[i] = null; // Unlike Knuth 6.4 Algorithm R, we must scan until // null because multiple entries could have been stale. while (tab[h] != null) h = nextIndex(h, len); tab[h] = e; &#125; &#125; &#125; //下一个为空的solt的索引。 return i; &#125; /** * 启发式的扫描清除，扫描次数由传入的参数n决定 * * @param i 从i向后开始扫描（不包括i，因为索引为i的Slot肯定为null） * * @param n 控制扫描次数，正常情况下为 log2(n) ， * 如果找到了无效entry，会将n重置为table的长度len,进行段清除。 * * map.set()点用的时候传入的是元素个数，replaceStaleEntry()调用的时候传入的是table的长度len * * @return true if any stale entries have been removed. */ private boolean cleanSomeSlots(int i, int n) &#123; boolean removed = false; Entry[] tab = table; int len = tab.length; do &#123; i = nextIndex(i, len); Entry e = tab[i]; if (e != null &amp;&amp; e.get() == null) &#123; n = len; removed = true; i = expungeStaleEntry(i); &#125; &#125; while ( (n &gt;&gt;&gt;= 1) != 0); return removed; &#125; /** * Re-pack and/or re-size the table. First scan the entire * table removing stale entries. If this doesn't sufficiently * shrink the size of the table, double the table size. */ private void rehash() &#123; //全清理 expungeStaleEntries(); // threshold = 2/3 * len，所以threshold - threshold / 4 = 1en/2 // 这里主要是因为上面做了一次全清理所以size减小，需要进行判断。 // 判断的时候把阈值调低了。 if (size &gt;= threshold - threshold / 4) resize(); &#125; /** * 扩容，扩大为原来的2倍（这样保证了长度为2的冥） */ private void resize() &#123; Entry[] oldTab = table; int oldLen = oldTab.length; int newLen = oldLen * 2; Entry[] newTab = new Entry[newLen]; int count = 0; for (int j = 0; j &lt; oldLen; ++j) &#123; Entry e = oldTab[j]; if (e != null) &#123; ThreadLocal&lt;?&gt; k = e.get(); //虽然做过一次清理，但在扩容的时候可能会又存在key==null的情况。 if (k == null) &#123; e.value = null; // Help the GC &#125; else &#123; //同样适用线性探测来设置值。 int h = k.threadLocalHashCode &amp; (newLen - 1); while (newTab[h] != null) h = nextIndex(h, newLen); newTab[h] = e; count++; &#125; &#125; &#125; //设置新的阈值 setThreshold(newLen); size = count; table = newTab; &#125; /** * 全清理，清理所有无效entry */ private void expungeStaleEntries() &#123; Entry[] tab = table; int len = tab.length; for (int j = 0; j &lt; len; j++) &#123; Entry e = tab[j]; if (e != null &amp;&amp; e.get() == null) //使用连续段清理 expungeStaleEntry(j); &#125; &#125;&#125; 从上面的分析，从 ThreadLocal 的 set() 着手分析再深入到 ThreadLocalMap 的 set() 方法。 同样的对于 ThreadLocalMap 中的 getEntry() 也从 ThreadLocal 的 get() 方法入手。 ThreadLocal 中的 get()1234567891011121314151617181920212223242526272829303132333435public T get() &#123; //同set方法类似获取对应线程中的ThreadLocalMap实例 Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings("unchecked") T result = (T)e.value; return result; &#125; &#125; //为空返回初始化值 return setInitialValue();&#125;/** * 初始化设值的方法，可以被子类覆盖。 */protected T initialValue() &#123; return null;&#125;private T setInitialValue() &#123; //获取初始化值，默认为null(如果没有子类进行覆盖) T value = initialValue(); Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); //不为空不用再初始化，直接调用set操作设值 if (map != null) map.set(this, value); else //第一次初始化，createMap在上面介绍set()的时候有介绍过。 createMap(t, value); return value;&#125; ThreadLocalMap 中的 getEntry()12345678910111213141516171819202122232425262728293031private ThreadLocal.ThreadLocalMap.Entry getEntry(ThreadLocal&lt;?&gt; key) &#123; //根据key计算索引，获取entry int i = key.threadLocalHashCode &amp; (table.length - 1); ThreadLocal.ThreadLocalMap.Entry e = table[i]; if (e != null &amp;&amp; e.get() == key) return e; else return getEntryAfterMiss(key, i, e);&#125;/** * 通过直接计算出来的key找不到对于的value的时候适用这个方法. */private ThreadLocal.ThreadLocalMap.Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, ThreadLocal.ThreadLocalMap.Entry e) &#123; ThreadLocal.ThreadLocalMap.Entry[] tab = table; int len = tab.length; while (e != null) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == key) return e; if (k == null) //清除无效的entry expungeStaleEntry(i); else //基于线性探测法向后扫描 i = nextIndex(i, len); e = tab[i]; &#125; return null;&#125; ThreadLocalMap中的remove()同样的 remove() ，就是找到对应的table[],调用 weakrefrence 的 clear()清除引用，然后再调用 expungeStaleEntry() 进行清除。 123456789101112131415161718private void remove(ThreadLocal&lt;?&gt; key) &#123; ThreadLocal.ThreadLocalMap.Entry[] tab = table; int len = tab.length; //计算索引 int i = key.threadLocalHashCode &amp; (len-1); //进行线性探测，查找正确的key for (ThreadLocal.ThreadLocalMap.Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; if (e.get() == key) &#123; //调用weakrefrence的clear()清除引用 e.clear(); //连续段清除 expungeStaleEntry(i); return; &#125; &#125;&#125; 参考引用哈希表——线性探测法、链地址法、查找成功、查找不成功的平均长度]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发学习记录之volatile]]></title>
    <url>%2Fpassages%2FJava%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B9%8Bvolatile%2F</url>
    <content type="text"><![CDATA[Java并发学习记录之volatile首先来个感性认识： volatile 关键字仅能实现对原始变量(如boolen、short、int、long等)赋值操作的原子性，但是复合操作如 i++则不保证。 volatile 和 synchronized 的区别volatile 关键字解决的是内存可见性的问题，会使得所有对volatile变量的读写都会直接刷到主存，即保证了变量的可见性。这样就能满足一些对变量可见性有要求而对读取顺序没有要求的需求。 synchronized 关键字解决的是执行控制的问题，它会阻止其它线程获取当前对象的监控锁，这样就使得当前对象中被synchronized关键字保护的代码块无法被其它线程访问，也就无法并发执行。更重要的是，synchronized 还会创建一个内存屏障，内存屏障指令保证了所有CPU操作结果都会直接刷到主存中，从而保证了操作的内存可见性，同时也使得先获得这个锁的线程的所有操作，都 happens-before 于随后获得这个锁的线程的操作。 区别点 volatile 本质是在告诉 JVM 当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取；synchronized 则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。 volatile 仅能使用在变量级别；synchronized 则可以使用在变量、方法、和类级别的。 volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性。 volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。 volatile 标记的变量不会被编译器优化；synchronized 标记的变量可以被编译器优化 volatile 关键字用于解决变量在多个线程之间的可见性，而 synchronized 关键字解决的是多个线程之间访问资源的同步性。 volatile 的可见性下面是加了 volatile 关键字 和不加 volatile 关键字的区别，作图演示： 区别在于，volatile 修饰的成员变量在每次被线程访问时，都强迫从主存（共享内存）中重读该成员变量的值。而且，当成员变量发生变化时，强迫线程将变化值回写到主内存（共享内存）。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值，这样也就保证了同步数据的可见性。 验证 volatile 的可见性12345678910111213141516171819202122232425262728package com.littlefxc.examples.base.thread;/** * @author fengxuechao * @date 2019/2/21 **/public class VolatileSample extends Thread &#123; private int number; static boolean ready = true; @Override public void run() &#123; while (ready) &#123; number++; &#125; System.out.println(ready); System.out.println(number); &#125; public static void main(String[] args) throws InterruptedException &#123; Thread t1 = new VolatileSample(); t1.start(); Thread.sleep(1000); ready = false; &#125;&#125; 上面这段代码，我没有为 ready 变量添加 volatile 关键字，程序运行后陷入死循环。 为 ready 变量添加关键字 volatile 修饰后再次运行程序，及时停止，没有死循环。 验证结果：]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发学习记录之线程间通信]]></title>
    <url>%2Fpassages%2FJava%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B9%8B%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[Java 并发学习记录之线程间通信volatile 和 synchronized 关键字Java并发学习记录之volatile Java并发学习记录之synchronized 等待/通知机制Java并发学习记录之wait-notify机制 管道输入/输出流管道输入/输出流和普通文件的输入/输出流或者网络输入、输出流不同之处在于管道输入/输出流主要用于线程之间的数据传输，而且传输的媒介为内存。 管道输入/输出流主要包括下列两类的实现： 面向字节： PipedOutputStream、 PipedInputStream 面向字符: PipedWriter、 PipedReader 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.littlefxc.examples.base.thread.pipe;import java.io.IOException;import java.io.PipedReader;import java.io.PipedWriter;/** * 管道输入/输出主要用于线程间的数据传输，传输的媒介是内存。具体实现： * &lt;br&gt;面向字节: * &lt;ul&gt; * &lt;li&gt;PipedWriter&lt;/li&gt; * &lt;li&gt;PipedReader&lt;/li&gt; * &lt;/ul&gt; * &lt;br&gt;面向字符: * &lt;ul&gt; * &lt;li&gt;PipedOutputStream&lt;/li&gt; * &lt;li&gt;PipedInputStream&lt;/li&gt; * &lt;/ul&gt; * * @author fengxuechao * @date 2019/2/26 **/public class Piped &#123; public static void main(String[] args) throws IOException &#123; PipedWriter writer = new PipedWriter(); PipedReader reader = new PipedReader(); // 将输出流和输入流进行必要的连接 writer.connect(reader); Thread printThread = new Thread(new Print(reader), "PrintThread"); printThread.start(); int receive = 0; try &#123; while ((receive = System.in.read()) != -1) &#123; writer.write(receive); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; writer.close(); &#125; &#125; static class Print implements Runnable &#123; private PipedReader reader; public Print(PipedReader reader) &#123; this.reader = reader; &#125; @Override public void run() &#123; int receive = 0; try &#123; while ((receive = reader.read()) != -1) &#123; System.out.print((char) receive); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 运行该示例，输入一组字符串，可以看到 printThread 进行了原样输出。 Tips：对于 Piped 类型的流，必须要进行绑定，也就是调用 connect()，否则会抛异常。 Thread.join() 的使用在很多情况下，主线程生成并起动了子线程，如果子线程里要进行大量的耗时的运算，主线程往往将于子线程之前结束，但是如果主线程处理完其他的事务后，需要用到子线程的处理结果，也就是主线程需要等待子线程执行完成之后再结束，这个时候就要用到join()方法了。另外，一个线程需要等待另一个线程也需要用到join()方法。 Thread类除了提供 join() 方法之外，还提供了 join(long millis)、join(long millis, int nanos)两个具有超时特性的方法。这两个超时方法表示，如果线程thread在指定的超时时间没有终止，那么将会从该超时方法中返回。 重点看一下 join(long millis) 的示例： 12345678910111213141516171819202122232425262728293031323334package com.littlefxc.examples.base.thread;/** * @author fengxuechao */public class JoinLongTest &#123; public static void main(String[] args) &#123; try &#123; MyThread threadTest = new MyThread(); threadTest.start(); threadTest.join(1000);// 主线成等待子线程1秒// Thread.sleep(1000); System.out.println("主线程结束"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; static public class MyThread extends Thread &#123; @Override public void run() &#123; try &#123; Thread.sleep(2000); System.out.println("子线程结束"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 运行结果： ThreadLocal之前我们讲保证线程资源安全问题时，使用同步加锁的方式保证线程安全。还有一种办法就是隔离资源的做法。 所谓的隔离，即每个线程使用自己的局部资源。将资源隔离不让其它线程访问，从被隔离资源的角度来说，能够访问它的只有当前线程。既然只有当前线程可以访问的数据，自然是线程安全的。一个典型的例子就是 Servlet。 ThreadLocal 的简单使用首先来一个不使用 ThreadLocal 的类，然后在逐渐对其改造。 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.littlefxc.examples.base.thread.threadlocal;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;/** * @author fengxuechao * @date 2019/2/26 **/public class ThreadLocal1 &#123; private static final SimpleDateFormat SDF = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); public static void main(String[] args) &#123; ExecutorService es = Executors.newFixedThreadPool(10); for (int i = 0; i &lt; 1000; i++) &#123; es.execute(new ParseDate(i)); &#125; es.shutdown(); &#125; private static class ParseDate implements Runnable &#123; int i = 0; public ParseDate(int i) &#123; this.i = i; &#125; @Override public void run() &#123; try &#123;ParseDateWithSync Date date = SDF.parse("2019-02-26 16:23:" + i % 60); System.out.println(i + ":" + date);// &#125; &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 运行结果： 一般这种问题主要是因为 SimpleDateFormat 在多线程环境下，是线程不安全的，所以如果你在多线程环境中共享了SimpleDateFormat的实例，比如你在类似日期类中定义了一个全局的 SimpleDateFormat 对象，这样子肯定会出现上述的报错 一种解决办法就是加锁，在上面代码中可以将注释去掉后再次运行，也就不会出现这个问题了。 但是我现在要使用保存线程局部变量的ThreadLocal对象来保存每一个线程的SimpleDateFormat对象，针对上述代码做出改变： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.littlefxc.examples.base.thread.threadlocal;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;/** * @author fengxuechao * @date 2019/2/26 **/public class ParseDateWithThreadLocal &#123; static final String pattern = "yyyy-MM-dd HH:mm:ss"; private static final ThreadLocal&lt;SimpleDateFormat&gt; threadLocal = new ThreadLocal&lt;SimpleDateFormat&gt;(); public static void main(String[] args) &#123; ExecutorService es = Executors.newFixedThreadPool(10); for (int i = 0; i &lt; 1000; i++) &#123; es.execute(new ParseDate(i)); &#125; es.shutdown(); &#125; private static class ParseDate implements Runnable &#123; int i = 0; public ParseDate(int i) &#123; this.i = i; &#125; @Override public void run() &#123; try &#123; // 如果当前线程不持有 SimpleDateFormat 对象。那就新建并保存设置在当前线程中，如果已持有，则直接使用。 if (threadLocal.get()==null) &#123; threadLocal.set(new SimpleDateFormat(pattern)); &#125; Date date = threadLocal.get().parse("2019-02-26 16:23:" + i % 60); System.out.println(i + ":" + date); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 注意：从上面代码中也可以看出，为每一个线程分配一个对象的工作并不是由 ThreadLocal 来完成的，而是需要开发人员在应用层面保证的。ThreadLocal 只是起到了一个容器的作用。 ThreadLocal的原理ThreadLocal的原理]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发学习记录之wait/notify机制]]></title>
    <url>%2Fpassages%2FJava%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B9%8Bwait-notify%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[为了支持多线程之间的协作，JDK提供了两个非常重要的接口线程等待 wait() 方法和通知 notify() 方法。 Java 并发学习记录之 wait/notify 机制为了支持多线程之间的协作，JDK提供了两个非常重要的接口线程等待 wait() 方法和通知 notify() 方法。 wait(): 使调用该方法的线程释放共享资源锁，然后从运行状态退出，进入等待队列，直到被再次唤醒 notify(): 随机唤醒等待队列中等待同一共享资源的 “一个线程”，并使该线程退出等待队列，进入可运行状态，也就是 notify() 方法仅通知“一个线程” wait(long): 超时等待一段时间，这里的参数时间是毫秒，也就是等待长达n毫秒，如果没有通知就超时返回 wait(long, int): 对于超时时间更细力度的控制，可以达到纳秒 notifyAll(): 使所有正在等待队列中等待同一共享资源的 “全部线程” 退出等待队列，进入可运行状态。此时，优先级最高的那个线程最先执行，但也有可能是随机执行，这取决于JVM虚拟机的实现 文字表达太枯燥了，作图演示有关线程状态的变化： 简单实例演示123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.littlefxc.examples.base.thread;/** * @author fengxuechao * @date 2019/2/22 **/public class WaitNotifySample &#123; public static void main(String[] args) &#123; Thread t1 = new WaitThread(); Thread t2 = new NotifyThread(); t1.start(); t2.start(); &#125; private static class WaitThread extends Thread &#123; @Override public void run() &#123; synchronized (WaitNotifySample.class) &#123; System.out.println("线程1:开始"); try &#123; System.out.println("线程1:等待中。。。"); WaitNotifySample.class.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("线程1:结束"); &#125; &#125; &#125; private static class NotifyThread extends Thread &#123; @Override public void run() &#123; synchronized (WaitNotifySample.class) &#123; System.out.println("线程2:开始"); WaitNotifySample.class.notify(); System.out.println("线程2:notify() 后必须等待 synchronized 代码执行完后才释放"); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("线程2:结束"); &#125; &#125; &#125;&#125; 执行结果： 代码分析：开启了两个线程 t1, t2。 t1首先获得锁，在执行 wait() 方法前先要申请锁，其中 synchronized(WaitNotifySample.class) 这样写不要觉得奇怪(Java编程思想：一切都是对象)我只是图方便而已， 所以在执行 wait() 方法时，它是持有 WaitNotifySample.class 的锁的。 wait() 方法后，t1 会进行等待，并释放 WaitNotifySample.class 的锁。 t2 线程在执行 notify() 前也会申请 WaitNotifySample.class 的锁. notify() 方法后并不会立即释放锁, 而是必须执行完notify()方法所在的synchronized代码块后才释放。我在这里让 t2 睡眠两秒使得效果更加明显. wait() 与 sleep() 的区别从上面的执行结果也可以看出来, wait() 方法后当前线程是会释放目标对象的锁, 而 sleep() 仍然是阻塞的说明线程没有释放任何资源.]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发学习记录之synchronized]]></title>
    <url>%2Fpassages%2FJava%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B9%8Bsynchronized%2F</url>
    <content type="text"><![CDATA[关键词 synchronized 的多种用法 指定加锁对象：对给定对象加锁，进入同步代码前要获得给定对象的锁 直接作用于实例方法：相当于对当前实例加锁，进入同步代码前要获得当前实例的锁 直接作用于静态方法：相当于对当前类加锁，进入同步代码前要获得当前类的锁 Java 并发学习记录之synchronized简介现在学习的是关于如何使用 synchronized 关键词，关于它的原理不再此次学习范围内。 实例变量的安全问题如何变量是一个方法内部的私有变量，那么这个变量是安全的。 但是如果这个变量是实例变量，那么多个线程操作这个变量就会变得不安全（如果不使用 synchronized 的话） 关键词 synchronized 的多种用法 指定加锁对象：对给定对象加锁，进入同步代码前要获得给定对象的锁 直接作用于实例方法：相当于对当前实例加锁，进入同步代码前要获得当前实例的锁 直接作用于静态方法：相当于对当前类加锁，进入同步代码前要获得当前类的锁 直接作用于实例方法的错误示范1234567891011121314151617181920212223242526272829303132333435package com.littlefxc.examples.base.thread.sync;/** * 指定加锁对象的错误示例：两个线程访问的不是同一个对象 * * @author fengxuechao * @date 2019/2/20 **/public class AccountSync1 implements Runnable &#123; static volatile int money = 0; public static void main(String[] args) &#123; AccountSync1 account1 = new AccountSync1(); AccountSync1 account2 = new AccountSync1(); Thread t1 = new Thread(account1); Thread t2 = new Thread(account2); t1.start(); t2.start(); try &#123; t1.join(); t2.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(money); &#125; @Override public void run() &#123; for (int i = 0; i &lt; 100000; i++) &#123; money++; &#125; &#125;&#125; 结果 结果与我们的期望结果(200000)显然不同。 为什么会这样呢？ 仔细查看代码，我们的 money++ 这个操作做实际上有两步操作，为这段代码加锁，我们为 run() 方法添加 synchronized，变为 123456@Overridepublic synchronized void run() &#123; for (int i = 0; i &lt; 100000; i++) &#123; money++; &#125;&#125; 然后在运行代码，仍然报错。（我都已经加锁了???） 在仔细查看一下代码，可以发现我们的代码中有两个线程，但这两个线程访问的是不同的实例，这就是得不到期望结果的原因了。修改一下代码是两个线程访问同一个实例。代码如下： 123456789101112131415161718192021222324252627282930313233343536package com.littlefxc.examples.base.thread.sync;/** * 指定加锁对象的错误示例：两个线程访问的不是同一个对象 * * @author fengxuechao * @date 2019/2/20 **/public class AccountSync1 implements Runnable &#123; static volatile int money = 0; public static void main(String[] args) &#123; AccountSync1 account1 = new AccountSync1();// AccountSync1 account2 = new AccountSync1(); // 使两个线程访问同一实例 Thread t1 = new Thread(account1); Thread t2 = new Thread(account1); t1.start(); t2.start(); try &#123; t1.join(); t2.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(money); &#125; @Override public synchronized void run() &#123; for (int i = 0; i &lt; 100000; i++) &#123; money++; &#125; &#125;&#125; 现在运行代码可以得到期望的结果 200000 了。 总之， 上述代码中关键词 synchronized 作用于一个实例方法，也就是说在进入被 synchronized 修饰的方法前，多个线程必须获得同一个对象实例的锁，也就是访问同一个对象实例，这样才能保证线程的安全。 指定加锁对象的错误示范我们将上面的代码稍许修改一下，将 synchronized 作用于指定的实例对象，例如 this. 1234567891011121314151617181920212223242526272829303132333435package com.littlefxc.examples.base.thread.sync;/** * @author fengxuechao * @date 2019/2/21 **/public class AccountSync2 implements Runnable &#123; static volatile int money = 0; @Override public void run() &#123; synchronized (this) &#123; for (int i = 0; i &lt; 100000; i++) &#123; money++; &#125; &#125; &#125; public static void main(String[] args) &#123; AccountSync2 account1 = new AccountSync2(); AccountSync2 account2 = new AccountSync2(); Thread t1 = new Thread(account1); Thread t2 = new Thread(account2); t1.start(); t2.start(); try &#123; t1.join(); t2.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(money); &#125;&#125; 结果 可以看到这个错误示例中的改动仅仅只是将 synchronized 关键词放到方法内部，并作用于 this，这个 this 表示当前实例对象。从这个分析我们就可以假设这段代码出错的原因是两个线程访问的不是同一个实例对象。 修改代码： 1234567891011121314151617181920212223242526272829303132333435package com.littlefxc.examples.base.thread.sync;/** * @author fengxuechao * @date 2019/2/21 **/public class AccountSync2 implements Runnable &#123; static volatile int money = 0; @Override public void run() &#123; synchronized (this) &#123; for (int i = 0; i &lt; 100000; i++) &#123; money++; &#125; &#125; &#125; public static void main(String[] args) &#123; AccountSync2 account1 = new AccountSync2();// AccountSync2 account2 = new AccountSync2(); Thread t1 = new Thread(account1); Thread t2 = new Thread(account1); t1.start(); t2.start(); try &#123; t1.join(); t2.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(money); &#125;&#125; 总之， 上述代码中关键词 synchronized 作用于一个对象实例，也就是说在进入被 synchronized 修饰的代码块前，多个线程必须获得同一个对象实例的锁，也就是访问同一个对象实例，这样才能保证线程的安全。 直接作用于静态方法但是，还有一种方法可以保证多个线程访问多个对象实例却仍然保证线程安全的办法。就是对静态方法添加 synchronized 。 12345678910111213141516171819202122232425262728293031323334353637package com.littlefxc.examples.base.thread.sync;/** * @author fengxuechao * @date 2019/2/21 **/public class AccountSync3 implements Runnable &#123; static volatile int money = 0; @Override public void run() &#123; for (int i = 0; i &lt; 100000; i++) &#123; increase(); &#125; &#125; private synchronized static void increase() &#123; money++; &#125; public static void main(String[] args) &#123; AccountSync3 account1 = new AccountSync3(); AccountSync3 account2 = new AccountSync3(); Thread t1 = new Thread(account1); Thread t2 = new Thread(account2); t1.start(); t2.start(); try &#123; t1.join(); t2.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(money); &#125;&#125; 分析上面代码，首先我们要知道在Java中一切都是对象，所以在Java中类本身也是一个对象。在JVM初始化Java的时候是有一个顺序的： 先初始化父类的静态代码 初始化子类的静态代码 (创建实例时,如果不创建实例,则后面的不执行)初始化父类的非静态代码（变量定义等） 初始化父类构造函数 初始化子类非静态代码（变量定义等） 初始化子类构造函数 简而言之，synchronized 修饰静态方法，加锁的是当前类本身。验证我的想法，改造它为如下代码: 1234567891011121314151617181920212223242526272829303132333435package com.littlefxc.examples.base.thread.sync;/** * @author fengxuechao * @date 2019/2/21 **/public class AccountSync4 implements Runnable &#123; static volatile int money = 0; @Override public void run() &#123; synchronized (AccountSync4.class) &#123; for (int i = 0; i &lt; 100000; i++) &#123; money++; &#125; &#125; &#125; public static void main(String[] args) &#123; AccountSync4 account1 = new AccountSync4(); AccountSync4 account2 = new AccountSync4(); Thread t1 = new Thread(account1); Thread t2 = new Thread(account2); t1.start(); t2.start(); try &#123; t1.join(); t2.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(money); &#125;&#125; 经过测试，我的想法是对的。同时，在本文开头指出 synchronized 的多种用法其实基于同一原理的不同表现形式。要想操作加锁的内存空间，需要的是能够匹配这把锁的钥匙，从而使得在某一时间内只有获得这把锁的线程才可以访问这把锁锁住的空间例如，还可以进行这种改造 synchronized 修饰不可变对象如字符串。 123synchronized ("abc") &#123; ...&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL分布式事务原理探究]]></title>
    <url>%2Fpassages%2FMySQL%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6%2F</url>
    <content type="text"><![CDATA[分布式事务处理的XA规范(由 AP、RM、TM 组成): 其中应用程序（Application Program ，简称 AP）：AP 定义事务边界（定义事务开始和结束）并访问事务边界内的资源。 资源管理器（Resource Manager，简称 RM）：RM 管理计算机共享的资源，许多软件都可以去访问这些资源，资源包含比如数据库、文件系统、打印机服务器等。 事务管理器（Transaction Manager ，简称TM）：负责管理全局事务，分配事务唯一标识，监控事务的执行进度，并负责事务的提交、回滚、失败恢复等。 MySQL 中基于 XA 实现的分布式事务-学习记录XA 协议 分布式事务处理的XA规范(由 AP、RM、TM 组成): 其中应用程序（Application Program ，简称 AP）：AP 定义事务边界（定义事务开始和结束）并访问事务边界内的资源。 资源管理器（Resource Manager，简称 RM）：RM 管理计算机共享的资源，许多软件都可以去访问这些资源，资源包含比如数据库、文件系统、打印机服务器等。 事务管理器（Transaction Manager ，简称TM）：负责管理全局事务，分配事务唯一标识，监控事务的执行进度，并负责事务的提交、回滚、失败恢复等。 XA 主要规定了 RM 与 TM 之间的交互，下面来看下 XA 规范中定义的 RM 和 TM 交互的接口： xa_start 负责开启或者恢复一个事务分支，并且关联 XID 到调用线程 xa_end 负责取消当前线程与事务分支的关联 xa_prepare 负责询问 RM 是否准备好了提交事务分支 xa_commit 通知 RM 提交事务分支 xa_rollback 通知 RM 回滚事务分支 XA 协议是使用了二阶段协议的，其中： 第一阶段 TM 要求所有的 RM 准备提交对应的事务分支，询问 RM 是否有能力保证成功的提交事务分支，RM 根据自己的情况，如果判断自己进行的工作可以被提交，那就就对工作内容进行持久化，并给 TM 回执 OK；否者给 TM 的回执 NO。RM 在发送了否定答复并回滚了已经的工作后，就可以丢弃这个事务分支信息了。 第二阶段 TM 根据阶段 1 各个 RM prepare 的结果，决定是提交还是回滚事务。如果所有的 RM 都 prepare 成功，那么 TM 通知所有的 RM 进行提交；如果有 RM prepare 回执 NO 的话，则 TM 通知所有 RM 回滚自己的事务分支。 也就是 TM 与 RM 之间是通过两阶段提交协议进行交互的。 MySQL 实现 XA确认下 MySQL 是否启动了 XA 功能：show variables like &#39;innodb_support_xa&#39; maven 依赖123456789101112&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.15&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.transaction&lt;/groupId&gt; &lt;artifactId&gt;jta&lt;/artifactId&gt; &lt;version&gt;1.1&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; Java 代码实现如下代码是对两个数据库进行转账操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package com.littlefxc.examples.mysqlxa2pc;import com.mysql.cj.jdbc.MysqlXADataSource;import com.mysql.cj.jdbc.MysqlXid;import javax.sql.XAConnection;import javax.transaction.xa.XAException;import javax.transaction.xa.XAResource;import javax.transaction.xa.Xid;import java.sql.Connection;import java.sql.SQLException;import java.sql.Statement;/** * @author fengxuechao */public class XaExample &#123; public static void main(String[] args) throws SQLException, XAException &#123; String url1 = "jdbc:mysql://192.168.120.63:3306/learn?useSSL=false&amp;serverTimezone=UTC"; String url2 = "jdbc:mysql://192.168.120.63:3306/learn2?useSSL=false&amp;serverTimezone=UTC"; String url3 = "jdbc:mysql://localhost:3306/learn?useSSL=false&amp;serverTimezone=UTC"; // 从不同的数据库获取数据库数据源 MysqlXADataSource ds1 = getDataSource(url1, "root", "123456"); MysqlXADataSource ds2 = getDataSource(url2, "root", "123456"); // 数据库1获取连接 XAConnection xAConn1 = ds1.getXAConnection(); Connection conn1 = xAConn1.getConnection(); XAResource xaResource1 = xAConn1.getXAResource(); Statement statement1 = conn1.createStatement(); // 数据库2获取连接 XAConnection xAConn2 = ds2.getXAConnection(); Connection conn2 = xAConn2.getConnection(); XAResource xaResource2 = xAConn2.getXAResource(); Statement statement2 = conn2.createStatement(); // 其中 xid 是一个全局唯一的 id 标示一个分支事务，每个分支事务有自己的全局唯一的一个 id。 Xid xid1 = new MysqlXid(new byte[]&#123;0x01&#125;, new byte[]&#123;0x02&#125;, 100); Xid xid2 = new MysqlXid(new byte[]&#123;0x011&#125;, new byte[]&#123;0x012&#125;, 100); try &#123; // 事务分支1关联事务sql语句 xaResource1.start(xid1, XAResource.TMNOFLAGS); int update1 = statement1.executeUpdate("update account_from set money = money - 0.5 where id = 1"); xaResource1.end(xid1, XAResource.TMSUCCESS); // 事务分支2关联事务sql语句 xaResource2.start(xid2, XAResource.TMNOFLAGS); int update2 = statement2.executeUpdate("update account_to set money = money + 0.5 where id = 1"); xaResource2.end(xid2, XAResource.TMSUCCESS); // 两阶段提交协议第一阶段 int ret1 = xaResource1.prepare(xid1); int ret2 = xaResource2.prepare(xid2); // 两阶段提交协议第二阶段 if (XAResource.XA_OK == ret1 &amp;&amp; XAResource.XA_OK == ret2) &#123; xaResource1.commit(xid1, false); xaResource2.commit(xid2, false); System.out.println("result:" + update1 + ", result2:" + update2); &#125; &#125; catch (XAException e) &#123; xaResource1.rollback(xid1); xaResource2.rollback(xid2); e.printStackTrace(); &#125; &#125; /** * 获取 MysqlXADataSource * * @param url * @param username * @param password * @return */ public static MysqlXADataSource getDataSource(String url, String username, String password) &#123; MysqlXADataSource dataSource = new MysqlXADataSource(); dataSource.setUrl(url); dataSource.setUser(username); dataSource.setPassword(password); return dataSource; &#125;&#125; 问题记录MySQL 8.x版本更新安全插件 mysql_native_password 变为 caching_sha2_password Unable to load authentication plugin ‘caching_sha2_password’. 解决办法：升级 mysql-connector-java 依赖的版本。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>分布式事务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日志写入数据库Logback-JDBCAppender]]></title>
    <url>%2Fpassages%2F%E6%97%A5%E5%BF%97%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE%E5%BA%93Logback-JDBCAppender%2F</url>
    <content type="text"><![CDATA[Logback-DBAppenderDBAppender以独立于Java编程语言的格式将日志事件插入到三个数据库表中。这三个表是 logging_event、logging_event_property 和 logging_event_exception。在使用DBAppender之前，它们必须存在。Logback附带了创建表的SQL脚本。它们可以在 logback-classic/src/main/java/ch/qos/logback/classic/db/script 文件夹下找到。对于每个最流行的数据库系统，都有一个特定的脚本。如果您的特定类型的数据库系统缺少脚本，那么应该很容易以现有脚本为例编写一个脚本。如果JDBC驱动程序支持JDBC 3.0规范中引入的getGeneratedKeys方法，假设您已经创建了如上所述的适当的数据库表，那么就不需要额外的步骤。否则，必须有适合您的数据库系统的sql方言。目前，logback有H2、HSQL、MS SQL Server、MySQL、Oracle、PostgreSQL、SQLLite和Sybase等多种方言。 如前所述，logback使用三个表来存储日志事件数据: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849BEGIN;DROP TABLE IF EXISTS logging_event_property;DROP TABLE IF EXISTS logging_event_exception;DROP TABLE IF EXISTS logging_event;COMMIT;BEGIN;CREATE TABLE logging_event( timestmp BIGINT NOT NULL, formatted_message TEXT NOT NULL, logger_name VARCHAR(254) NOT NULL, level_string VARCHAR(254) NOT NULL, thread_name VARCHAR(254), reference_flag SMALLINT, arg0 VARCHAR(254), arg1 VARCHAR(254), arg2 VARCHAR(254), arg3 VARCHAR(254), caller_filename VARCHAR(254) NOT NULL, caller_class VARCHAR(254) NOT NULL, caller_method VARCHAR(254) NOT NULL, caller_line CHAR(4) NOT NULL, event_id BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY);COMMIT;BEGIN;CREATE TABLE logging_event_property( event_id BIGINT NOT NULL, mapped_key VARCHAR(254) NOT NULL, mapped_value TEXT, PRIMARY KEY(event_id, mapped_key), FOREIGN KEY (event_id) REFERENCES logging_event(event_id));COMMIT;BEGIN;CREATE TABLE logging_event_exception( event_id BIGINT NOT NULL, i SMALLINT NOT NULL, trace_line VARCHAR(254) NOT NULL, PRIMARY KEY(event_id, i), FOREIGN KEY (event_id) REFERENCES logging_event(event_id));COMMIT; maven 依赖通过使用 platform-bom 来管理依赖的版本问题。使用 druid 作为 JDBCAppender 的连接池。 12345678910111213141516171819202122232425262728293031323334353637383940&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;io.spring.platform&lt;/groupId&gt; &lt;artifactId&gt;platform-bom&lt;/artifactId&gt; &lt;version&gt;Cairo-RELEASE&lt;/version&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;type&gt;pom&lt;/type&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 日志配置文件：logback.xmlch.qos.logback.classic.db.DBAppender 是 logback 中 DBAppender 的实现类。 ch.qos.logback.core.db.DataSourceConnectionSource 是 DBAppender 的管理数据源的类。 com.alibaba.druid.pool.DruidDataSource 是数据源连接池，你也可以选择其它数据源连接池。 1234567891011121314151617181920212223242526272829&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;configuration&gt; &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder"&gt; &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;appender name="DB" class="ch.qos.logback.classic.db.DBAppender"&gt; &lt;connectionSource class="ch.qos.logback.core.db.DataSourceConnectionSource"&gt; &lt;dataSource class="com.alibaba.druid.pool.DruidDataSource"&gt; &lt;!-- DruidDataSource 中的属性配置 --&gt; &lt;driverClassName&gt;com.mysql.jdbc.Driver&lt;/driverClassName&gt; &lt;url&gt;jdbc:mysql://192.168.120.63:3306/learn?useSSL=false&lt;/url&gt; &lt;username&gt;root&lt;/username&gt; &lt;password&gt;123456&lt;/password&gt; &lt;/dataSource&gt; &lt;/connectionSource&gt; &lt;/appender&gt; &lt;logger name="com.littlefxc.examples.logback" level="debug"/&gt; &lt;root level="debug"&gt; &lt;appender-ref ref="STDOUT"/&gt; &lt;appender-ref ref="DB" /&gt; &lt;/root&gt;&lt;/configuration&gt; 启动123456789101112131415161718192021222324package com.littlefxc.examples.logback;import org.slf4j.Logger;import org.slf4j.LoggerFactory;/** * @author fengxuechao * @date 2019/2/12 **/public class App &#123; private static final Logger log = LoggerFactory.getLogger(App.class); public static void main(String[] args) &#123; long l = System.currentTimeMillis(); log.debug("This is debug"); long r = System.currentTimeMillis(); System.out.println(r - l); log.info("This is info"); log.warn("This is warn"); log.error("This is error"); log.error("This is exception", new RuntimeException("this is a exception")); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>日志</tag>
        <tag>logback</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日志写入数据库Log4j2-JDBCAppender]]></title>
    <url>%2Fpassages%2F%E6%97%A5%E5%BF%97%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE%E5%BA%93Log4j2-JDBCAppender%2F</url>
    <content type="text"><![CDATA[Log4j2-JDBCAppenderJDBCAppender使用标准JDBC将日志事件写入关系数据库表。可以将其配置为使用JNDI数据源或自定义工厂方法获取JDBC连接。无论采用哪种方法，都必须有连接池作为支持。否则，日志记录性能将受到很大影响。 maven 依赖通过使用 platform-bom 来管理依赖的版本问题。使用 druid 作为 JDBCAppender 的连接池。 12345678910111213141516171819202122232425262728293031323334353637383940&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;io.spring.platform&lt;/groupId&gt; &lt;artifactId&gt;platform-bom&lt;/artifactId&gt; &lt;version&gt;Cairo-RELEASE&lt;/version&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;type&gt;pom&lt;/type&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-slf4j-impl&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 日志配置文件：log4j2.xml&lt;JDBC&gt;&lt;/JDBC&gt; 是 Log4j2 的 JDBCAppender 的标签。 ConnectionFactory 是一个实现 Druid 连接池的单例类， 通过 method 属性来获取 java.sql.Connection。 Column 表示数据表 log4j2 的字段。 1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;Configuration status="INFO"&gt; &lt;Appenders&gt; &lt;Console name="console" target="SYSTEM_OUT"&gt; &lt;PatternLayout pattern="[%-5level] %d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%t] %c&#123;1&#125; - %msg%n"/&gt; &lt;/Console&gt; &lt;!-- JDBCAppender --&gt; &lt;JDBC name="jdbc" tableName="log4j2"&gt; &lt;ConnectionFactory class="com.littlefxc.examples.log4j2.ConnectionFactory" method="getDatabaseConnection"/&gt; &lt;!-- 数据表 log4j2 中的字段 --&gt; &lt;Column name="time" pattern="%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;" /&gt; &lt;Column name="level" pattern="%level"/&gt; &lt;Column name="logger" pattern="%logger"/&gt; &lt;Column name="message" pattern="%message"/&gt; &lt;Column name="exception" pattern="%ex&#123;full&#125;"/&gt; &lt;/JDBC&gt; &lt;/Appenders&gt; &lt;Loggers&gt; &lt;Logger name="com.littlefxc.examples.log4j2" level="debug" additivity="false"&gt; &lt;AppenderRef ref="jdbc"/&gt; &lt;/Logger&gt; &lt;Root level="debug" additivity="false"&gt; &lt;AppenderRef ref="console"/&gt; &lt;/Root&gt; &lt;/Loggers&gt;&lt;/Configuration&gt; 数据库文件：schema.sql123456789101112131415SET NAMES utf8mb4;SET FOREIGN_KEY_CHECKS = 0;DROP TABLE IF EXISTS log4j2;CREATE TABLE `log4j2` ( `id` bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT, `time` char(23) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL, `level` char(5) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL, `logger` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL, `message` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL, `exception` varchar(1000) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '', PRIMARY KEY (`id`) USING BTREE) ENGINE = MyISAM AUTO_INCREMENT = 1 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;SET FOREIGN_KEY_CHECKS = 1; ConnectionFactory1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.littlefxc.examples.log4j2;import com.alibaba.druid.pool.DruidDataSource;import javax.sql.DataSource;import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;import java.sql.Connection;import java.sql.SQLException;import java.util.Properties;/** * Log4j2 ConnectionFactory * * @author fengxuechao */public class ConnectionFactory &#123; private final DataSource dataSource; private ConnectionFactory() &#123; Properties properties = new Properties(); String lineSeparator = File.separator; String fileName = String.join(lineSeparator, System.getProperty("user.dir"), "Log4j2-JDBCAppender", "src", "main", "resources", "db.properties"); try (InputStream stream = new FileInputStream(fileName)) &#123; properties.load(stream); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; this.dataSource = new DruidDataSource(); ((DruidDataSource) this.dataSource).configFromPropety(properties); &#125; public static Connection getDatabaseConnection() throws SQLException &#123; return Singleton.INSTANCE.dataSource.getConnection(); &#125; private static interface Singleton &#123; final ConnectionFactory INSTANCE = new ConnectionFactory(); &#125;&#125; ConnectionFactory 是一个实现 Druid 连接池的单例类。 db.properties123456druid.url=jdbc:mysql://192.168.120.63:3306/learn?useSSL=falsedruid.username=rootdruid.password=123456druid.driverClassName=com.mysql.jdbc.Driverdruid.maxActive=10druid.minIdle=5 启动123456789101112131415161718192021package com.littlefxc.examples.log4j2;import org.slf4j.Logger;import org.slf4j.LoggerFactory;/** * @author fengxuechao * @date 2019/2/11 **/public class App &#123; private static final Logger log = LoggerFactory.getLogger(App.class); public static void main(String[] args) &#123; log.debug("This is debug"); log.info("This is info"); log.warn("This is warn"); log.error("This is error"); log.error("This is error", new RuntimeException("this is a exception")); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>日志</tag>
        <tag>log4j2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring-expression学习记录]]></title>
    <url>%2Fpassages%2Fspring-expression%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[Spring SpEl 表达式语言 - 学习记录SpEL是类似于OGNL和JSF EL的表达式语言，能够在运行时构建复杂表达式，存取对象属性、对象方法调用等。所有的SpEL都支持XML和Annotation两种方式，格式：#{ expressoin } Maven 依赖因为 spring-context 依赖中包含 spring-expression，所以选择它。 123456&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 初始化在后面的一系列的测试中，都有用到在 @Before 中的元素。我仅仅只是将一份这份单元测试类分解了而已。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public class SpelTest &#123; ExpressionParser parser; // 测试 XML 配置 SpEl User user; BeanFactory beanFactory; // 测试注解配置 SpEl FieldValueTestBean fieldValueTestBean; MovieRecommender movieRecommender; PropertyValueTestBean propertyValueTestBean; StandardEvaluationContext context; // 发明家列表 List&lt;Inventor&gt; inventorList = new ArrayList&lt;&gt;(); // 发明家特斯拉 Inventor inventorTesla; // 发明家爱迪生 Inventor inventorEdlson; // 发明家贝尔 Inventor inventorBell; // 发明家数组 Inventor[] inventorArrays; Society society; /** * 初始化Spring */ @Before public void setUp() &#123; beanFactory = new ClassPathXmlApplicationContext("classpath:spring-root.xml"); &#123; // 允许 SpEl 表达式访问 IOC 容器中的 bean // SpEL支持使用 "@" 符号来引用Bean, 在引用Bean时需要使用BeanResolver接口实现来查找Bean, Spring提供BeanFactoryResolver实现 context = new StandardEvaluationContext(); context.setBeanResolver(new BeanFactoryResolver(beanFactory)); &#125; // SpEl 解析器 parser = (ExpressionParser) beanFactory.getBean("parser"); // XML 配置 SpEl user = (User) beanFactory.getBean("user"); // 注解配置 SpEl fieldValueTestBean = (FieldValueTestBean) beanFactory.getBean("fieldValueTestBean"); movieRecommender = (MovieRecommender) beanFactory.getBean("movieRecommender"); propertyValueTestBean = (PropertyValueTestBean) beanFactory.getBean("propertyValueTestBean"); &#123; // 设置 SpEl 的 根对象 inventorTesla = new Inventor("尼古拉·特斯拉", "塞尔维亚裔美籍"); inventorTesla.setPlaceOfBirth(new PlaceOfBirth("利卡-塞尼县", "克罗地亚")); inventorEdlson = new Inventor("托马斯·阿尔瓦·爱迪生", "美国"); inventorEdlson.setPlaceOfBirth(new PlaceOfBirth("米兰", "美国俄亥俄州")); inventorBell = new Inventor("亚历山大·格拉汉姆·贝尔", "美国"); inventorBell.setPlaceOfBirth(new PlaceOfBirth("爱丁堡", "英国苏格兰")); inventorList.add(inventorTesla); inventorList.add(inventorEdlson); inventorList.add(inventorBell); // 数组和列表的内容通过使用方括号表示法获得 Inventor[] inventorArrays = new Inventor[3]; inventorArrays = inventorList.toArray(inventorArrays); society = new Society(); society.getOfficers().put(Society.President, inventorEdlson); society.getOfficers().put(Society.Advisors, inventorList); &#125; &#125;&#125; 1. 入门支持执行字符串表达式1234567@Testpublic void test1() &#123; ExpressionParser parser = new SpelExpressionParser(); Expression exp = parser.parseExpression("'Hello World'"); String message = (String) exp.getValue(); Assert.assertEquals("Hello World", message);&#125; SpEL支持广泛的功能，例如调用方法，访问属性和调用构造函数12345678910111213141516171819202122232425@Testpublic void test2() &#123; ExpressionParser parser = new SpelExpressionParser(); // 调用方法 Expression exp = parser.parseExpression("'Hello World'.concat('!')"); String message = (String) exp.getValue(); Assert.assertEquals("Hello World!", message); // 调用属性 exp = parser.parseExpression("'Hello World'.bytes"); byte[] bytesE = "Hello World".getBytes(); byte[] bytesA = (byte[]) exp.getValue(); Assert.assertArrayEquals(bytesE, bytesA); // SpEL还通过使用标准点表示法（例如prop1.prop2.prop3）和属性值的设置来支持嵌套属性。也可以访问公共字段。 exp = parser.parseExpression("'Hello World'.bytes.length"); int lengthE = "Hello World".getBytes().length; int lengthA = (int) exp.getValue(); Assert.assertEquals(lengthE, lengthA); // 调用构造方法 exp = parser.parseExpression("new String('hello world').toUpperCase()"); String constructorA = exp.getValue(String.class); Assert.assertEquals("HELLO WORLD", constructorA); &#125; SpEL的更常见用法是提供针对特定对象实例（称为根对象）计算的表达式字符串12345678@Testpublic void test3() &#123; ExpressionParser parser = new SpelExpressionParser(); Expression exp = parser.parseExpression("username == 'fxc'"); Boolean expValue = exp.getValue(user, Boolean.class); Assert.assertEquals(true, expValue);&#125; Spring Beans 中的 SpEl 表达式, Bean 的引用Spring SpEL 可以在 XML 配置文件中使用，同样可以在注解配置中使用例如 @Value(&quot;#{expression}&quot;)。 Spring 允许 SpEl 表达式访问 IOC 容器中的 bean，SpEL支持使用 @ 符号来引用Bean, 在引用 Bean 时需要使用 BeanResolver 接口实现来查找Bean, Spring提供 BeanFactoryResolver 实现 ClassPathXmlApplicationContext 实现默认会把 System.getProperties() 注册名为systemProperties 的 Bean，因此使用 @systemProperties 来引用该 Bean。 在 Spring 配置文件中使用 SpEl 表达式12345678910111213141516171819202122&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;context:property-placeholder location="classpath:application.properties"/&gt; &lt;context:component-scan base-package="com.littlefxc.examples.spel"/&gt; &lt;bean id="parser" class="org.springframework.expression.spel.standard.SpelExpressionParser"/&gt; &lt;!-- 同样也适用于 Java Config, 例如 @Value("#&#123;systemProperties['user.country']&#125;") --&gt; &lt;bean id="user" class="com.littlefxc.examples.spel.User"&gt; &lt;property name="username" value="fxc"/&gt; &lt;!--&lt;property name="uuid" value="#&#123;T(java.util.UUID).randomUUID().toString()&#125;"/&gt;--&gt; &lt;property name="uuid" value="$&#123;user.uuid&#125;"/&gt; &lt;property name="place" value="#&#123;systemProperties['user.country']&#125;"/&gt; &lt;property name="age" value="$&#123;user.age&#125;"/&gt; &lt;/bean&gt;&lt;/beans&gt; application.properties 12user.uuid=#&#123;T(java.util.UUID).randomUUID().toString()&#125;user.age=18 在注解中用法1：在成员属性上使用 SpEL 表达式123456789101112131415161718package com.littlefxc.examples.spel;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;/** * @author fengxuechao * @date 2019/1/24 **/@Componentpublic class FieldValueTestBean &#123; @Value("#&#123; systemProperties['user.country'] &#125;") private String defaultLocale; // 省略 setter getter&#125; 在注解中用法2：在构造方法上使用 SpEL 表达式12345678910111213@Componentpublic class MovieRecommender &#123; private String movieName; private String defaultLocale; @Autowired public MovieRecommender(@Value("#&#123; systemProperties['user.country'] &#125;") String defaultLocale) &#123; this.defaultLocale = defaultLocale; &#125; // 省略 setter getter&#125; 在注解中用法3：在属性设置方法上使用 SpEL 表达式1234567891011121314151617181920package com.littlefxc.examples.spel;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;@Componentpublic class PropertyValueTestBean &#123; private String defaultLocale; public String getDefaultLocale() &#123; return this.defaultLocale; &#125; @Value("#&#123; systemProperties['user.country'] &#125;") public void setDefaultLocale(String defaultLocale) &#123; this.defaultLocale = defaultLocale; &#125;&#125; 测试12345678910111213141516@Testpublic void test4() &#123; // 允许 SpEl 表达式访问 IOC 容器中的 bean // SpEL支持使用 "@" 符号来引用Bean, 在引用Bean时需要使用BeanResolver接口实现来查找Bean, Spring提供BeanFactoryResolver实现 // ClassPathXmlApplicationContext 实现默认会把"System.getProperties()"注册为"systemProperties"Bean，因此我们使用 "@systemProperties"来引用该Bean Properties result1 = parser.parseExpression("@systemProperties").getValue(context, Properties.class); System.out.println(result1.getProperty("user.dir", "环境变量中没有该属性")); // XML 配置 User userActual = parser.parseExpression("@user").getValue(context, User.class); Assert.assertSame(user, userActual); // 注解配置 Assert.assertSame(movieRecommender, parser.parseExpression("@movieRecommender").getValue(context, MovieRecommender.class)); Assert.assertSame(propertyValueTestBean, parser.parseExpression("@propertyValueTestBean").getValue(context, PropertyValueTestBean.class));&#125; 2. 字面量表达式SpEL支持的字面量包括：字符串、数字类型（int、long、float、double）、布尔类型、null类型。 类型 示例 字符串 String str1 = parser.parseExpression(“‘Hello World!’”).getValue(String.class); String str2 = parser.parseExpression(“\“Hello World!\“”).getValue(String.class); 数字类型 int int1 = parser.parseExpression(“1”).getValue(Integer.class); long long1 = parser.parseExpression(“-1L”).getValue(long.class); float float1 = parser.parseExpression(“1.1”).getValue(Float.class); double double1 = parser.parseExpression(“1.1E+2”).getValue(double.class); int hex1 = parser.parseExpression(“0xa”).getValue(Integer.class); long hex2 = parser.parseExpression(“0xaL”).getValue(long.class); 布尔类型 boolean true1 = parser.parseExpression(“true”).getValue(boolean.class); boolean false1 = parser.parseExpression(“false”).getValue(boolean.class); null类型 Object null1 = parser.parseExpression(“null”).getValue(Object.class); 12345678910111213141516171819202122@Testpublic void test5() &#123; ExpressionParser parser = new SpelExpressionParser(); // evals to "Hello World" String helloWorld = (String) parser.parseExpression("'Hello World'").getValue(); Assert.assertEquals("Hello World", helloWorld); // 浮点型字面量 double avogadrosNumber = (Double) parser.parseExpression("6.0221415E+23").getValue(); Assert.assertEquals(Double.valueOf("6.0221415E+23"), avogadrosNumber, Double.MIN_VALUE); // evals to 2147483647 int maxValue = (Integer) parser.parseExpression("0x7FFFFFFF").getValue(); Assert.assertEquals(2147483647, maxValue); boolean trueValue = (Boolean) parser.parseExpression("true").getValue(); Assert.assertTrue(trueValue); Object nullValue = parser.parseExpression("null").getValue(); Assert.assertNull(nullValue);&#125; 3. 集合的表达式(Properties, Arrays, Lists, Maps, and Indexers)123456789101112131415161718192021222324252627282930313233343536/** * 集合的表达式 * * @see java.util.Properties * @see java.util.Arrays * @see java.util.List * @see java.util.Map * Index 索引 */ @Test public void test6() &#123; // 属性名称的第一个字母不区分大小写 // 数组和列表的内容通过使用方括号表示法获得 int year = (Integer) parser.parseExpression("Birthdate.Year = 1856").getValue(context); String city = (String) parser.parseExpression("placeOfBirth.City").getValue(context); Assert.assertEquals(1856, year); Assert.assertEquals("利卡-塞尼县", city); // 列表 context.setRootObject(inventorList); String birthCity = parser .parseExpression("[0].placeOfBirth.City") .getValue(context, String.class); Assert.assertEquals("利卡-塞尼县", birthCity); // 字典 context.setRootObject(society); // 改变字典的值的某个属性 parser.parseExpression("Officers['president'].placeOfBirth.City") .setValue(context, "随便"); // 获取字典的值的某个属性 birthCity = (String) parser .parseExpression("officers['president'].placeOfBirth.City") .getValue(context); Assert.assertEquals("随便", birthCity); &#125; 4. 内联列表( Inline Lists )可以使用{}符号直接在表达式中表示列表.{}本身表示一个空列表。出于性能原因，如果列表本身完全由固定的文字组成，那么将创建一个常量列表来表示表达式(而不是在每个表达式上构建一个新的列表) 123456789101112131415161718192021222324252627/** * 内联列表(Inline Lists) */@Test(expected = UnsupportedOperationException.class)public void test7_1() &#123; // 将返回不可修改的空List List list = parser.parseExpression("&#123;&#125;").getValue(List.class); // 对于字面量列表也将返回不可修改的List List list2 = parser.parseExpression("&#123;1,2,3,4&#125;").getValue(List.class); // 不会进行不可修改处理 list2.set(0, 2);&#125;/** * 内联列表(Inline Lists) */@Testpublic void test7_2() &#123; // 对于列表中只要有一个不是字面量表达式，将只返回原始List List&lt;List&lt;Integer&gt;&gt; list = parser.parseExpression("&#123;&#123;1+2, 2+4&#125;,&#123;3, 4+4&#125;&#125;").getValue(List.class); // 操作的不是原始列表 list.get(0).set(0, 1); Integer value = parser.parseExpression("&#123;&#123;1+2, 2+4&#125;,&#123;3, 4+4&#125;&#125;[0][0]").getValue(Integer.class); Assert.assertEquals(1, list.get(0).get(0).intValue()); Assert.assertEquals(3, value.intValue());&#125; 5. 内联字典( Inline Maps )您可以使用熟悉的Java语法来构建数组，也可以提供一个初始化器来在构建时填充数组。 1234567891011121314151617181920/** * 内联字典(Inline Maps) */ @Test public void test8() &#123; // evaluates to a Java map containing the two entries Map inventorInfo = (Map) parser.parseExpression("&#123;name:'Nikola',dob:'10-July-1856'&#125;").getValue(context); Assert.assertEquals("Nikola", inventorInfo.get("name")); // 字典中的字典 Map mapOfMaps = (Map) parser .parseExpression("&#123;name:&#123;first:'Nikola',last:'Tesla'&#125;,dob:&#123;day:10,month:'July',year:1856&#125;&#125;") .getValue(context); Map tesla = (Map) mapOfMaps.get("name"); Assert.assertEquals("Tesla", tesla.get("last")); // 空字典 &#123;:&#125; Map emptyMap = (Map) parser.parseExpression("&#123;:&#125;").getValue(context); Assert.assertEquals(0, emptyMap.size()); &#125; {:}本身表示一个空映射。出于性能原因，如果映射本身由固定的文字或其他嵌套的常量结构(列表或映射)组成，则创建常量映射来表示表达式(而不是在每个表达式上构建新的映射)。 6. 数组构造(Array Construction)您可以使用熟悉的Java语法来构建数组，也可以提供一个初始化器来在构建时填充数组 12345678910111213141516/** * 数组创建(Array Construction):相似的 Java 数组语法 */ @Test public void test9() &#123; int[] numbers1 = (int[]) parser.parseExpression("new int[4]").getValue(context); Assert.assertArrayEquals(new int[4], numbers1); // Array with initializer int[] numbers2 = (int[]) parser.parseExpression("new int[]&#123;1,2,3&#125;").getValue(context); Assert.assertArrayEquals(new int[]&#123;1, 2, 3&#125;, numbers2); // Multi dimensional array int[][] numbers3 = (int[][]) parser.parseExpression("new int[4][5]").getValue(context); Assert.assertArrayEquals(new int[4][5], numbers3); &#125; 在构造多维数组时，无法初始化，也就是 &quot;new int[4][5]&quot; 后面无法添加{} 8. 方法调用您可以使用典型的Java编程语法来调用方法。您还可以对文字调用方法。还支持变量参数。下面的示例展示了如何调用方法： 12345678910111213141516/** * 方法调用 */ @Test public void test10() &#123; // string literal, evaluates to "bc" String bc = parser.parseExpression("'abc'.substring(1, 3)").getValue(String.class); Assert.assertEquals("bc", bc); society.getMembers().add(inventorTesla); context.setRootObject(society); // evaluates to true boolean isMember = parser.parseExpression("isMember('尼古拉·特斯拉')") .getValue(context, Boolean.class); Assert.assertTrue(isMember); &#125; 9. 运算符9.1. 关系运算符关系运算符(等于、不等于、小于、小于或等于、大于、大于或等于)通过使用标准运算符表示法得到支持。下面的清单显示了一些操作符示例: 12345678910111213141516171819202122232425262728293031323334/** * 运算符：关系运算符 */ @Test public void test11() &#123; // 关系运算符(等于、不等于、小于、小于或等于、大于、大于或等于、instanceof、正则表达式) // lt (&lt;) gt (&gt;) le (&lt;=) ge (&gt;=) eq (==) ne (!=) div (/) mod (%) not (!) 可以在XML文档中替换相应的符号 // evaluates to true boolean flag = parser.parseExpression("2 == 2").getValue(Boolean.class); Assert.assertTrue(flag); // evaluates to false flag = parser.parseExpression("2 &lt; -5.0").getValue(Boolean.class); Assert.assertFalse(flag); // evaluates to true flag = parser.parseExpression("'black' &lt; 'block'").getValue(Boolean.class); Assert.assertTrue(flag); // evaluates to false flag = parser.parseExpression( "'xyz' instanceof T(Integer)").getValue(Boolean.class); Assert.assertFalse(flag); // evaluates to true flag = parser.parseExpression( "'5.00' matches '^-?\\d+(\\.\\d&#123;2&#125;)?$'").getValue(Boolean.class); Assert.assertTrue(flag); //evaluates to false flag = parser.parseExpression( "'5.0067' matches '^-?\\d+(\\.\\d&#123;2&#125;)?$'").getValue(Boolean.class); Assert.assertFalse(flag); &#125; 每个符号运算符也可以指定为纯字母等价的。这避免了使用的符号对嵌入表达式的文档类型具有特殊意义的问题(例如在XML文档中). lt (&lt;) gt (&gt;) le (&lt;=) ge (&gt;=) eq (==) ne (!=) div (/) mod (%) not (!) 9.2. 逻辑运算符123456789101112131415161718192021222324252627282930313233343536373839404142/** * 运算符：逻辑运算符 */ @Test public void test12() &#123; society.getMembers().add(inventorTesla); society.getMembers().add(inventorEdlson); context.setRootObject(society); // -- AND -- // evaluates to false boolean flagAnd = parser.parseExpression("true and false").getValue(Boolean.class); Assert.assertFalse(flagAnd); // evaluates to true String expression = "isMember('尼古拉·特斯拉') and isMember('托马斯·阿尔瓦·爱迪生')"; flagAnd = parser.parseExpression(expression).getValue(context, Boolean.class); Assert.assertTrue(flagAnd); // -- OR -- // evaluates to true boolean flagOr = parser.parseExpression("true or false").getValue(Boolean.class); Assert.assertTrue(flagOr); // evaluates to true expression = "isMember('尼古拉·特斯拉') or isMember('托马斯·阿尔瓦·爱迪生')"; flagOr = parser.parseExpression(expression).getValue(context, Boolean.class); Assert.assertTrue(flagOr); // -- NOT -- // evaluates to false boolean flagNot = parser.parseExpression("!true").getValue(Boolean.class); Assert.assertFalse(flagNot); // -- AND and NOT -- expression = "isMember('尼古拉·特斯拉') and !isMember('托马斯·阿尔瓦·爱迪生')"; boolean flagAndNot = parser.parseExpression(expression).getValue(context, Boolean.class); Assert.assertFalse(flagAndNot); &#125; 9.3. 赋值运算符若要设置属性，请使用赋值运算符(=)。这通常在对setValue的调用中完成，但也可以在对getValue的调用中完成。下面的代码展示了使用赋值运算符的两种方法: 123456789101112131415/** * 运算符：赋值运算符 */ @Test public void test14() &#123; Inventor inventor = new Inventor(); parser.parseExpression("Name").setValue(context, inventor, "Alexander Graham"); // alternatively String bell = parser.parseExpression( "Name = 'Alexander Graham Bell'").getValue(context, inventor, String.class); Assert.assertEquals("Alexander Graham Bell", bell);&#125; 10. 构造函数您可以通过使用新的操作符来调用构造函数。除了基本类型(int、float等)和字符串之外，应该对所有类型使用全限定类名。下面的例子展示了如何使用新的操作符来调用构造函数: 123456789101112131415/** * 类类型表达式：使用"T(Type)"来表示java.lang.Class实例，"Type"必须是类全限定名，"java.lang"包除外，即该包下的类可以不指定包名； * 使用类类型表达式还可以进行访问类静态方法及类静态字段。 */ @Test public void test15() &#123; Inventor einstein = parser.parseExpression( "new com.littlefxc.examples.spel.Inventor('爱因斯坦', '德国')") .getValue(Inventor.class); Assert.assertEquals(new Inventor("爱因斯坦", "德国").getName(), einstein.getName()); context.setRootObject(society); //create new inventor instance within add method of List parser.parseExpression("Members.add(new com.littlefxc.examples.spel.Inventor('爱因斯坦', '德国'))").getValue(context); &#125; 11. 变量定义及引用可以使用#variableName语法引用表达式中的变量。变量是通过在EvaluationContext实现上使用setVariable方法设置的。下面的例子展示了如何使用变量: 123456789101112131415161718192021222324252627282930313233/** * 变量定义及引用 * &lt;p&gt; * 变量定义通过 EvaluationContext 接口的 setVariable(variableName, value) 方法定义；&lt;br&gt; * 在表达式中使用 "#variableName" 引用；&lt;br&gt; * 除了引用自定义变量，SpEL还允许引用根对象及当前上下文对象，使用 "#root" 引用根对象，使用 "#this" 引用当前上下文对象；&lt;br&gt; * &lt;/p&gt; */ @Test public void test16() &#123; Inventor tesla = new Inventor("Nikola Tesla", "Serbian"); EvaluationContext context = SimpleEvaluationContext.forReadWriteDataBinding().build(); context.setVariable("newName", "Mike Tesla"); parser.parseExpression("Name = #newName").getValue(context, tesla);// "Mike Tesla"// parser.parseExpression("#root.Name = #newName").getValue(context, tesla);// "Mike Tesla" Assert.assertEquals("Mike Tesla", tesla.getName()); // create an array of integers List&lt;Integer&gt; primes = new ArrayList&lt;&gt;(); primes.addAll(Arrays.asList(2, 3, 5, 7, 11, 13, 17)); // create parser and set variable 'primes' as the array of integers context.setVariable("primes", primes); // 通过使用诸如 (using selection ?&#123;...&#125;) 这样的选择表达式，选择列表中所有大于10的数字 // evaluates to [11, 13, 17] List&lt;Integer&gt; primesGreaterThanTen = (List&lt;Integer&gt;) parser .parseExpression("#primes.?[#this&gt;10]").getValue(context); System.out.println(primesGreaterThanTen); &#125; 12. 自定义函数您可以通过注册可在表达式字符串中调用的用户定义函数来扩展SpEL。 该功能通过EvaluationContext注册。 以下示例显示如何注册用户定义的函数： 1234567891011121314151617/** * 自定义函数 * &lt;p&gt; * 目前只支持类静态方法注册为自定义函数；&lt;br&gt; * SpEL使用StandardEvaluationContext的registerFunction方法进行注册自定义函数， * 其实完全可以使用setVariable代替，两者其实本质是一样的； * &lt;/p&gt; */ @Test public void test17() throws NoSuchMethodException &#123; Method parseInt = Integer.class.getDeclaredMethod("parseInt", String.class); // 自定义函数推荐用 context.registerFunction("fnName", fn) context.registerFunction("parseInt", parseInt); context.setVariable("parseInt2", parseInt); Boolean bool = parser.parseExpression("#parseInt('3') == #parseInt2('3')").getValue(context, Boolean.class); Assert.assertTrue(bool); &#125; 13. 三目运算及Elivis运算表达式12345678910111213141516171819202122232425262728293031323334/** * 三目运算及Elivis运算表达式 * &lt;br&gt; * 三目运算符 "表达式1?表达式2:表达式3"用于构造三目运算表达式，如"2&gt;1?true:false"将返回true； * &lt;br&gt; * Elivis运算符 "表达式1?:表达式2" 从Groovy语言引入用于简化三目运算符的， * 当 表达式1 为 非null 时则返回 表达式1， * 当 表达式1 为 null 时则返回 表达式2， * 简化了三目运算符方式 "表达式1?表达式1:表达式2"，如 "null?:false" 将返回 false，而 "true?:false" 将返回true； */@Testpublic void test18() &#123; int int1 = parser.parseExpression("true and false ? 1 : 0").getValue(Integer.class); Assert.assertEquals(0, int1); // 如果是 null, 返回 false Boolean bool1 = parser.parseExpression("null ?: false").getValue(Boolean.class); Assert.assertFalse(bool1); // true 不是 null, 返回 true Boolean bool2 = parser.parseExpression("true ?: false").getValue(Boolean.class); Assert.assertTrue(bool2); // 稍微复杂点 Inventor tesla = new Inventor("Nikola Tesla", "Serbian"); String name = parser.parseExpression("Name?:'Elvis Presley'").getValue(context, tesla, String.class); Assert.assertEquals("Nikola Tesla", name); // Nikola Tesla tesla.setName(null); name = parser.parseExpression("Name?:'Elvis Presley'").getValue(context, tesla, String.class); Assert.assertEquals("Elvis Presley", name); // Elvis Presley // 可以把Elivis运算表达式作为 默认值 例如 : @Value("#&#123;systemProperties['pop3.port'] ?: 25&#125;")&#125; 14. 安全的导航操作符安全导航操作符用于避免NullPointerException并来自Groovy语言。 通常，在引用对象时，可能需要在访问对象的方法或属性之前验证它是否为null。 为避免这种情况，安全导航操作符返回null而不是抛出异常。 以下示例显示如何使用安全导航运算符： 1234567891011121314151617/** * 安全的导航操作符： * 安全导航操作符用于避免NullPointerException，它来自Groovy语言。 * 通常，当您有一个对象的引用时，您可能需要在访问该对象的方法或属性之前验证它是否为null。为了避免这种情况，安全导航操作符返回null，而不是抛出异常。 */ @Test public void test19() &#123; Inventor tesla = new Inventor("Nikola Tesla", "Serbian"); tesla.setPlaceOfBirth(new PlaceOfBirth("Smiljan")); String city = parser.parseExpression("PlaceOfBirth?.City").getValue(context, tesla, String.class); Assert.assertEquals("Smiljan", city); // Smiljan tesla.setPlaceOfBirth(null); city = parser.parseExpression("PlaceOfBirth?.City").getValue(context, tesla, String.class); Assert.assertNull(city); // null - 没有抛出空指针异常(NullPointerException)!!! &#125; 15. 集合选择(Collection Selection)12345678910111213141516171819202122232425/** * 集合选择(Collection Selection)： * 选择表达式允许通过从源集合的条目中进行选择，将源集合转换为另一个集合。 * 选择表达式通过使用形如 ".?[selectionExpression]" 的语法。它筛选集合并返回包含原始元素子集的新集合。 */ @Test public void test20() &#123; society.getMembers().addAll(inventorList); context.setRootObject(society); // 从列表中选出国籍是美国的元素，然后组成新的列表 List&lt;Inventor&gt; list = (List&lt;Inventor&gt;) parser .parseExpression("Members.?[Nationality == '塞尔维亚裔美籍']") .getValue(context); Assert.assertEquals(1, list.size()); // 只有特斯拉是塞尔维亚裔美籍 // 从原字典中选出值大于27的元素，然后组成新的字典 Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); map.put("a", 26); map.put("b", 27); map.put("c", 28); context.setVariable("map", map); Map newMap = (Map) parser.parseExpression("#map.?[value&lt;27]").getValue(context); Assert.assertEquals(1, newMap.size()); &#125; 16. 集合投影(Collection Projection)12345678910111213/** * 集合投影: * 投影让集合驱动子表达式的求值，结果是一个新的集合。 * 投影的语法是 ".![projectionExpression]"。例如，假设我们有一个发明家列表，但是想要他们出生的城市列表。实际上，我们想要的是“出生地点”。 */ @Test public void test21() &#123; society.getMembers().addAll(inventorList); context.setRootObject(society); List&lt;String&gt; placesOfBirth = (List) parser.parseExpression("Members.![placeOfBirth.city]").getValue(context); MatcherAssert.assertThat(placesOfBirth, IsIterableContainingInOrder.contains("利卡-塞尼县", "米兰", "爱丁堡")); &#125; 17. 引用Spring Expression Language (SpEL) https://jinnianshilongnian.iteye.com/blog/1418309]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>spring-expression</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring-batch入门之CSV-to-DB]]></title>
    <url>%2Fpassages%2Fspring-batch%E5%85%A5%E9%97%A8%E4%B9%8BCSV-to-DB%2F</url>
    <content type="text"><![CDATA[学习使用Spring batch从CSV文件读取记录，并使用 StaxEventItemWriter 输出经过处理的记录转换为 XML 的数据。 JobLauncher： 顾名思义，该领域对象就是Job的启动器，其作用就是绑定一组JobParameters到Job上，然后运行该Job。 Job： 定义，配置批处理任务的领域对象，该对象的作用，第一是做Step的容器，配置该批处理任务需要的Step，以及他们之间的逻辑关系。第二是配置该批处理任务的特征，比方说名字，是否可重启，是否对JobParameters进行验证以及验证规则等。 Step： 定义批处理任务中一个对立的逻辑任务处理单元。基本上的业务逻辑处理代码都是封装在Step中的。Step有2种实现形式，一种是Tasklet形式的，这种形式非常自由，开发人员只需要实现Tasklet接口，其中的逻辑完全有自己决定，另一种是Chunk-Oriented形式的，这种形式定义了一个Step的流程必须是“读-处理（可选）-写”，当然Spring Batch也对每一个步骤提供了接口ItemReader， ItemProcessor，ItemWriter还有很多常用的默认实现（读文件，读数据库，写文件，写数据库等等）。 每一个Step只能由一个Tasklet或者一个Chunk构成。 JobRepository： 该领域对象会为Spring Batch的运维数据提供一种持久化机制。其为所有的运维数据的提供CRUD的操作接口，并为所有的操作提供事务支持。 项目概述在这个应用程序中，我们将执行以下任务: 使用 FlatFileItemReader 从CSV文件读取交易记录 使用 CustomItemProcessor 进行项目的业务处理。当 ItemReader 读取一个项目，而 ItemWriter 写入它们时，ItemProcessor 提供一个转换或应用其他业务处理的访问点。 使用 StaxEventItemWriter 获取 CustomItemProcessor 的处理结果，并将它转换成 XML 类型数据作为最终输出。 使用 MyBatisBatchItemWriter 获取 CustomItemProcessor 的处理结果，并将它转换成 XML 类型数据作为最终输出。 查看MySQL 工程结构 Maven 依赖sqlite-jdbc 和 mysql-connector-java 可以选择其中一个。当选择其中一种时，同时也要在 applicationContext.xml 文件中做出相应的改动。 改动: 依赖的版本由 platform-bom 来统一管理 添加 mybatis, mybatis-spring 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.littlefxc.example&lt;/groupId&gt; &lt;artifactId&gt;Spring-CSV-to-DB&lt;/artifactId&gt; &lt;version&gt;1.0-snapshot&lt;/version&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;spring.version&gt;5.0.9.RELEASE&lt;/spring.version&gt; &lt;spring.batch.version&gt;4.0.1.RELEASE&lt;/spring.batch.version&gt; &lt;sqlite.version&gt;3.8.11.2&lt;/sqlite.version&gt; &lt;mysql.version&gt;5.1.47&lt;/mysql.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;io.spring.platform&lt;/groupId&gt; &lt;artifactId&gt;platform-bom&lt;/artifactId&gt; &lt;version&gt;Cairo-RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- MySQL database driver --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- spring的XML文件处理依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-oxm&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.batch&lt;/groupId&gt; &lt;artifactId&gt;spring-batch-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; applicationContext.xml我们将使用 FlatFileItemReader 读取 CSV 文件。我们将使用它的标准配置，包括 DefaultLineMapper，DelimitedLineTokenizer 和 BeanWrapperFieldSetMapper 类。为了在XML文件中输出记录，我们将使用 StaxEventItemWriter 作为标准编写器。 改动： 将输出XML变为输出到mysql Spring Batch 持久层框架由 spring-jdbc 改为 mybatis, mybatis-spring 当然，原来的输出 itemWriter 去掉注释后，仍然起作用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:jdbc="http://www.springframework.org/schema/jdbc" xmlns:batch="http://www.springframework.org/schema/batch" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc.xsd http://www.springframework.org/schema/batch http://www.springframework.org/schema/batch/spring-batch.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt; &lt;context:property-placeholder location="classpath:application.properties"/&gt; &lt;context:component-scan base-package="com.littlefxc.examples.batch"/&gt; &lt;!-- 1. 数据库脚本：这里是为了方便起见保证每次重启程序数据库都是最新的（生产环境中不要这么做!!!） --&gt; &lt;jdbc:initialize-database&gt; &lt;jdbc:script location="$&#123;batch.schema-drop&#125;"/&gt; &lt;jdbc:script location="$&#123;batch.schema-create&#125;"/&gt; &lt;jdbc:script location="$&#123;project.schema-drop&#125;"/&gt; &lt;jdbc:script location="$&#123;project.schema-create&#125;"/&gt; &lt;/jdbc:initialize-database&gt; &lt;!-- 2. 连接数据库：可以选择其它的数据源实现 --&gt; &lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource" p:driverClassName="$&#123;jdbc.driver-class-name&#125;" p:url="$&#123;jdbc.url&#125;" p:username="$&#123;jdbc.username&#125;" p:password="$&#123;jdbc.password&#125;"/&gt; &lt;!-- 3. 事务管理 --&gt; &lt;!--&lt;bean id="transactionManager" class="org.springframework.batch.support.transactionRecord.ResourcelessTransactionManager"/&gt;--&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager" p:dataSource-ref="dataSource"/&gt; &lt;!-- 3.1 申明式事务 --&gt; &lt;tx:annotation-driven/&gt; &lt;!-- 3.2 mybatis 配置 --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean" p:dataSource-ref="dataSource" p:typeAliasesPackage="$&#123;mybatis.type-aliases-package&#125;" p:configLocation="$&#123;mybatis.configuration&#125;"/&gt; &lt;!-- 3.3 mybatis dao 配置 --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer" p:basePackage="com.littlefxc.examples.batch.dao" p:sqlSessionFactoryBeanName="sqlSessionFactory"/&gt; &lt;!-- 4. 为JobLauncher，Job和Step实现提供CRUD操作 --&gt; &lt;bean id="jobRepository" class="org.springframework.batch.core.repository.support.JobRepositoryFactoryBean" p:dataSource-ref="dataSource" p:transactionManager-ref="transactionManager" p:databaseType="mysql"/&gt; &lt;!-- 5. JobLauncher表示一个简单的接口，用于使用给定的 JobParameter 启动作业 --&gt; &lt;bean id="jobLauncher" class="org.springframework.batch.core.launch.support.SimpleJobLauncher" p:jobRepository-ref="jobRepository"/&gt; &lt;!-- 6. batch 输入 --&gt; &lt;bean id="itemReader" class="org.springframework.batch.item.file.FlatFileItemReader"&gt; &lt;!-- 输入资源 --&gt; &lt;property name="resource" value="input/record.csv"/&gt; &lt;!-- 不读取第一行数据 --&gt; &lt;property name="linesToSkip" value="1"/&gt; &lt;!-- 将输入资源转化为对象 --&gt; &lt;property name="lineMapper"&gt; &lt;bean class="org.springframework.batch.item.file.mapping.DefaultLineMapper"&gt; &lt;property name="lineTokenizer"&gt; &lt;bean class="org.springframework.batch.item.file.transform.DelimitedLineTokenizer"&gt; &lt;property name="names" value="username,user_id,transaction_date,transaction_amount"/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;property name="fieldSetMapper" ref="recordFieldSetMapper"/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 7. batch的处理器 --&gt; &lt;bean id="itemProcessor" class="com.littlefxc.examples.batch.service.CustomItemProcessor"/&gt; &lt;!-- 8. batch 输出:输出为xml --&gt; &lt;!--&lt;bean id="itemWriter" class="org.springframework.batch.item.xml.StaxEventItemWriter"&gt; &lt;property name="resource" value="file:xml/output.xml"/&gt; &lt;property name="marshaller"&gt; &amp;lt;!&amp;ndash; xml 与 对象的转换器 &amp;ndash;&amp;gt; &lt;bean class="org.springframework.oxm.jaxb.Jaxb2Marshaller" p:packagesToScan="com.littlefxc.examples.batch.model"/&gt; &lt;/property&gt; &lt;property name="rootTagName" value="transactionRecord"/&gt; &lt;/bean&gt;--&gt; &lt;!-- 8. batch 输出:输出到mysql --&gt; &lt;!--&lt;bean id="itemWriter" class="org.springframework.batch.item.database.JdbcBatchItemWriter" p:dataSource-ref="dataSource" p:sql="$&#123;batch.sql&#125;"&gt; &lt;property name="itemSqlParameterSourceProvider"&gt; &lt;bean class="org.springframework.batch.item.database.BeanPropertyItemSqlParameterSourceProvider"/&gt; &lt;/property&gt; &lt;/bean&gt;--&gt; &lt;!-- 8. batch 输出:使用 mybatis 输出到mysql --&gt; &lt;bean id="itemWriter" class="org.mybatis.spring.batch.MyBatisBatchItemWriter"&gt; &lt;property name="sqlSessionFactory" ref="sqlSessionFactory"/&gt; &lt;!-- 与 mybatis 关联的 dao 层的接口名：com.littlefxc.examples.batch.dao.TransactionRecordDao.insertTransactionRecord --&gt; &lt;property name="statementId" value="insertTransactionRecord"/&gt; &lt;/bean&gt; &lt;!-- 9. 配置batch的输入(6)、处理器(7)、输出(8) --&gt; &lt;!-- commit-interval:提交事务之前将处理的项目数。 --&gt; &lt;batch:job id="firstBatchJob"&gt; &lt;batch:step id="step1"&gt; &lt;batch:tasklet&gt; &lt;batch:chunk reader="itemReader" processor="itemProcessor" writer="itemWriter" commit-interval="2"/&gt; &lt;/batch:tasklet&gt; &lt;/batch:step&gt; &lt;/batch:job&gt;&lt;/beans&gt; RecordFieldSetMapperItemReader 的属性，作用是将 FieldSet 转换为对象 123456789101112131415161718192021222324252627282930313233package com.littlefxc.examples.batch.service;import com.littlefxc.examples.batch.model.TransactionRecord;import org.springframework.batch.item.file.mapping.FieldSetMapper;import org.springframework.batch.item.file.transform.FieldSet;import org.springframework.validation.BindException;import java.text.ParseException;import java.text.SimpleDateFormat;/** * 将 FieldSet 转换为对象 * @author fengxuechao * @date 2019/1/4 **/public class RecordFieldSetMapper implements FieldSetMapper&lt;Transaction&gt; &#123; public Transaction mapFieldSet(FieldSet fieldSet) throws BindException &#123; SimpleDateFormat dateFormat = new SimpleDateFormat("dd/MM/yyyy"); Transaction transactionRecord = new Transaction(); transactionRecord.setUsername(fieldSet.readString("username")); transactionRecord.setUserId(fieldSet.readInt("user_id")); transactionRecord.setAmount(fieldSet.readDouble("transaction_amount")); String dateString = fieldSet.readString("transaction_date"); try &#123; transactionRecord.setTransactionDate(dateFormat.parse(dateString)); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; return transactionRecord; &#125;&#125; CustomItemProcessor自定义实现接口 ItemProcessor, 作为 ItemReader 和 ItemWriter 的转换点。 123456789101112131415161718192021222324252627282930313233package com.littlefxc.examples.batch.service;import com.littlefxc.examples.batch.model.TransactionRecord;import org.springframework.batch.item.file.mapping.FieldSetMapper;import org.springframework.batch.item.file.transform.FieldSet;import org.springframework.validation.BindException;import java.text.ParseException;import java.text.SimpleDateFormat;/** * 将读取到的数据集合转换为对象 * @author fengxuechao * @date 2019/1/4 **/public class RecordFieldSetMapper implements FieldSetMapper&lt;Transaction&gt; &#123; public Transaction mapFieldSet(FieldSet fieldSet) throws BindException &#123; SimpleDateFormat dateFormat = new SimpleDateFormat("dd/MM/yyyy"); Transaction transactionRecord = new Transaction(); transactionRecord.setUsername(fieldSet.readString("username")); transactionRecord.setUserId(fieldSet.readInt("user_id")); transactionRecord.setAmount(fieldSet.readDouble("transaction_amount")); String dateString = fieldSet.readString("transaction_date"); try &#123; transactionRecord.setTransactionDate(dateFormat.parse(dateString)); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; return transactionRecord; &#125;&#125; 模型12345678910111213141516171819202122package com.littlefxc.examples.batch.model;import lombok.Data;import javax.xml.bind.annotation.XmlRootElement;import java.util.Date;/** * @author fengxuechao */@Data@XmlRootElement(name = "transactionRecord")public class Transaction &#123; private String username; private int userId; private Date transactionDate; private double amount;&#125; record.csv123devendra, 1234, 31/10/2015, 10000john , 2134, 3/12/2015 , 12321robin , 2134, 2/02/2015 , 23411 启动程序123456789101112131415161718192021222324252627package com.littlefxc.examples.batch;import org.springframework.batch.core.Job;import org.springframework.batch.core.JobExecution;import org.springframework.batch.core.JobParameters;import org.springframework.batch.core.launch.JobLauncher;import org.springframework.context.support.ClassPathXmlApplicationContext;public class App &#123; public static void main(String[] args) &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(); context.setConfigLocations("classpath:spring-context.xml"); context.refresh(); JobLauncher jobLauncher = (JobLauncher) context.getBean("jobLauncher"); Job job = (Job) context.getBean("firstBatchJob"); System.out.println("Starting the batch job"); try &#123; JobExecution execution = jobLauncher.run(job, new JobParameters()); System.out.println("Job Status : " + execution.getStatus()); System.out.println("Job completed"); &#125; catch (Exception e) &#123; e.printStackTrace(); System.out.println("Job failed"); &#125; &#125;&#125; 验证123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;transactionRecord&gt; &lt;transactionRecord&gt; &lt;amount&gt;10000.0&lt;/amount&gt; &lt;transactionDate&gt;2015-10-31T00:00:00+08:00&lt;/transactionDate&gt; &lt;userId&gt;1234&lt;/userId&gt; &lt;username&gt;devendra&lt;/username&gt; &lt;/transactionRecord&gt; &lt;transactionRecord&gt; &lt;amount&gt;12321.0&lt;/amount&gt; &lt;transactionDate&gt;2015-12-03T00:00:00+08:00&lt;/transactionDate&gt; &lt;userId&gt;2134&lt;/userId&gt; &lt;username&gt;john&lt;/username&gt; &lt;/transactionRecord&gt; &lt;transactionRecord&gt; &lt;amount&gt;23411.0&lt;/amount&gt; &lt;transactionDate&gt;2015-02-02T00:00:00+08:00&lt;/transactionDate&gt; &lt;userId&gt;2134&lt;/userId&gt; &lt;username&gt;robin&lt;/username&gt; &lt;/transactionRecord&gt;&lt;/transactionRecord&gt; 附录：application.properties123456789101112131415161718batch.schema-drop=org/springframework/batch/core/schema-drop-mysql.sqlbatch.schema-create=org/springframework/batch/core/schema-mysql.sqlbatch.sql=INSERT INTO transaction_record (user_id, username, transaction_date, amount) VALUES (:userId, :username, :transactionDate, :amount)jdbc.url=jdbc:mysql://192.168.120.63:3306/batch?useSSL=falsejdbc.username=rootjdbc.password=123456jdbc.driver-class-name=com.mysql.jdbc.Driver# 自定义数据库删除脚本project.schema-drop=classpath:schema-drop.sql# 自定义数据库创建脚本project.schema-create=classpath:schema.sql# Mybatis Configmybatis.configuration=classpath:mybatis-config.xmlmybatis.type-aliases-package=com.littlefxc.examples.batch.modelmybatis.mapper.base-package=com.littlefxc.examples.batch.dao mybatis-config.xml12345678910111213141516171819202122&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;settings&gt; &lt;setting name="cacheEnabled" value="true"/&gt; &lt;setting name="lazyLoadingEnabled" value="true"/&gt; &lt;setting name="multipleResultSetsEnabled" value="true"/&gt; &lt;setting name="useColumnLabel" value="true"/&gt; &lt;setting name="useGeneratedKeys" value="false"/&gt; &lt;setting name="autoMappingBehavior" value="PARTIAL"/&gt; &lt;setting name="autoMappingUnknownColumnBehavior" value="WARNING"/&gt; &lt;setting name="defaultExecutorType" value="SIMPLE"/&gt; &lt;setting name="defaultStatementTimeout" value="25"/&gt; &lt;setting name="defaultFetchSize" value="100"/&gt; &lt;setting name="safeRowBoundsEnabled" value="false"/&gt; &lt;setting name="mapUnderscoreToCamelCase" value="false"/&gt; &lt;setting name="localCacheScope" value="SESSION"/&gt; &lt;setting name="jdbcTypeForNull" value="OTHER"/&gt; &lt;setting name="lazyLoadTriggerMethods" value="equals,clone,hashCode,toString"/&gt; &lt;/settings&gt;&lt;/configuration&gt; schema.sql1234567891011121314151617181920212223242526272829303132/* Navicat Premium Data Transfer Source Server : localhost Source Server Type : MySQL Source Server Version : 50722 Source Host : localhost:3306 Source Schema : batch Target Server Type : MySQL Target Server Version : 50722 File Encoding : 65001 Date: 31/01/2019 10:27:20*/SET NAMES utf8mb4;SET FOREIGN_KEY_CHECKS = 0;-- ------------------------------ Table structure for transaction_record-- ----------------------------# DROP TABLE IF EXISTS `transaction_record`;CREATE TABLE `transaction_record` ( `username` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL, `user_id` bigint(20) NOT NULL, `transaction_date` datetime(6) NOT NULL, `amount` double(11, 0) NOT NULL, PRIMARY KEY (`username`) USING BTREE) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;SET FOREIGN_KEY_CHECKS = 1; schema-drop.sql1DROP TABLE IF EXISTS `transaction_record`;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>spring-batch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义spring-boot-starter]]></title>
    <url>%2Fpassages%2F%E8%87%AA%E5%AE%9A%E4%B9%89spring-boot-starter%2F</url>
    <content type="text"><![CDATA[自定义Starter:myQuartz-spring-boot-starter模仿学习Spring Boot starter写一个关于Quartz的自动配置的依赖。 1. 自定义Starter的模块结构 2. Maven 依赖配置自定义starter命名方式： 官方 spring-boot-starter-模块名 非官方（如我们自己编写的） 模块名-spring-boot-starter spring-boot-configuration-processor是2.x必须引入的包。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.littlefxc.examples&lt;/groupId&gt; &lt;artifactId&gt;myQuartz-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.0-snapshot&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.18.RELEASE&lt;/version&gt; &lt;relativePath /&gt; &lt;/parent&gt; &lt;properties&gt; &lt;quartz.version&gt;2.3.0&lt;/quartz.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- starter的基本配置 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;!-- quartz的基本配置 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt; &lt;artifactId&gt;quartz&lt;/artifactId&gt; &lt;version&gt;$&#123;quartz.version&#125;&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;artifactId&gt;HikariCP-java6&lt;/artifactId&gt; &lt;groupId&gt;com.zaxxer&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 3. 创建自动配置类QuartzAutoConfiguration构造函数隐式注入在4.3之前,如果你构造函数中要依赖另外一个bean，你必须显示依赖@Autowired, 例如: 12345678@Servicepublic class FooService &#123; private final FooRepository repository; @Autowired public FooService(FooRepository repository) &#123; this.repository = repository &#125;&#125; 相当常见的用例但是如果你忘记构造函数上的@Autowired注释，容器将抛出一个寻找默认构造函数的异常，除非你在bean定义设置中明确指出autowire模式’constructor’。 因此，从4.3开始，您不再需要在这样的单构造函数场景中指定显式注入注释。对于那些根本不带任何容器注释的类来说，这是特别优雅的，FooService会从beanFactory中查找FooRepository。 同样的，@Configuration类在4.3之前不支持构造函数注入。 为什么要使用ObjectProvider? 上文讲过构造函数隐式注入，但其有个缺点那就是强依赖。Spring Framework 4.3引入了ObjectProvider，它是现有ObjectFactory接口的扩展，具有方便的签名，例如getIfAvailable和getIfUnique，只有在它实际存在时才检索bean（可选支持）或者如果可以确定单个候选者（特别是：主要候选者）在多个匹配的bean的情况下）。它的Spring核心源码见org.springframework.beans.factory.support.DefaultListableBeanFactory#resolveDependency() ** 用到的几个和Starter相关的注解: @ConditionalOnClass，当classpath下发现该类的情况下进行自动配置。 @ConditionalOnMissingBean，当Spring Context中不存在该Bean时。 @EnableConfigurationProperties(QuartzProperties.class)，使@ConfigurationProperties注解生效。 @ConfigurationProperties，主要用来把properties配置文件转化为bean。 @AutoConfigureAfter，自动注入该类在什么类加载之后。 自定义Quartz的调度器工厂Bean的自动配置类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798@Configuration@ConditionalOnClass(&#123;Scheduler.class, SchedulerFactoryBean.class, PlatformTransactionManager.class&#125;)@EnableConfigurationProperties(QuartzProperties.class)@AutoConfigureAfter(&#123;DataSourceAutoConfiguration.class, HibernateJpaAutoConfiguration.class&#125;)public class QuartzAutoConfiguration &#123; private final static Logger log = LoggerFactory.getLogger(QuartzAutoConfiguration.class); private final List&lt;SchedulerFactoryBeanCustomizer&gt; customizers; private final QuartzProperties properties; private final JobDetail[] jobDetails; private final Map&lt;String, Calendar&gt; calendars; private final Trigger[] triggers; private final ApplicationContext applicationContext; private final DataSource dataSource; private final PlatformTransactionManager transactionManager; public QuartzAutoConfiguration(QuartzProperties properties, ObjectProvider&lt;List&lt;SchedulerFactoryBeanCustomizer&gt;&gt; customizers, ObjectProvider&lt;JobDetail[]&gt; jobDetails, ObjectProvider&lt;Map&lt;String, Calendar&gt;&gt; calendars, ObjectProvider&lt;Trigger[]&gt; triggers, ApplicationContext applicationContext, ObjectProvider&lt;DataSource&gt; dataSource, ObjectProvider&lt;PlatformTransactionManager&gt; transactionManager) &#123; this.properties = properties; this.jobDetails = jobDetails.getIfAvailable(); this.calendars = calendars.getIfAvailable(); this.triggers = triggers.getIfAvailable(); this.applicationContext = applicationContext; this.dataSource = dataSource.getIfAvailable(); this.transactionManager = transactionManager.getIfAvailable(); this.customizers = customizers.getIfAvailable(); &#125; /** * 如果没有调度器，就创建 * * @return */ @Bean @ConditionalOnMissingBean public SchedulerFactoryBean schedulerFactoryBean() &#123; log.info("Init SchedulerFactoryBean"); SchedulerFactoryBean schedulerFactoryBean = new SchedulerFactoryBean(); schedulerFactoryBean.setJobFactory(new AutoSchedulerJobFactory(this.applicationContext.getAutowireCapableBeanFactory())); if (!this.properties.getProperties().isEmpty()) &#123; schedulerFactoryBean.setQuartzProperties(asProperties(this.properties.getProperties())); &#125; if (this.jobDetails != null &amp;&amp; this.jobDetails.length &gt; 0) &#123; schedulerFactoryBean.setJobDetails(this.jobDetails); &#125; if (this.calendars != null &amp;&amp; !this.calendars.isEmpty()) &#123; schedulerFactoryBean.setCalendars(this.calendars); &#125; if (this.triggers != null &amp;&amp; this.triggers.length &gt; 0) &#123; schedulerFactoryBean.setTriggers(this.triggers); &#125; // todo quartz数据源初始化 if (properties.getJobStoreType() == JobStoreType.JDBC) &#123; if (dataSource != null) &#123; schedulerFactoryBean.setDataSource(dataSource); &#125; if (transactionManager != null) &#123; schedulerFactoryBean.setTransactionManager(transactionManager); &#125; &#125; customize(schedulerFactoryBean); return schedulerFactoryBean; &#125; /** * 自定义调度器 * * @param schedulerFactoryBean */ private void customize(SchedulerFactoryBean schedulerFactoryBean) &#123; if (this.customizers != null) &#123; for (SchedulerFactoryBeanCustomizer customizer : this.customizers) &#123; customizer.customize(schedulerFactoryBean); &#125; &#125; &#125; private Properties asProperties(Map&lt;String, String&gt; source) &#123; Properties properties = new Properties(); properties.putAll(source); return properties; &#125;&#125; 4. resources/META-INF/spring.factories12org.springframework.boot.autoconfigure.EnableAutoConfiguration=\com.littlefxc.examples.spring.boot.autoconfigure.QuartzAutoConfiguration 5. 其它QuartzProperties12345678910111213141516171819202122232425@ConfigurationProperties("spring.quartz")public class QuartzProperties &#123; /** * Quartz job store type. */ private JobStoreType jobStoreType = JobStoreType.MEMORY; /** * Additional Quartz Scheduler properties. */ private final Map&lt;String, String&gt; properties = new HashMap&lt;&gt;(); public JobStoreType getJobStoreType() &#123; return this.jobStoreType; &#125; public void setJobStoreType(JobStoreType jobStoreType) &#123; this.jobStoreType = jobStoreType; &#125; public Map&lt;String, String&gt; getProperties() &#123; return this.properties; &#125;&#125; JobStoreType12345678910111213public enum JobStoreType &#123; /** * Store jobs in memory. */ MEMORY, /** * Store jobs in the database. */ JDBC&#125; AutoSchedulerJobFactory1234567891011121314151617181920212223/** * 模仿了：&#123;@link org.springframework.boot.autoconfigure.quartz.AutowireCapableBeanJobFactory&#125; * * @author fengxuechao * @date 12/19/2018 * @see &lt;a href="http://blog.btmatthews.com/?p=40#comment-33797"&gt;注入Spring上下文(applicationContext) */public class AutoSchedulerJobFactory extends SpringBeanJobFactory &#123; private AutowireCapableBeanFactory beanFactory; AutoSchedulerJobFactory(AutowireCapableBeanFactory factory) &#123; beanFactory = factory; &#125; @Override protected Object createJobInstance(final TriggerFiredBundle bundle) throws Exception &#123; final Object job = super.createJobInstance(bundle); beanFactory.autowireBean(job); this.beanFactory.initializeBean(job, null); return job; &#125;&#125; SchedulerFactoryBeanCustomizer1234567891011121314/** * 回调接口，可以由希望在完全初始化之前自定义Quartz SchedulerFactoryBean的bean实现，特别是调整其配置。 * @author fengxuechao */@FunctionalInterfacepublic interface SchedulerFactoryBeanCustomizer &#123; /** * 自定义&#123;@link SchedulerFactoryBean&#125;. * @param schedulerFactoryBean the scheduler to customize */ void customize(SchedulerFactoryBean schedulerFactoryBean);&#125; 6. 测试6.1 项目结构新建项目,结构如下图所示： 6.2 Maven 依赖123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.littlefxc.examples&lt;/groupId&gt; &lt;artifactId&gt;test-autoconfigure&lt;/artifactId&gt; &lt;version&gt;1.0-snapshot&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;!--&lt;version&gt;2.0.4.RELEASE&lt;/version&gt;--&gt; &lt;version&gt;1.5.18.RELEASE&lt;/version&gt; &lt;relativePath /&gt; &lt;/parent&gt; &lt;properties&gt; &lt;quartz.version&gt;2.3.0&lt;/quartz.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.littlefxc.examples&lt;/groupId&gt; &lt;artifactId&gt;myQuartz-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.0-snapshot&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt; &lt;artifactId&gt;quartz-jobs&lt;/artifactId&gt; &lt;version&gt;$&#123;quartz.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 6.3 application.properties123456789101112131415161718192021222324252627282930313233343536logging.level.root=warnlogging.level.com.littlefxc.examples=debug# DataSource Configspring.datasource.url=jdbc:mysql://localhost:3306/learn-quartz?useSSL=falsespring.datasource.username=rootspring.datasource.password=123456spring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.type=com.alibaba.druid.pool.DruidDataSourcespring.datasource.druid.filters=slf4j,wallspring.datasource.druid.initial-size=1spring.datasource.druid.min-idle=1spring.datasource.druid.max-active=8spring.datasource.druid.max-wait=60000spring.datasource.druid.time-between-eviction-runs-millis=60000spring.datasource.druid.min-evictable-idle-time-millis=300000spring.datasource.druid.test-while-idle=truespring.datasource.druid.test-on-borrow=falsespring.datasource.druid.test-on-return=falsespring.datasource.druid.pool-prepared-statements=truespring.datasource.druid.max-pool-prepared-statement-per-connection-size=20# Quartz Configspring.quartz.job-store-type=jdbcspring.quartz.properties.org.quartz.scheduler.instanceName=schedulerFactoryBeanspring.quartz.properties.org.quartz.scheduler.instanceId=AUTOspring.quartz.properties.org.quartz.scheduler.instanceIdGenerator.class=com.littlefxc.examples.CustomQuartzInstanceIdGeneratorspring.quartz.properties.org.quartz.threadPool.threadCount=20spring.quartz.properties.org.quartz.jobStore.class=org.quartz.impl.jdbcjobstore.JobStoreTXspring.quartz.properties.org.quartz.jobStore.driverDelegateClass=org.quartz.impl.jdbcjobstore.StdJDBCDelegatespring.quartz.properties.org.quartz.jobStore.useProperties=truespring.quartz.properties.org.quartz.jobStore.misfireThreshold=60000spring.quartz.properties.org.quartz.jobStore.tablePrefix=qrtz_spring.quartz.properties.org.quartz.jobStore.isClustered=truespring.quartz.properties.org.quartz.plugin.shutdownHook.class=org.quartz.plugins.management.ShutdownHookPluginspring.quartz.properties.org.quartz.plugin.shutdownHook.cleanShutdown=TRUE 6.4 代码核心代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667@Slf4j@SpringBootApplicationpublic class TestAutoConfigure &#123; public static void main(String[] args) &#123; SpringApplication.run(TestAutoConfigure.class, args); &#125; @Bean public SchedulerFactoryBeanCustomizer dataSourceCustomizer() &#123; return (schedulerFactoryBean) -&gt; &#123; schedulerFactoryBean.setOverwriteExistingJobs(false); schedulerFactoryBean.setWaitForJobsToCompleteOnShutdown(true); schedulerFactoryBean.setStartupDelay(10); &#125;; &#125; /** * JobDetailFactoryBean * * @return */ @Bean public JobDetailFactoryBean jobDetailFactoryBean() &#123; JobDetailFactoryBean bean = new JobDetailFactoryBean(); bean.setName("job-1"); bean.setGroup("job-group-1"); bean.setJobClass(MyJob.class); JobDataMap jobDataMap = new JobDataMap(); jobDataMap.put("hello", "world"); bean.setJobDataMap(jobDataMap); bean.setDurability(true); return bean; &#125; /** * CronTriggerFactoryBean * * @param jobDetail * @return */ @Bean public CronTriggerFactoryBean cronTrigger(JobDetail jobDetail) &#123; CronTriggerFactoryBean bean = new CronTriggerFactoryBean(); bean.setName("cron-1"); bean.setGroup("cron-group-1"); bean.setCronExpression("0/5 * * * * ?"); bean.setJobDetail(jobDetail); return bean; &#125; /** * Job */ @Component public static class MyJob extends QuartzJobBean &#123; @Override protected void executeInternal(JobExecutionContext jobExecutionContext) throws JobExecutionException &#123; JobDetail jobDetail = jobExecutionContext.getJobDetail(); String jobName = jobDetail.getKey().getName(); String jobGroup = jobDetail.getKey().getGroup(); String jobDataMapHello = (String) jobDetail.getJobDataMap().get("hello"); log.info("job.name = &#123;&#125;, job.group = &#123;&#125;, job.dataMap.hello = &#123;&#125;", jobName, jobGroup, jobDataMapHello); &#125; &#125;&#125; CustomQuartzInstanceIdGenerator 123456789101112public class CustomQuartzInstanceIdGenerator implements InstanceIdGenerator &#123; @Override public String generateInstanceId() throws SchedulerException &#123; try &#123; return UUID.randomUUID().toString().replaceAll("-", ""); &#125; catch (Exception ex) &#123; throw new SchedulerException("Couldn't generate UUID!", ex); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>spring-boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring-boot-starter-quartz动态调度任务实现]]></title>
    <url>%2Fpassages%2Fspring-boot-starter-quartz%E5%8A%A8%E6%80%81%E8%B0%83%E5%BA%A6%E4%BB%BB%E5%8A%A1%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[1.项目结构 2.Maven12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.littlefxc&lt;/groupId&gt; &lt;artifactId&gt;learn-quartz-SpringBoot&lt;/artifactId&gt; &lt;version&gt;1.0-snapshot&lt;/version&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.4.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-quartz&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 3.数据库-模型在jar包quartz-2.3.0.jar下有数据库sql文件. sql文件的包路径地址：org.quartz.impl.jdbcjobstore，选择tables_mysql_innodb.sql 3.1. scheduler_job_info.sql123456789101112131415DROP TABLE IF EXISTS `scheduler_job_info`; CREATE TABLE `scheduler_job_info` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `cron_expression` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, `cron_job` bit(1) NULL DEFAULT NULL, `job_class` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, `job_group` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, `job_name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL, `scheduler_name` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL, `repeat_time` bigint(20) NULL DEFAULT NULL, PRIMARY KEY (`id`) USING BTREE, UNIQUE INDEX `uk_job_name`(`job_name`) USING BTREE ) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic; SET FOREIGN_KEY_CHECKS = 1; 3.2.实体类12345678910111213141516171819202122232425262728293031323334353637package com.littlefxc.example.quartz.enitiy; import lombok.Data; import javax.persistence.*; import java.io.Serializable; /** * @author fengxuechao * @date 12/19/2018 */ @Data @Entity @Table(name = "scheduler_job_info") public class SchedulerJob implements Serializable &#123; private static final long serialVersionUID = -8990533448070839127L; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(unique = true) private String jobName; private String jobGroup; private String jobClass; private String cronExpression; private Long repeatTime; private Boolean cronJob; private String schedulerName; &#125; 4.配置4.1.application.propertiescom.littlefxc.example.quartz.component.CustomQuartzInstanceIdGenerator表示使用自定义的实例名生成策略，该类代码可以在5.1章节中看到,在数据库上的代码实际效果可以查看到(表qrtz_scheduler_state, 字段INSTANCE_NAME)。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647spring.application.name=learn-quartz-SpringBoot # jackson Config spring.jackson.time-zone=GMT+8 spring.jackson.date-format=yyyy-MM-dd HH:mm:sss #spring.jackson.property-naming-strategy=SNAKE_CASE # DataSource Config spring.datasource.url=jdbc:mysql://localhost:3306/learn-quartz?useSSL=false spring.datasource.username=root spring.datasource.password=123456 spring.datasource.driver-class-name=com.mysql.jdbc.Driver spring.datasource.type=com.alibaba.druid.pool.DruidDataSource spring.datasource.druid.filters=slf4j,wall spring.datasource.druid.initial-size=1 spring.datasource.druid.min-idle=1 spring.datasource.druid.max-active=8 spring.datasource.druid.max-wait=60000 spring.datasource.druid.time-between-eviction-runs-millis=60000 spring.datasource.druid.min-evictable-idle-time-millis=300000 spring.datasource.druid.test-while-idle=true spring.datasource.druid.test-on-borrow=false spring.datasource.druid.test-on-return=false spring.datasource.druid.pool-prepared-statements=true spring.datasource.druid.max-pool-prepared-statement-per-connection-size=20 # JPA Config spring.jpa.hibernate.ddl-auto=update #spring.jpa.open-in-view=false spring.jpa.show-sql=true # Quartz Config spring.quartz.job-store-type=jdbc spring.quartz.jdbc.initialize-schema=never spring.quartz.properties.org.quartz.scheduler.instanceName=$&#123;spring.application.name&#125; spring.quartz.properties.org.quartz.scheduler.instanceId=AUTO spring.quartz.properties.org.quartz.scheduler.instanceIdGenerator.class=com.littlefxc.example.quartz.component.CustomQuartzInstanceIdGenerator spring.quartz.properties.org.quartz.threadPool.threadCount=20 spring.quartz.properties.org.quartz.jobStore.class=org.quartz.impl.jdbcjobstore.JobStoreTX spring.quartz.properties.org.quartz.jobStore.driverDelegateClass=org.quartz.impl.jdbcjobstore.StdJDBCDelegate spring.quartz.properties.org.quartz.jobStore.useProperties=true spring.quartz.properties.org.quartz.jobStore.misfireThreshold=60000 spring.quartz.properties.org.quartz.jobStore.tablePrefix=qrtz_ spring.quartz.properties.org.quartz.jobStore.isClustered=true spring.quartz.properties.org.quartz.plugin.shutdownHook.class=org.quartz.plugins.management.ShutdownHookPlugin spring.quartz.properties.org.quartz.plugin.shutdownHook.cleanShutdown=TRUE 4.2.自定义SchedulerFactoryBean创建SchedulerFactoryBean。黄色代码高亮处表示在SchedulerFactoryBean中注入Spring上下文(applicationContext)，该类(SchedulerJobFactory)可以在5.2章节中详细查看 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.littlefxc.example.quartz.config; import com.littlefxc.example.quartz.component.SchedulerJobFactory; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.autoconfigure.quartz.QuartzProperties; import org.springframework.context.ApplicationContext; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.scheduling.quartz.SchedulerFactoryBean; import javax.sql.DataSource; import java.util.Properties; /** * @author fengxuechao * @date 12/19/2018 */ @Configuration public class SchedulerConfig &#123; @Autowired private DataSource dataSource; @Autowired private ApplicationContext applicationContext; @Autowired private QuartzProperties quartzProperties; /** * create scheduler factory */ @Bean public SchedulerFactoryBean schedulerFactoryBean() &#123; SchedulerJobFactory jobFactory = new SchedulerJobFactory(); jobFactory.setApplicationContext(applicationContext); Properties properties = new Properties(); properties.putAll(quartzProperties.getProperties()); SchedulerFactoryBean factory = new SchedulerFactoryBean(); factory.setOverwriteExistingJobs(true); factory.setDataSource(dataSource); factory.setQuartzProperties(properties); factory.setJobFactory(jobFactory); return factory; &#125; &#125; 5.组件5.1.CustomQuartzInstanceIdGenerator用法详见4.1章节 1234567891011121314151617181920212223package com.littlefxc.example.quartz.component; import org.quartz.SchedulerException; import org.quartz.spi.InstanceIdGenerator; import java.util.UUID; /** * @author fengxuechao * @date 12/19/2018 */ public class CustomQuartzInstanceIdGenerator implements InstanceIdGenerator &#123; @Override public String generateInstanceId() throws SchedulerException &#123; try &#123; return UUID.randomUUID().toString(); &#125; catch (Exception ex) &#123; throw new SchedulerException("Couldn't generate UUID!", ex); &#125; &#125; &#125; 5.2.SchedulerJobFactoryQuartz与Spring结合。在SchedulerFactory中引入Spring上下文。用法详见4.2章节。 12345678910111213141516171819202122232425262728293031package com.littlefxc.example.quartz.component; import org.quartz.spi.TriggerFiredBundle; import org.springframework.beans.factory.config.AutowireCapableBeanFactory; import org.springframework.context.ApplicationContext; import org.springframework.context.ApplicationContextAware; import org.springframework.scheduling.quartz.SpringBeanJobFactory; /** * 模仿了：&#123;@link org.springframework.boot.autoconfigure.quartz.AutowireCapableBeanJobFactory&#125; * * @author fengxuechao * @date 12/19/2018 * @see &lt;a href="http://blog.btmatthews.com/?p=40#comment-33797"&gt;注入Spring上下文(applicationContext) */ public class SchedulerJobFactory extends SpringBeanJobFactory implements ApplicationContextAware &#123; private AutowireCapableBeanFactory beanFactory; @Override public void setApplicationContext(final ApplicationContext context) &#123; beanFactory = context.getAutowireCapableBeanFactory(); &#125; @Override protected Object createJobInstance(final TriggerFiredBundle bundle) throws Exception &#123; final Object job = super.createJobInstance(bundle); beanFactory.autowireBean(job); return job; &#125; &#125; 5.3.JobScheduleCreatorScheduler 创建Job，SimpleTrigger，CronTrigger的封装类。用法在service 层体现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100package com.littlefxc.example.quartz.component; import lombok.extern.slf4j.Slf4j; import org.quartz.CronTrigger; import org.quartz.JobDataMap; import org.quartz.JobDetail; import org.quartz.SimpleTrigger; import org.springframework.context.ApplicationContext; import org.springframework.scheduling.quartz.CronTriggerFactoryBean; import org.springframework.scheduling.quartz.JobDetailFactoryBean; import org.springframework.scheduling.quartz.QuartzJobBean; import org.springframework.scheduling.quartz.SimpleTriggerFactoryBean; import org.springframework.stereotype.Component; import java.text.ParseException; import java.util.Date; /** * Scheduler创建Job, SimpleTrigger, CronTrigger * * @author fengxuechao * @date 12/19/2018 * @see &lt;a href="https://blog.csdn.net/yangshangwei/article/details/78539433#withmisfirehandlinginstructiondonothing"&gt;Quartz-错过触发机制&lt;/a&gt; */ @Slf4j @Component public class JobScheduleCreator &#123; /** * Create Quartz Job. * * @param jobClass Class whose executeInternal() method needs to be called. * @param isDurable Job needs to be persisted even after completion. if true, job will be persisted, not otherwise. * @param context Spring application context. * @param jobName Job name. * @param jobGroup Job group. * @return JobDetail object */ public JobDetail createJob(Class&lt;? extends QuartzJobBean&gt; jobClass, boolean isDurable, ApplicationContext context, String jobName, String jobGroup) &#123; JobDetailFactoryBean factoryBean = new JobDetailFactoryBean(); factoryBean.setJobClass(jobClass); factoryBean.setDurability(isDurable); factoryBean.setApplicationContext(context); factoryBean.setName(jobName); factoryBean.setGroup(jobGroup); // set job data map JobDataMap jobDataMap = new JobDataMap(); jobDataMap.put(jobName + jobGroup, jobClass.getName()); factoryBean.setJobDataMap(jobDataMap); factoryBean.afterPropertiesSet(); return factoryBean.getObject(); &#125; /** * Create cron trigger. * * @param triggerName Trigger name. * @param startTime Trigger start time. * @param cronExpression Cron expression. * @param misFireInstruction Misfire instruction (what to do in case of misfire happens). * @return &#123;@link CronTrigger&#125; */ public CronTrigger createCronTrigger(String triggerName, Date startTime, String cronExpression, int misFireInstruction) &#123; CronTriggerFactoryBean factoryBean = new CronTriggerFactoryBean(); factoryBean.setName(triggerName); factoryBean.setStartTime(startTime); factoryBean.setCronExpression(cronExpression); factoryBean.setMisfireInstruction(misFireInstruction); try &#123; factoryBean.afterPropertiesSet(); &#125; catch (ParseException e) &#123; log.error(e.getMessage(), e); &#125; return factoryBean.getObject(); &#125; /** * Create simple trigger. * * @param triggerName Trigger name. * @param startTime Trigger start time. * @param repeatTime Job repeat period mills * @param misFireInstruction Misfire instruction (what to do in case of misfire happens). * @return &#123;@link SimpleTrigger&#125; */ public SimpleTrigger createSimpleTrigger(String triggerName, Date startTime, Long repeatTime, int misFireInstruction) &#123; SimpleTriggerFactoryBean factoryBean = new SimpleTriggerFactoryBean(); factoryBean.setName(triggerName); factoryBean.setStartTime(startTime); factoryBean.setRepeatInterval(repeatTime); factoryBean.setRepeatCount(SimpleTrigger.REPEAT_INDEFINITELY); factoryBean.setMisfireInstruction(misFireInstruction); factoryBean.afterPropertiesSet(); return factoryBean.getObject(); &#125; &#125; 6.Jobs这里的任务都是实现了org.quartz.Job这个接口 Simple Job1234567891011121314151617181920212223242526272829package com.littlefxc.example.quartz.jobs; import lombok.extern.slf4j.Slf4j; import org.quartz.JobExecutionContext; import org.quartz.JobExecutionException; import org.springframework.scheduling.quartz.QuartzJobBean; import java.util.stream.IntStream; /** * @author fengxuechao * @date 12/19/2018 */ @Slf4j public class SimpleJob extends QuartzJobBean &#123; @Override protected void executeInternal(JobExecutionContext context) throws JobExecutionException &#123; log.info("&#123;&#125; Start................", context.getJobDetail().getKey()); IntStream.range(0, 5).forEach(i -&gt; &#123; log.info("Counting - &#123;&#125;", i); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; log.error(e.getMessage(), e); &#125; &#125;); log.info("&#123;&#125; End................", context.getJobDetail().getKey()); &#125; &#125; Cron Job12345678910111213141516171819202122232425262728293031package com.littlefxc.example.quartz.jobs; import lombok.extern.slf4j.Slf4j; import org.quartz.DisallowConcurrentExecution; import org.quartz.JobExecutionContext; import org.quartz.JobExecutionException; import org.springframework.scheduling.quartz.QuartzJobBean; import java.util.stream.IntStream; /** * @author fengxuechao * @date 12/19/2018 */ @Slf4j @DisallowConcurrentExecution // 这个注解告诉Quartz，一个给定的Job定义（也就是一个JobDetail实例），不并发运行。 public class SampleCronJob extends QuartzJobBean &#123; @Override protected void executeInternal(JobExecutionContext context) throws JobExecutionException &#123; log.info("&#123;&#125; Start................", context.getJobDetail().getKey()); IntStream.range(0, 10).forEach(i -&gt; &#123; log.info("Counting - &#123;&#125;", i); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; log.error(e.getMessage(), e); &#125; &#125;); log.info("&#123;&#125; End................", context.getJobDetail().getKey()); &#125; &#125; 7.控制器层7.1.QuartzController工作调度的主要代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596package com.littlefxc.example.quartz.controller; import com.littlefxc.example.quartz.enitiy.SchedulerJob; import com.littlefxc.example.quartz.service.SchedulerService; import lombok.extern.slf4j.Slf4j; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.data.domain.Page; import org.springframework.data.domain.Pageable; import org.springframework.data.web.PageableDefault; import org.springframework.web.bind.annotation.*; import java.util.Map; /** * @author fengxuechao * @date 12/19/2018 **/ @RestController @RequestMapping("/job") @Slf4j public class QuartzController &#123; private final SchedulerService schedulerService; @Autowired public QuartzController(SchedulerService schedulerService) &#123; this.schedulerService = schedulerService; &#125; /** * 添加 * * @param jobInfo */ @PostMapping(value = "/addjob") public void addjob(@RequestBody SchedulerJob jobInfo) &#123; schedulerService.scheduleNewJob(jobInfo); &#125; /** * 暂停 * * @param jobName * @param jobGroup */ @PostMapping(value = "/pausejob") public void pausejob( @RequestParam String jobName, @RequestParam String jobGroup) &#123; schedulerService.pauseJob(jobName, jobGroup); &#125; /** * 恢复启动 * * @param jobName * @param jobGroup */ @PostMapping(value = "/resumejob") public void resumejob(@RequestParam String jobName, @RequestParam String jobGroup) &#123; schedulerService.resumeJob(jobName, jobGroup); &#125; /** * 更新：移除older trigger,添加new trigger * * @param jobInfo */ @PostMapping(value = "/reschedulejob") public void rescheduleJob(@RequestBody SchedulerJob jobInfo) &#123; schedulerService.updateScheduleJob(jobInfo); &#125; /** * 删除 * * @param jobName * @param jobGroup */ @PostMapping(value = "/deletejob") public void deletejob(@RequestParam String jobName, @RequestParam String jobGroup) &#123; schedulerService.deleteJob(jobName, jobGroup); &#125; /** * 查询 * * @param pageable * @param cron * @return */ @GetMapping(value = "/queryjob") public Page&lt;Map&lt;String, Object&gt;&gt; queryjob( @PageableDefault Pageable pageable, @RequestParam Boolean cron) &#123; return schedulerService.findAll(pageable, cron); &#125; &#125; 7.2.SchedulerController仅对自定义数据库(scheduler_job_info)操作的控制器。 12345678910111213141516171819202122232425262728293031package com.littlefxc.example.quartz.controller; import com.littlefxc.example.quartz.enitiy.SchedulerJob; import com.littlefxc.example.quartz.service.SchedulerService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.RestController; /** * @author fengxuechao * @date 12/20/2018 **/ @RestController @RequestMapping("/job-info") public class SchedulerController &#123; @Autowired private SchedulerService schedulerService; /** * 根据jobName查询 * @param jobName * @return &#123;@link SchedulerJob&#125; */ @GetMapping("/findOne") public SchedulerJob findOne(@RequestParam String jobName) &#123; return schedulerService.findOne(jobName); &#125; &#125; 8.Service层8.1.SchedulerServiceImpl123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249package com.littlefxc.example.quartz.service.impl; import com.littlefxc.example.quartz.component.JobScheduleCreator; import com.littlefxc.example.quartz.enitiy.SchedulerJob; import com.littlefxc.example.quartz.repository.SchedulerRepository; import com.littlefxc.example.quartz.service.SchedulerService; import lombok.extern.slf4j.Slf4j; import org.quartz.*; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.ApplicationContext; import org.springframework.data.domain.Page; import org.springframework.data.domain.Pageable; import org.springframework.scheduling.quartz.QuartzJobBean; import org.springframework.scheduling.quartz.SchedulerFactoryBean; import org.springframework.stereotype.Service; import org.springframework.transaction.annotation.Transactional; import java.util.Date; import java.util.List; import java.util.Map; /** * @author fengxuechao * @date 12/19/2018 */ @Slf4j @Transactional(rollbackFor = Exception.class) @Service public class SchedulerServiceImpl implements SchedulerService &#123; @Autowired private SchedulerFactoryBean schedulerFactoryBean; @Autowired private SchedulerRepository schedulerRepository; @Autowired private ApplicationContext context; @Autowired private JobScheduleCreator scheduleCreator; /** * 启动所有的在表scheduler_job_info中记录的job */ @Override public void startAllSchedulers() &#123; List&lt;SchedulerJob&gt; jobInfoList = schedulerRepository.findAll(); if (jobInfoList != null) &#123; Scheduler scheduler = schedulerFactoryBean.getScheduler(); jobInfoList.forEach(jobInfo -&gt; &#123; try &#123; JobDetail jobDetail = JobBuilder.newJob((Class&lt;? extends QuartzJobBean&gt;) Class.forName(jobInfo.getJobClass())) .withIdentity(jobInfo.getJobName(), jobInfo.getJobGroup()).build(); if (!scheduler.checkExists(jobDetail.getKey())) &#123; Trigger trigger; jobDetail = scheduleCreator.createJob((Class&lt;? extends QuartzJobBean&gt;) Class.forName(jobInfo.getJobClass()), false, context, jobInfo.getJobName(), jobInfo.getJobGroup()); if (jobInfo.getCronJob() &amp;&amp; CronExpression.isValidExpression(jobInfo.getCronExpression())) &#123; trigger = scheduleCreator.createCronTrigger(jobInfo.getJobName(), new Date(), jobInfo.getCronExpression(), CronTrigger.MISFIRE_INSTRUCTION_DO_NOTHING); &#125; else &#123; trigger = scheduleCreator.createSimpleTrigger(jobInfo.getJobName(), new Date(), jobInfo.getRepeatTime(), SimpleTrigger.MISFIRE_INSTRUCTION_RESCHEDULE_NEXT_WITH_REMAINING_COUNT); &#125; scheduler.scheduleJob(jobDetail, trigger); &#125; &#125; catch (ClassNotFoundException e) &#123; log.error("Class Not Found - &#123;&#125;", jobInfo.getJobClass(), e); &#125; catch (SchedulerException e) &#123; log.error(e.getMessage(), e); &#125; &#125;); &#125; &#125; @Override public void scheduleNewJob(SchedulerJob jobInfo) &#123; try &#123; Scheduler scheduler = schedulerFactoryBean.getScheduler(); JobDetail jobDetail = JobBuilder.newJob((Class&lt;? extends QuartzJobBean&gt;) Class.forName(jobInfo.getJobClass())) .withIdentity(jobInfo.getJobName(), jobInfo.getJobGroup()).build(); if (!scheduler.checkExists(jobDetail.getKey())) &#123; jobDetail = scheduleCreator.createJob((Class&lt;? extends QuartzJobBean&gt;) Class.forName(jobInfo.getJobClass()), false, context, jobInfo.getJobName(), jobInfo.getJobGroup()); Trigger trigger; if (jobInfo.getCronJob()) &#123; trigger = scheduleCreator.createCronTrigger(jobInfo.getJobName(), new Date(), jobInfo.getCronExpression(), CronTrigger.MISFIRE_INSTRUCTION_DO_NOTHING); &#125; else &#123; trigger = scheduleCreator.createSimpleTrigger(jobInfo.getJobName(), new Date(), jobInfo.getRepeatTime(), SimpleTrigger.MISFIRE_INSTRUCTION_RESCHEDULE_NEXT_WITH_REMAINING_COUNT); &#125; scheduler.scheduleJob(jobDetail, trigger); jobInfo.setSchedulerName(schedulerFactoryBean.getScheduler().getSchedulerName()); schedulerRepository.save(jobInfo); &#125; else &#123; log.error("scheduleNewJobRequest.jobAlreadyExist"); &#125; &#125; catch (ClassNotFoundException e) &#123; log.error("Class Not Found - &#123;&#125;", jobInfo.getJobClass(), e); &#125; catch (SchedulerException e) &#123; log.error(e.getMessage(), e); &#125; &#125; @Override public void updateScheduleJob(SchedulerJob jobInfo) &#123; Trigger newTrigger; if (jobInfo.getCronJob()) &#123; newTrigger = scheduleCreator.createCronTrigger(jobInfo.getJobName(), new Date(), jobInfo.getCronExpression(), CronTrigger.MISFIRE_INSTRUCTION_DO_NOTHING); &#125; else &#123; newTrigger = scheduleCreator.createSimpleTrigger(jobInfo.getJobName(), new Date(), jobInfo.getRepeatTime(), SimpleTrigger.MISFIRE_INSTRUCTION_RESCHEDULE_NEXT_WITH_REMAINING_COUNT); &#125; try &#123; schedulerFactoryBean.getScheduler().rescheduleJob(TriggerKey.triggerKey(jobInfo.getJobName()), newTrigger); jobInfo.setSchedulerName(schedulerFactoryBean.getScheduler().getSchedulerName()); schedulerRepository.save(jobInfo); &#125; catch (SchedulerException e) &#123; log.error(e.getMessage(), e); &#125; &#125; /** * unscheduleJob(TriggerKey triggerKey)只是不再调度触发器，所以，当其他的触发器引用了这个Job，它们不会被改变 * * @param jobName * @return */ @Override public boolean unScheduleJob(String jobName) &#123; try &#123; return schedulerFactoryBean.getScheduler().unscheduleJob(new TriggerKey(jobName)); &#125; catch (SchedulerException e) &#123; log.error("Failed to un-schedule job - &#123;&#125;", jobName, e); return false; &#125; &#125; /** * deleteJob(JobKey jobKey):&lt;br&gt; * 1.循环遍历所有引用此Job的触发器，以取消它们的调度(to unschedule them)&lt;br&gt; * 2.从jobstore中删除Job * * @param jobName job name * @param jobGroup job group * @return */ @Override public boolean deleteJob(String jobName, String jobGroup) &#123; try &#123; boolean deleteJob = schedulerFactoryBean.getScheduler().deleteJob(new JobKey(jobName, jobGroup)); if (deleteJob) &#123; SchedulerJob job = schedulerRepository.findSchedulerJobByJobName(jobName); schedulerRepository.delete(job); &#125; return deleteJob; &#125; catch (SchedulerException e) &#123; log.error("Failed to delete job - &#123;&#125;", jobName, e); return false; &#125; &#125; /** * 暂停 * * @param jobName job name * @param jobGroup job group * @return */ @Override public boolean pauseJob(String jobName, String jobGroup) &#123; try &#123; schedulerFactoryBean.getScheduler().pauseJob(new JobKey(jobName, jobGroup)); return true; &#125; catch (SchedulerException e) &#123; log.error("Failed to pause job - &#123;&#125;", jobName, e); return false; &#125; &#125; /** * 恢复 * * @param jobName job name * @param jobGroup job group * @return */ @Override public boolean resumeJob(String jobName, String jobGroup) &#123; try &#123; schedulerFactoryBean.getScheduler().resumeJob(new JobKey(jobName, jobGroup)); return true; &#125; catch (SchedulerException e) &#123; log.error("Failed to resume job - &#123;&#125;", jobName, e); return false; &#125; &#125; @Override public boolean startJobNow(String jobName, String jobGroup) &#123; try &#123; schedulerFactoryBean.getScheduler().triggerJob(new JobKey(jobName, jobGroup)); return true; &#125; catch (SchedulerException e) &#123; log.error("Failed to start new job - &#123;&#125;", jobName, e); return false; &#125; &#125; /** * 分页查询 * * @param pageable * @param cron true: cron trigger, false: simple trigger * @return */ @Transactional(readOnly = true)// 方法上注解属性会覆盖类注解上的相同属性 @Override public Page&lt;Map&lt;String, Object&gt;&gt; findAll(Pageable pageable, Boolean cron) &#123; if (cron) &#123; return schedulerRepository.getJobWithCronTrigger(pageable); &#125; else &#123; return schedulerRepository.getJobWithSimpleTrigger(pageable); &#125; &#125; /** * 根据jobName查询单条记录 * * @param jobName * @return */ @Transactional(readOnly = true) @Override public SchedulerJob findOne(String jobName) &#123; return schedulerRepository.findSchedulerJobByJobName(jobName); &#125; &#125; 9.Dao层9.1.SchedulerRepository123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990package com.littlefxc.example.quartz.repository; import com.littlefxc.example.quartz.enitiy.SchedulerJob; import org.springframework.data.domain.Page; import org.springframework.data.domain.Pageable; import org.springframework.data.jpa.repository.JpaRepository; import org.springframework.data.jpa.repository.Query; import org.springframework.stereotype.Repository; import java.util.Map; /** * @author fengxuechao * @date 12/19/2018 */ @Repository public interface SchedulerRepository extends JpaRepository&lt;SchedulerJob, Long&gt; &#123; /** * 仅查询simple trigger关联的Job * 不查询cron trigger关联的job * * @param pageable 分页信息 * @return */ @Query(value = "select " + "j.JOB_NAME, " + "j.JOB_GROUP, " + "j.JOB_CLASS_NAME, " + "t.TRIGGER_NAME, " + "t.TRIGGER_GROUP, " + "s.REPEAT_INTERVAL, " + "s.TIMES_TRIGGERED " + "from qrtz_job_details as j " + "join qrtz_triggers as t " + "join qrtz_simple_triggers as s ON j.JOB_NAME = t.JOB_NAME " + "and t.TRIGGER_NAME = s.TRIGGER_NAME " + "and t.TRIGGER_GROUP = s.TRIGGER_GROUP " + "where j.SCHED_NAME = 'schedulerFactoryBean' " + "order by ?#&#123;#pageable&#125;", countQuery = "select count(1) " + "from qrtz_job_details as j " + "join qrtz_triggers as t " + "join qrtz_cron_triggers as c ON j.JOB_NAME = t.JOB_NAME " + "and t.TRIGGER_NAME = c.TRIGGER_NAME " + "and t.TRIGGER_GROUP = c.TRIGGER_GROUP " + "where j.SCHED_NAME = 'schedulerFactoryBean' ", nativeQuery = true) Page&lt;Map&lt;String, Object&gt;&gt; getJobWithSimpleTrigger(Pageable pageable); /** * 仅查询cron trigger关联的Job * 不查询simple trigger关联的job * * @param pageable * @return */ @Query(value = "select " + "j.JOB_NAME, " + "j.JOB_GROUP, " + "j.JOB_CLASS_NAME, " + "t.TRIGGER_NAME, " + "t.TRIGGER_GROUP, " + "c.CRON_EXPRESSION, " + "c.TIME_ZONE_ID " + "from qrtz_job_details as j " + "join qrtz_triggers as t " + "join qrtz_cron_triggers as c ON j.JOB_NAME = t.JOB_NAME " + "and t.TRIGGER_NAME = c.TRIGGER_NAME " + "and t.TRIGGER_GROUP = c.TRIGGER_GROUP " + "where j.SCHED_NAME = 'schedulerFactoryBean' " + "order by ?#&#123;#pageable&#125;", countQuery = "select count(1) " + "from qrtz_job_details as j " + "join qrtz_triggers as t " + "join qrtz_cron_triggers as c ON j.JOB_NAME = t.JOB_NAME " + "and t.TRIGGER_NAME = c.TRIGGER_NAME " + "and t.TRIGGER_GROUP = c.TRIGGER_GROUP " + "where j.SCHED_NAME = 'schedulerFactoryBean' ", nativeQuery = true) Page&lt;Map&lt;String, Object&gt;&gt; getJobWithCronTrigger(Pageable pageable); /** * 根据JobName查询SchedulerJob * * @param jobName * @return SchedulerJob */ SchedulerJob findSchedulerJobByJobName(String jobName); &#125; 10.网页Vue+ElementUI实现10.1.simple.html仅对Simple Trigger管理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;QuartzDemo&lt;/title&gt; &lt;link rel="stylesheet" href="https://unpkg.com/element-ui/lib/theme-chalk/index.css"&gt; &lt;script src="https://unpkg.com/vue/dist/vue.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.bootcss.com/vue-resource/1.5.1/vue-resource.js"&gt;&lt;/script&gt; &lt;script src="https://unpkg.com/element-ui/lib/index.js"&gt;&lt;/script&gt; &lt;style&gt; #top &#123; background: #20A0FF; padding: 5px; overflow: hidden &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="test"&gt; &lt;a href="cron.html"&gt;goto simple.html&lt;/a&gt; &lt;div id="top"&gt; &lt;el-button type="text" @click="search" style="color:white"&gt;查询&lt;/el-button&gt; &lt;el-button type="text" @click="handleadd" style="color:white"&gt;添加&lt;/el-button&gt; &lt;/span&gt; &lt;/div&gt; &lt;br/&gt; &lt;div style="margin-top:15px"&gt; &lt;el-table ref="testTable" :data="tableData" style="width:100%" border &gt; &lt;el-table-column prop="JOB_NAME" label="任务名称" sortable show-overflow-tooltip&gt; &lt;/el-table-column&gt; &lt;el-table-column prop="JOB_GROUP" label="任务所在组" sortable&gt; &lt;/el-table-column&gt; &lt;el-table-column prop="JOB_CLASS_NAME" label="任务类名" sortable&gt; &lt;/el-table-column&gt; &lt;el-table-column prop="TRIGGER_NAME" label="触发器名称" sortable&gt; &lt;/el-table-column&gt; &lt;el-table-column prop="TRIGGER_GROUP" label="触发器所在组" sortable&gt; &lt;/el-table-column&gt; &lt;el-table-column prop="REPEAT_INTERVAL" label="触发间隔(毫秒)" sortable&gt; &lt;/el-table-column&gt; &lt;el-table-column prop="TIMES_TRIGGERED" label="已触发次数" sortable&gt; &lt;/el-table-column&gt; &lt;el-table-column label="操作" width="300"&gt; &lt;template scope="scope"&gt; &lt;el-button size="small" type="warning" @click="handlePause(scope.$index, scope.row)"&gt;暂停 &lt;/el-button&gt; &lt;el-button size="small" type="info" @click="handleResume(scope.$index, scope.row)"&gt;恢复 &lt;/el-button&gt; &lt;el-button size="small" type="danger" @click="handleDelete(scope.$index, scope.row)"&gt;删除 &lt;/el-button&gt; &lt;el-button size="small" type="success" @click="handleUpdate(scope.$index, scope.row)"&gt;修改 &lt;/el-button&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;div align="center"&gt; &lt;el-pagination @size-change="handleSizeChange" @current-change="handleCurrentChange" :current-page="currentPage" :page-sizes="[10, 20, 30, 40]" :page-size="pagesize" layout="total, sizes, prev, pager, next, jumper" :total="totalCount"&gt; &lt;/el-pagination&gt; &lt;/div&gt; &lt;/div&gt; &lt;el-dialog title="添加任务" :visible.syn="dialogFormVisible"&gt; &lt;el-form :model="form"&gt; &lt;el-form-item label="任务名称" label-width="120px" style="width:35%"&gt; &lt;el-input v-model="form.jobName" auto-complete="off"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label="任务分组" label-width="120px" style="width:35%"&gt; &lt;el-input v-model="form.jobGroup" auto-complete="off"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label="任务类名" label-width="120px" style="width:35%"&gt; &lt;el-input v-model="form.jobClass" auto-complete="off"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label="触发器类型" label-width="120px" style="width:35%"&gt; &lt;el-switch v-model="form.cronJob" active-color="#13ce66" inactive-color="#ff4949" active-text="cron" inactive-text="simple"&gt; &lt;/el-switch&gt; &lt;/el-form-item&gt; &lt;el-form-item label="表达式" v-show="form.cronJob" label-width="120px" style="width:35%"&gt; &lt;el-input v-model="form.cronExpression" auto-complete="off"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label="触发间隔(毫秒)" v-show="!form.cronJob" label-width="120px" style="width:35%"&gt; &lt;el-input v-model="form.repeatTime" auto-complete="off"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;div slot="footer" class="dialog-footer"&gt; &lt;el-button @click="dialogFormVisible = false"&gt;取 消&lt;/el-button&gt; &lt;el-button type="primary" @click="add"&gt;确 定&lt;/el-button&gt; &lt;/div&gt; &lt;/el-dialog&gt; &lt;el-dialog title="修改任务" :visible.syn="updateFormVisible"&gt; &lt;el-form :model="updateform"&gt; &lt;el-form-item label="任务名称" label-width="120px" style="width:35%"&gt; &lt;el-input v-model="updateform.jobName" auto-complete="off"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label="任务分组" label-width="120px" style="width:35%"&gt; &lt;el-input v-model="updateform.jobGroup" auto-complete="off"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label="任务类名" label-width="120px" style="width:35%"&gt; &lt;el-input v-model="updateform.jobClass" auto-complete="off"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label="触发器类型" label-width="120px" style="width:35%"&gt; &lt;el-switch v-model="updateform.cronJob" active-color="#13ce66" inactive-color="#ff4949" active-text="cron" inactive-text="simple"&gt; &lt;/el-switch&gt; &lt;/el-form-item&gt; &lt;el-form-item label="表达式" v-show="updateform.cronJob" label-width="120px" style="width:35%"&gt; &lt;el-input v-model="updateform.cronExpression" auto-complete="off"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label="触发间隔(毫秒)" v-show="!updateform.cronJob" label-width="120px" style="width:35%"&gt; &lt;el-input v-model="updateform.repeatTime" auto-complete="off"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;div slot="footer" class="dialog-footer"&gt; &lt;el-button @click="updateFormVisible = false"&gt;取 消&lt;/el-button&gt; &lt;el-button type="primary" @click="update"&gt;确 定&lt;/el-button&gt; &lt;/div&gt; &lt;/el-dialog&gt; &lt;/div&gt; &lt;footer align="center"&gt; &lt;p&gt;© Quartz 任务管理&lt;/p&gt; &lt;/footer&gt; &lt;script&gt; var vue = new Vue(&#123; el: "#test", data: &#123; //表格当前页数据 tableData: [], //请求的URL url: '', //默认每页数据量 pagesize: 10, //当前页码 currentPage: 1, //查询的页码 start: 1, //默认数据总数 totalCount: 1000, //添加对话框默认可见性 dialogFormVisible: false, //修改对话框默认可见性 updateFormVisible: false, //提交的表单 form: &#123; jobName: '', jobGroup: '', jobClass: '', cronJob: false, repeatTime: 0, cronExpression: '' &#125;, // 修改的表单 updateform: &#123; id: 0, jobName: '', jobGroup: '', jobClass: '', cronJob: false, repeatTime: 0, cronExpression: '' &#125;, &#125;, methods: &#123; //从服务器读取数据 loadData: function (pageNum, pageSize) &#123; this.$http.get('job/queryjob?cron=false&amp;' + 'page=' + pageNum + '&amp;size=' + pageSize).then(function (res) &#123; console.log(res); this.tableData = res.body.content; this.totalCount = res.body.numberOfElements; &#125;, function () &#123; console.log('failed'); &#125;); &#125;, //单行删除 handleDelete: function (index, row) &#123; this.$http.post('job/deletejob', &#123; "jobName": row.JOB_NAME, "jobGroup": row.JOB_GROUP &#125;, &#123;emulateJSON: true&#125;).then(function (res) &#123; this.loadData(this.currentPage, this.pagesize); &#125;, function () &#123; console.log('failed'); &#125;); &#125;, //暂停任务 handlePause: function (index, row) &#123; this.$http.post('job/pausejob', &#123; "jobName": row.JOB_NAME, "jobGroup": row.JOB_GROUP &#125;, &#123;emulateJSON: true&#125;).then(function (res) &#123; this.loadData(this.currentPage, this.pagesize); &#125;, function () &#123; console.log('failed'); &#125;); &#125;, //恢复任务 handleResume: function (index, row) &#123; this.$http.post('job/resumejob', &#123; "jobName": row.JOB_NAME, "jobGroup": row.JOB_GROUP &#125;, &#123;emulateJSON: true&#125;).then(function (res) &#123; this.loadData(this.currentPage, this.pagesize); &#125;, function () &#123; console.log('failed'); &#125;); &#125;, //搜索 search: function () &#123; this.loadData(this.currentPage, this.pagesize); &#125;, //弹出对话框 handleadd: function () &#123; this.dialogFormVisible = true; &#125;, //添加 add: function () &#123; this.$http.post('job/addjob', this.form, &#123; headers: &#123;'Content-Type': "application/json;charset=utf-8"&#125; &#125;).then(function (res) &#123; this.loadData(this.currentPage, this.pagesize); this.dialogFormVisible = false; &#125;, function () &#123; console.log('failed'); &#125;); &#125;, //更新 handleUpdate: function (index, row) &#123; console.log(row); this.updateFormVisible = true; this.updateform.jobName = row.JOB_NAME; this.updateform.jobGroup = row.JOB_GROUP; this.updateform.jobClass = row.JOB_CLASS_NAME; this.updateform.cronJob = false; this.updateform.repeatTime = row.REPEAT_INTERVAL; this.$http.get('job-info/findOne?jobName=' + row.JOB_NAME).then(function (res) &#123; this.updateform.id = res.body.id; this.updateform.cronExpression = row.cronExpression; &#125;, function () &#123; console.log('failed'); &#125;); console.log(this.updateform) &#125;, //更新任务 update: function () &#123; this.$http.post('job/reschedulejob', this.updateform, &#123; headers: &#123;'Content-Type': "application/json;charset=utf-8"&#125; &#125;).then(function (res) &#123; this.loadData(this.currentPage, this.pagesize); this.updateFormVisible = false; &#125;, function () &#123; console.log('failed'); &#125;); &#125;, //每页显示数据量变更 handleSizeChange: function (val) &#123; this.pagesize = val; this.loadData(this.currentPage, this.pagesize); &#125;, //页码变更 handleCurrentChange: function (val) &#123; this.currentPage = val; this.loadData(this.currentPage, this.pagesize); &#125;, &#125;, &#125;); //载入数据 vue.loadData(vue.currentPage, vue.pagesize); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 10.2.cron.html进队Cron Trigger 管理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;QuartzDemo&lt;/title&gt; &lt;link rel="stylesheet" href="https://unpkg.com/element-ui/lib/theme-chalk/index.css"&gt; &lt;script src="https://unpkg.com/vue/dist/vue.js"&gt;&lt;/script&gt; &lt;script src="http://cdn.bootcss.com/vue-resource/1.3.4/vue-resource.js"&gt;&lt;/script&gt; &lt;script src="https://unpkg.com/element-ui/lib/index.js"&gt;&lt;/script&gt; &lt;style&gt; #top &#123; background: #20A0FF; padding: 5px; overflow: hidden &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="test"&gt; &lt;a href="simple.html"&gt;goto cron.html&lt;/a&gt; &lt;div id="top"&gt; &lt;el-button type="text" @click="search" style="color:white"&gt;查询&lt;/el-button&gt; &lt;el-button type="text" @click="handleadd" style="color:white"&gt;添加&lt;/el-button&gt; &lt;/span&gt; &lt;/div&gt; &lt;br/&gt; &lt;div style="margin-top:15px"&gt; &lt;el-table ref="testTable" :data="tableData" style="width:100%" border &gt; &lt;el-table-column prop="JOB_NAME" label="任务名称" sortable show-overflow-tooltip&gt; &lt;/el-table-column&gt; &lt;el-table-column prop="JOB_GROUP" label="任务所在组" sortable&gt; &lt;/el-table-column&gt; &lt;el-table-column prop="JOB_CLASS_NAME" label="任务类名" sortable&gt; &lt;/el-table-column&gt; &lt;el-table-column prop="TRIGGER_NAME" label="触发器名称" sortable&gt; &lt;/el-table-column&gt; &lt;el-table-column prop="TRIGGER_GROUP" label="触发器所在组" sortable&gt; &lt;/el-table-column&gt; &lt;el-table-column prop="CRON_EXPRESSION" label="表达式" sortable&gt; &lt;/el-table-column&gt; &lt;el-table-column prop="TIME_ZONE_ID" label="时区" sortable&gt; &lt;/el-table-column&gt; &lt;el-table-column label="操作" width="300"&gt; &lt;template scope="scope"&gt; &lt;el-button size="small" type="warning" @click="handlePause(scope.$index, scope.row)"&gt;暂停 &lt;/el-button&gt; &lt;el-button size="small" type="info" @click="handleResume(scope.$index, scope.row)"&gt;恢复 &lt;/el-button&gt; &lt;el-button size="small" type="danger" @click="handleDelete(scope.$index, scope.row)"&gt;删除 &lt;/el-button&gt; &lt;el-button size="small" type="success" @click="handleUpdate(scope.$index, scope.row)"&gt;修改 &lt;/el-button&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;div align="center"&gt; &lt;el-pagination @size-change="handleSizeChange" @current-change="handleCurrentChange" :current-page="currentPage" :page-sizes="[10, 20, 30, 40]" :page-size="pagesize" layout="total, sizes, prev, pager, next, jumper" :total="totalCount"&gt; &lt;/el-pagination&gt; &lt;/div&gt; &lt;/div&gt; &lt;el-dialog title="添加任务" :visible.syn="dialogFormVisible"&gt; &lt;el-form :model="form"&gt; &lt;el-form-item label="任务名称" label-width="120px" style="width:35%"&gt; &lt;el-input v-model="form.jobName" auto-complete="off"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label="任务分组" label-width="120px" style="width:35%"&gt; &lt;el-input v-model="form.jobGroup" auto-complete="off"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label="任务类名" label-width="120px" style="width:35%"&gt; &lt;el-input v-model="form.jobClass" auto-complete="off"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label="触发器类型" label-width="120px" style="width:35%"&gt; &lt;el-switch v-model="form.cronJob" active-color="#13ce66" inactive-color="#ff4949" active-text="cron" inactive-text="simple"&gt; &lt;/el-switch&gt; &lt;/el-form-item&gt; &lt;el-form-item label="表达式" v-show="form.cronJob" label-width="120px" style="width:35%"&gt; &lt;el-input v-model="form.cronExpression" auto-complete="off"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label="触发间隔(毫秒)" v-show="!form.cronJob" label-width="120px" style="width:35%"&gt; &lt;el-input v-model="form.repeatTime" auto-complete="off"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;div slot="footer" class="dialog-footer"&gt; &lt;el-button @click="dialogFormVisible = false"&gt;取 消&lt;/el-button&gt; &lt;el-button type="primary" @click="add"&gt;确 定&lt;/el-button&gt; &lt;/div&gt; &lt;/el-dialog&gt; &lt;el-dialog title="修改任务" :visible.syn="updateFormVisible"&gt; &lt;el-form :model="updateform"&gt; &lt;el-form-item label="任务名称" label-width="120px" style="width:35%"&gt; &lt;el-input v-model="updateform.jobName" auto-complete="off"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label="任务分组" label-width="120px" style="width:35%"&gt; &lt;el-input v-model="updateform.jobGroup" auto-complete="off"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label="任务类名" label-width="120px" style="width:35%"&gt; &lt;el-input v-model="updateform.jobClass" auto-complete="off"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label="触发器类型" label-width="120px" style="width:35%"&gt; &lt;el-switch v-model="updateform.cronJob" active-color="#13ce66" inactive-color="#ff4949" active-text="cron" inactive-text="simple"&gt; &lt;/el-switch&gt; &lt;/el-form-item&gt; &lt;el-form-item label="表达式" v-show="updateform.cronJob" label-width="120px" style="width:35%"&gt; &lt;el-input v-model="updateform.cronExpression" auto-complete="off"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label="触发间隔(毫秒)" v-show="!updateform.cronJob" label-width="120px" style="width:35%"&gt; &lt;el-input v-model="updateform.repeatTime" auto-complete="off"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;div slot="footer" class="dialog-footer"&gt; &lt;el-button @click="updateFormVisible = false"&gt;取 消&lt;/el-button&gt; &lt;el-button type="primary" @click="update"&gt;确 定&lt;/el-button&gt; &lt;/div&gt; &lt;/el-dialog&gt; &lt;/div&gt; &lt;footer align="center"&gt; &lt;p&gt;© Quartz 任务管理&lt;/p&gt; &lt;/footer&gt; &lt;script&gt; var vue = new Vue(&#123; el: "#test", data: &#123; //表格当前页数据 tableData: [], //请求的URL url: 'job/queryjob', //默认每页数据量 pagesize: 10, //当前页码 currentPage: 1, //查询的页码 start: 1, //默认数据总数 totalCount: 1000, //添加对话框默认可见性 dialogFormVisible: false, //修改对话框默认可见性 updateFormVisible: false, //提交的表单 form: &#123; jobName: '', jobGroup: '', jobClass: '', cronJob: true, repeatTime: 0, cronExpression: '' &#125;, // 修改的表单 updateform: &#123; id: 0, jobName: '', jobGroup: '', jobClass: '', cronJob: true, repeatTime: 0, cronExpression: '' &#125;, &#125;, methods: &#123; //从服务器读取数据 loadData: function (pageNum, pageSize) &#123; this.$http.get('job/queryjob?cron=true&amp;' + 'page=' + pageNum + '&amp;size=' + pageSize).then(function (res) &#123; console.log(res); this.tableData = res.body.content; this.totalCount = res.body.numberOfElements; &#125;, function () &#123; console.log('failed'); &#125;); &#125;, //单行删除 handleDelete: function (index, row) &#123; this.$http.post('job/deletejob', &#123; "jobName": row.JOB_NAME, "jobGroup": row.JOB_GROUP &#125;, &#123;emulateJSON: true&#125;).then(function (res) &#123; this.loadData(this.currentPage, this.pagesize); &#125;, function () &#123; console.log('failed'); &#125;); &#125;, //暂停任务 handlePause: function (index, row) &#123; this.$http.post('job/pausejob', &#123; "jobName": row.JOB_NAME, "jobGroup": row.JOB_GROUP &#125;, &#123;emulateJSON: true&#125;).then(function (res) &#123; this.loadData(this.currentPage, this.pagesize); &#125;, function () &#123; console.log('failed'); &#125;); &#125;, //恢复任务 handleResume: function (index, row) &#123; this.$http.post('job/resumejob', &#123; "jobName": row.JOB_NAME, "jobGroup": row.JOB_GROUP &#125;, &#123;emulateJSON: true&#125;).then(function (res) &#123; this.loadData(this.currentPage, this.pagesize); &#125;, function () &#123; console.log('failed'); &#125;); &#125;, //搜索 search: function () &#123; this.loadData(this.currentPage, this.pagesize); &#125;, //弹出对话框 handleadd: function () &#123; this.dialogFormVisible = true; &#125;, //添加 add: function () &#123; this.$http.post('job/addjob', this.form, &#123; headers: &#123;'Content-Type': "application/json;charset=utf-8"&#125; &#125;).then(function (res) &#123; this.loadData(this.currentPage, this.pagesize); this.dialogFormVisible = false; &#125;, function () &#123; console.log('failed'); &#125;); &#125;, //更新 handleUpdate: function (index, row) &#123; console.log(row); this.updateFormVisible = true; this.updateform.jobName = row.JOB_NAME; this.updateform.jobGroup = row.JOB_GROUP; this.updateform.jobClass = row.JOB_CLASS_NAME; this.updateform.cronJob = true; this.updateform.cronExpression = row.CRON_EXPRESSION; this.$http.get('job-info/findOne?jobName=' + row.JOB_NAME).then(function (res) &#123; this.updateform.id = res.body.id; this.updateform.repeatTime = res.body.repeatTime; &#125;, function () &#123; console.log('failed'); &#125;); console.log(this.updateform) &#125;, //更新任务 update: function () &#123; this.$http.post('job/reschedulejob', this.updateform, &#123; headers: &#123;'Content-Type': "application/json;charset=utf-8"&#125; &#125;).then(function (res) &#123; this.loadData(this.currentPage, this.pagesize); this.updateFormVisible = false; &#125;, function () &#123; console.log('failed'); &#125;); &#125;, //每页显示数据量变更 handleSizeChange: function (val) &#123; this.pagesize = val; this.loadData(this.currentPage, this.pagesize); &#125;, //页码变更 handleCurrentChange: function (val) &#123; this.currentPage = val; this.loadData(this.currentPage, this.pagesize); &#125;, &#125;, &#125;); //载入数据 vue.loadData(vue.currentPage, vue.pagesize); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 11. 引用https://blog.csdn.net/u012907049/article/details/73801122https://blog.csdn.net/yangshangwei/article/details/78539433#withmisfirehandlinginstructiondonothinghttp://blog.btmatthews.com/?p=40#comment-33797https://www.baeldung.com/spring-quartz-schedule]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>spring-boot</tag>
        <tag>定时调度器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring-boot启动流程]]></title>
    <url>%2Fpassages%2Fspring-boot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[spring-boot启动流程SpringApplication的run方法的实现是我们本次旅程的主要线路，该方法的主要流程大体可以归纳如下： 如果我们使用的是SpringApplication的静态run方法，那么，这个方法里面首先要创建一个SpringApplication对象实例，然后调用这个创建好的SpringApplication的实例方法。在SpringApplication实例初始化的时候，它会提前做几件事情：根据classpath里面是否存在某个特征类org.springframework.web.context.ConfigurableWebApplicationContext来决定是否应该创建一个为Web应用使用的ApplicationContext类型。使用SpringFactoriesLoader在应用的classpath中查找并加载所有可用的ApplicationContextInitializer。使用SpringFactoriesLoader在应用的classpath中查找并加载所有可用的ApplicationListener。推断并设置main方法的定义类。 12345678910111213141516public class SpringApplication &#123; // ... public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) &#123; this.resourceLoader = resourceLoader; Assert.notNull(primarySources, "PrimarySources must not be null"); this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources)); this.webApplicationType = deduceWebApplicationType(); // 查找并加载所有可用的ApplicationContextInitializer setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class)); // 查找并加载所有可用的ApplicationListener setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); this.mainApplicationClass = deduceMainApplicationClass(); &#125;&#125; SpringApplication实例初始化完成并且完成设置后，就开始执行run方法的逻辑了，方法执行伊始，首先遍历执行所有通过SpringFactoriesLoader可以查找到并加载的SpringApplicationRunListener。调用它们的started()方法，告诉这些SpringApplicationRunListener，“嘿，SpringBoot应用要开始执行咯！”。 创建并配置当前Spring Boot应用将要使用的Environment（包括配置要使用的PropertySource以及Profile）。 遍历调用所有SpringApplicationRunListener的environmentPrepared()的方法，告诉他们：“当前SpringBoot应用使用的Environment准备好了咯！”。 如果SpringApplication的showBanner属性被设置为true，则打印banner。 根据用户是否明确设置了applicationContextClass类型以及初始化阶段的推断结果，决定该为当前SpringBoot应用创建什么类型的ApplicationContext并创建完成，然后根据条件决定是否添加ShutdownHook，决定是否使用自定义的BeanNameGenerator，决定是否使用自定义的ResourceLoader，当然，最重要的，将之前准备好的Environment设置给创建好的ApplicationContext使用。 ApplicationContext创建好之后，SpringApplication会再次借助SpringFactoriesLoader，查找并加载classpath中所有可用的ApplicationContextInitializer，然后遍历调用这些ApplicationContextInitializer的initialize(applicationContext)方法来对已经创建好的ApplicationContext进行进一步的处理。 遍历调用所有SpringApplicationRunListener的contextPrepared()方法。 最核心的一步，将之前通过@EnableAutoConfiguration获取的所有配置以及其他形式的IoC容器配置加载到已经准备完毕的ApplicationContext。 遍历调用所有SpringApplicationRunListener的contextLoaded()方法。 调用ApplicationContext的refresh()方法，完成IoC容器可用的最后一道工序。 查找当前ApplicationContext中是否注册有CommandLineRunner，如果有，则遍历执行它们。 正常情况下，遍历执行SpringApplicationRunListener的finished()方法、（如果整个过程出现异常，则依然调用所有SpringApplicationRunListener的finished()方法，只不过这种情况下会将异常信息一并传入处理） Spring 源码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public ConfigurableApplicationContext run(String... args) &#123; StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList&lt;&gt;(); configureHeadlessProperty(); // SpringFactoriesLoader =&gt; META-INF/spring.factories SpringApplicationRunListeners listeners = getRunListeners(args); listeners.starting(); try &#123; ApplicationArguments applicationArguments = new DefaultApplicationArguments( args); // 环境配置 None(非WEB), Servlet, Reactive(响应式) ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); configureIgnoreBeanInfo(environment); // Banner Banner printedBanner = printBanner(environment); context = createApplicationContext(); exceptionReporters = getSpringFactoriesInstances( SpringBootExceptionReporter.class, new Class[] &#123; ConfigurableApplicationContext.class &#125;, context); prepareContext(context, environment, listeners, applicationArguments, printedBanner); // IOC容器的最后一步 refreshContext(context); afterRefresh(context, applicationArguments); stopWatch.stop(); if (this.logStartupInfo) &#123; new StartupInfoLogger(this.mainApplicationClass) .logStarted(getApplicationLog(), stopWatch); &#125; listeners.started(context); // 查找 CommandLineRunner, ApplicationRunner, ... callRunners(context, applicationArguments); &#125; catch (Throwable ex) &#123; handleRunFailure(context, ex, exceptionReporters, listeners); throw new IllegalStateException(ex); &#125; try &#123; listeners.running(context); &#125; catch (Throwable ex) &#123; handleRunFailure(context, ex, exceptionReporters, null); throw new IllegalStateException(ex); &#125; return context;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>spring-boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring-boot中注解@EnableAutoConfiguration的解析]]></title>
    <url>%2Fpassages%2Fspring-boot%E4%B8%AD%E6%B3%A8%E8%A7%A3-EnableAutoConfiguration%E7%9A%84%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[个人感觉@EnableAutoConfiguration这个Annotation最为重要，Spring框架有提供的各种名字为@Enable开头的Annotation定义，比如@EnableScheduling、@EnableCaching、@EnableMBeanExport等，@EnableAutoConfiguration的理念和做事方式其实一脉相承，简单概括一下就是，借助@Import的支持… 个人感觉@EnableAutoConfiguration这个Annotation最为重要，Spring框架有提供的各种名字为@Enable开头的Annotation定义，比如@EnableScheduling、@EnableCaching、@EnableMBeanExport等，@EnableAutoConfiguration的理念和做事方式其实一脉相承，简单概括一下就是，借助@Import的支持，收集和注册特定场景相关的bean定义。 又例如： @EnableScheduling是通过@Import将Spring调度框架相关的bean定义都加载到IoC容器。 @EnableMBeanExport是通过@Import将JMX相关的bean定义加载到IoC容器。 而@EnableAutoConfiguration也是借助@Import的帮助，将所有符合自动配置条件的bean定义加载到IoC容器，仅此而已！ @EnableAutoConfiguration作为一个复合Annotation,其自身定义关键信息如下： 其中，最关键的要属@Import(EnableAutoConfigurationImportSelector.class)，借助EnableAutoConfigurationImportSelector，@EnableAutoConfiguration可以帮助SpringBoot应用将所有符合条件的@Configuration配置都加载到当前SpringBoot创建并使用的IoC容器。 借助于Spring框架原有的一个工具类：SpringFactoriesLoader的支持，@EnableAutoConfiguration可以智能的自动配置功效才得以大功告成！ 自动配置幕后英雄：SpringFactoriesLoader详解 SpringFactoriesLoader属于Spring框架私有的一种扩展方案，其主要功能就是从指定的配置文件META-INF/spring.factories加载配置。1234567891011public abstract class SpringFactoriesLoader &#123; //... public static &lt;T&gt; List&lt;T&gt; loadFactories(Class&lt;T&gt; factoryClass, ClassLoader classLoader) &#123; ... &#125; public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, ClassLoader classLoader) &#123; .... &#125; &#125; 配合@EnableAutoConfiguration使用的话，它更多是提供一种配置查找的功能支持，即根据@EnableAutoConfiguration的完整类名org.springframework.boot.autoconfigure.EnableAutoConfiguration作为查找的Key,获取对应的一组@Configuration类 上图就是从SpringBoot的autoconfigure依赖包中的META-INF/spring.factories配置文件中摘录的一段内容，可以很好地说明问题。所以，@EnableAutoConfiguration自动配置就是：从classpath中搜寻所有的META-INF/spring.factories配置文件，并将其中org.springframework.boot.autoconfigure.EnableutoConfiguration对应的配置项通过反射（Java Refletion）实例化为对应的标注了@Configuration的JavaConfig形式的IoC容器配置类，然后汇总为一个并加载到IoC容器。 注：@Conditional派生注解（Spring注解版原生的@Conditional作用） 作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效； 注解 作用 @Conditional扩展注解 作用（判断是否满足当前指定条件） @ConditionalOnJava 系统的java版本是否符合要求 @ConditionalOnBean 容器中存在指定Bean @ConditionalOnMissingBean 容器中不存在指定Bean @ConditionalOnExpression 满足SpEL表达式指定 @ConditionalOnClass 系统中有指定的类 @ConditionalOnMissingClass 系统中没有指定的类 @ConditionalOnSingleCandidate 容器中只有一个指定的Bean，或者这个Bean是首选Bean @ConditionalOnProperty 系统中指定的属性是否有指定的值 @ConditionalOnResource 类路径下是否存在指定资源文件 @ConditionalOnWebApplication 当前是web环境 @ConditionalOnNotWebApplication 当前不是web环境 @ConditionalOnJndi JNDI存在指定项]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>spring-boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring-boot使用atomikos实现分布式事务]]></title>
    <url>%2Fpassages%2Fspring-boot%E4%BD%BF%E7%94%A8atomikos%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[Java规范对分布式事务定义了标准的规范Java事务API和Java事务服务，分别是JTA和JTS一个分布式事务必须包括一个事务管理器和多个资源管理器。 资源管理器是任意类型的持久化数据存储；而事务管理器则是承担着所有事务参与单元者的相互通讯的责任。 JTA的规范制定了分布式事务的实现的整套流程框架，定义了各个接口且只有接口，而实现分别交给事务管理器的实现方和资源管理器的实现方 1.前言Java规范对分布式事务定义了标准的规范Java事务API和Java事务服务，分别是JTA和JTS一个分布式事务必须包括一个事务管理器和多个资源管理器。 资源管理器是任意类型的持久化数据存储；而事务管理器则是承担着所有事务参与单元者的相互通讯的责任。 JTA的规范制定了分布式事务的实现的整套流程框架，定义了各个接口且只有接口，而实现分别交给事务管理器的实现方和资源管理器的实现方 对于资源管理器而言，主要包括数据库连接，JMS等，还有很多了解的不清楚。 对于事务管理器而言，从网上了解主要是应用服务器，包括JBOSS，WEBLOGIC等应用服务器，也就是说事务管理器的实现方是应用服务器，用来管理事务的通讯和协调。对于大多数谈的数据库了解，事务管理器需要从数据库获得XAConnection , XAResource等对象，而这些对象是数据库驱动程序需要提供的，所以如果要实现分布式事务还必须有支持分布式事务的数据库服务器以及数据库驱动程序。 对Mysql而言，在mysql5.0以上的版本已经支持了分布式事务，另外常用的mysql-connector-java-5.1.25-bin.jar也是支持分布式事务的，可以在jar包的com.mysql.jdbc.jdbc2.optional中找到XA对象的实现上面介绍了事务管理器和资源管理器的实现方式，在学习研究过程中发现对于事务管理器，特别强调了tomcat等服务器是不支持的，这句话的意思应该是在tomcat容器内并没有分布式事务管理器的实现对象。而在JBOSS或者WEBLOGIC等商业服务器应该内置了分布式事务管理器的实现对象，应用程序可以通过JNDI方式获取UserTransaction和TransactionManager等分布式事务环境中所需要用到的对象。 通常，应用程序服务器（Application Server）提供了应用程序可以使用的多种服务。在谈到分布式事务时，该服务就称作 XA Resource。当然，在应用程序可以使用 XA Resource 之前，首先要在应用程序服务器中注册和配置 XA Resource。 事务管理器作为管理和协调分布式事务的关键处理中心非常重要，所以应用服务器可以单独只用过事务管理器。 2.在SpringBoot中使用分布式事务上面主要是一些基本的概念，在学习研究中总结出来的，可能不太全面，下面主要介绍一下在使用Spring使用分布式事务中的心得，这种做法也是将事务管理器嵌入应用中。 开始准备Spring的时候，Spring官网-SpringBoot文档第38章介绍了Atomikos和Bitronix 等工具，实际上这些工具都是取代应用服务器对事务管理器的支持，负责实现事务管理器对象。由于Atomikos介绍在Bitronix 之前，所以直接使用Atomikos进行测试。 2.1.盲点解释要理解 JTA 的实现原理首先需要了解其架构：它包括事务管理器（Transaction Manager）和一个或多个支持 XA 协议的资源管理器 ( Resource Manager ) 两部分， 我们可以将资源管理器看做任意类型的持久化数据存储；事务管理器则承担着所有事务参与单元的协调与控制。 根据所面向对象的不同，我们可以将 JTA 的事务管理器和资源管理器理解为两个方面：面向开发人员的使用接口（事务管理器）和面向服务提供商的实现接口（资源管理器）。其中开发接口的主要部分即为上述示例中引用的 UserTransaction 对象，开发人员通过此接口在信息系统中实现分布式事务；而实现接口则用来规范提供商（如数据库连接提供商）所提供的事务服务，它约定了事务的资源管理功能，使得 JTA 可以在异构事务资源之间执行协同沟通。以数据库为例，IBM 公司提供了实现分布式事务的数据库驱动程序，Oracle 也提供了实现分布式事务的数据库驱动程序， 在同时使用 DB2 和 Oracle 两种数据库连接时， JTA 即可以根据约定的接口协调者两种事务资源从而实现分布式事务。正是基于统一规范的不同实现使得 JTA 可以协调与控制不同数据库或者 JMS 厂商的事务资源，其架构如下图所示：图 2.1 JTA体系结构 开发人员使用开发人员接口，实现应用程序对全局事务的支持；各提供商（数据库，JMS 等）依据提供商接口的规范提供事务资源管理功能；事务管理器（ TransactionManager ）将应用对分布式事务的使用映射到实际的事务资源并在事务资源间进行协调与控制。 下面，本文将对包括 UserTransaction、Transaction 和 TransactionManager 在内的三个主要接口以及其定义的方法进行介绍。 UserTransaction:面向开发人员的接口,开发人员通常只使用此接口实现 JTA 事务管理 Transaction:代表了一个物理意义上的事务 TransactionManager:本身并不承担实际的事务处理功能，它更多的是充当用户接口和实现接口之间的桥梁 UserTransaction 对象不会对事务进行任何控制，所有的事务方法都是通过 TransactionManager 传递到实际的事务资源即 Transaction 对象上 2.2.确保mysql开启XA事务支持1SHOW VARIABLES LIKE '%xa%' 如果innodb_support_xa的值是ON就说明mysql已经开启对XA事务的支持了。如果不是就执行： 1SET innodb_support_xa = ON 2.3.重要Maven依赖1234567891011121314151617181920212223&lt;!-- 数据库连接 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 分布式事务atomikos --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jta-atomikos&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Druid --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MyBatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; 2.4.配置Atomikos, Druid, MyBatis首先，要使下面的代码配置生效要先确保你在项目工程中引入了spring-boot-starter-jta-atomikos, druid-spring-boot-starter这两个依赖。第二，SpringBoot会自动配置Atomikos的事务管理配置，无需做其它的配置。 2.4.1.application.properties第15-19行代码表示实现javax.sql.XADataSource接口的com.alibaba.druid.pool.xa.DruidXADataSource的特有属性, 并不是Atomikos的属性. 123456789101112131415161718192021222324252627282930313233343536spring.application.name=learn-jta-atomikos# 开启下划线-驼峰命名转换mybatis.configuration.map-underscore-to-camel-case=truespring.aop.proxy-target-class=true## jta相关参数配置# 如果你在JTA环境中，并且仍然希望使用本地事务，你可以设置spring.jta.enabled属性为false以禁用JTA自动配置。spring.jta.enabled=true# 必须配置唯一的资源名spring.jta.atomikos.datasource.one.unique-resource-name=jta-personal# 配置Druid的属性 https://github.com/alibaba/druid/wiki/DruidDataSource%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%E5%88%97%E8%A1%A8spring.jta.atomikos.datasource.one.xa-data-source-class-name=com.alibaba.druid.pool.xa.DruidXADataSourcespring.jta.atomikos.datasource.one.xa-properties.url=jdbc:mysql://localhost:3306/personal?characterEncoding=utf-8&amp;useSSL=false&amp;allowMultiQueries=truespring.jta.atomikos.datasource.one.xa-properties.username=rootspring.jta.atomikos.datasource.one.xa-properties.password=123456spring.jta.atomikos.datasource.one.xa-properties.filters=slf4j,stat,wall,config#spring.jta.atomikos.datasource.one.xa-properties.connectionProperties=config.decrypt=true;config.decrypt.key=$&#123;druid.publickey&#125;spring.jta.atomikos.datasource.two.unique-resource-name=jta-bookspring.jta.atomikos.datasource.two.max-pool-size=8spring.jta.atomikos.datasource.two.xa-data-source-class-name=com.alibaba.druid.pool.xa.DruidXADataSourcespring.jta.atomikos.datasource.two.xa-properties.url=jdbc:mysql://localhost:3306/secondary?characterEncoding=utf-8&amp;useSSL=false&amp;&amp;allowMultiQueries=truespring.jta.atomikos.datasource.two.xa-properties.username=rootspring.jta.atomikos.datasource.two.xa-properties.password=123456spring.jta.atomikos.datasource.two.xa-properties.filters=slf4j,stat,wall,config#spring.jta.atomikos.datasource.two.xa-properties.connectionProperties=config.decrypt=true;config.decrypt.key=$&#123;druid.publickey&#125;## Druid监控设置spring.datasource.druid.web-stat-filter.exclusions=*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*spring.datasource.druid.stat-view-servlet.url-pattern=/druid/*spring.datasource.druid.stat-view-servlet.reset-enable=truespring.datasource.druid.stat-view-servlet.login-username=adminspring.datasource.druid.stat-view-servlet.login-password=adminspring.datasource.druid.aop-patterns=com.example.atomikos.service.* 2.4.2.配置Atomikos数据源与MyBatis集成这里只给出默认数据源的Atomikos与MyBatis的集成，其余的数据源的配置与它大同小异(见第2.5章实例)。注意！第18行代码，这里指定com.example.atomikos.dao.one这个包路径下Mapper接口的MyBatis的会话工厂，不同的数据源指定不同的会话工厂！！！然后在使用dao层的时候，正常使用即可，详细代码见(见第2.5章实例)。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.example.atomikos.config;import com.atomikos.jdbc.AtomikosDataSourceBean;import org.apache.ibatis.session.SqlSessionFactory;import org.mybatis.spring.SqlSessionFactoryBean;import org.mybatis.spring.annotation.MapperScan;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Primary;import javax.sql.DataSource;/** * 设置JTA(Atomikos)数据源，Mybatis * * @author fengxuechao */@Configuration@MapperScan(basePackages = "com.example.atomikos.dao.one", sqlSessionFactoryRef = "oneSqlSessionFactory")public class OneDatabaseConfig &#123; /** * 设置JTA(Atomikos)数据源 * * @return &#123;@link AtomikosDataSourceBean&#125; */ @Primary @Bean @ConfigurationProperties(prefix = "spring.jta.atomikos.datasource.one") public DataSource oneDataSource() &#123; return new AtomikosDataSourceBean(); &#125; /** * 设置Mybatis的会话工厂类 * * @param dataSource JTA(Atomikos)数据源 * @return &#123;@link SqlSessionFactoryBean#getObject()&#125; * @throws Exception */ @Primary @Bean(name = "oneSqlSessionFactory") public SqlSessionFactory oneSqlSessionFactory(DataSource dataSource) throws Exception &#123; SqlSessionFactoryBean bean = new SqlSessionFactoryBean(); bean.setDataSource(dataSource); return bean.getObject(); &#125;&#125; 2.4.3.配置声明式事务(tx+aop)Java配置声明式事务AOP 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import org.springframework.aop.Advisor; import org.springframework.aop.aspectj.AspectJExpressionPointcut; import org.springframework.aop.support.DefaultPointcutAdvisor; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.transaction.PlatformTransactionManager; import org.springframework.transaction.TransactionDefinition; import org.springframework.transaction.interceptor.*; import java.util.Collections; import java.util.HashMap; import java.util.Map; /** * 配置声明式事务 切面拦截 * * @author fengxuechao */ @Configuration public class TransactionConfig &#123; private static final int TX_METHOD_TIMEOUT = 5; private static final String AOP_POINTCUT_EXPRESSION = "execution (* com.example.atomikos.service.*.*(..))"; @Autowired private PlatformTransactionManager transactionManager; @Bean public TransactionInterceptor txAdvice() &#123; NameMatchTransactionAttributeSource source = new NameMatchTransactionAttributeSource(); /* 只读事务，不做更新操作 */ RuleBasedTransactionAttribute readOnlyTx = new RuleBasedTransactionAttribute(); readOnlyTx.setReadOnly(true); readOnlyTx.setPropagationBehavior(TransactionDefinition.PROPAGATION_SUPPORTS); /* 当前存在事务就使用当前事务，当前不存在事务就创建一个新的事务 */ RuleBasedTransactionAttribute requiredTx = new RuleBasedTransactionAttribute(); requiredTx.setRollbackRules(Collections.singletonList(new RollbackRuleAttribute(Exception.class))); requiredTx.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED); requiredTx.setTimeout(TX_METHOD_TIMEOUT); Map&lt;String, TransactionAttribute&gt; txMap = new HashMap&lt;&gt;(10); txMap.put("add*", requiredTx); txMap.put("save*", requiredTx); txMap.put("insert*", requiredTx); txMap.put("update*", requiredTx); txMap.put("delete*", requiredTx); txMap.put("get*", readOnlyTx); txMap.put("query*", readOnlyTx); txMap.put("list*", readOnlyTx); txMap.put("find*", readOnlyTx); source.setNameMap(txMap); return new TransactionInterceptor(transactionManager, source); &#125; /** * 切点 * * @return */ @Bean public Advisor txAdviceAdvisor() &#123; AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut(); pointcut.setExpression(AOP_POINTCUT_EXPRESSION); return new DefaultPointcutAdvisor(pointcut, txAdvice()); &#125; &#125; 等同于下面的Spring XML配置 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt; &lt;!-- 配置事务传播特性 --&gt; &lt;tx:advice id="txAdvice"&gt; &lt;tx:attributes&gt; &lt;!-- name ：绑定事务的方法名，可以使用通配符，可以配置多个。 propagation ：传播行为 isolation ：隔离级别 read-only ：是否只读 timeout ：超时信息 rollback-for：发生哪些异常回滚. no-rollback-for：发生哪些异常不回滚. --&gt; &lt;!-- 哪些方法加事务 --&gt; &lt;tx:method name="query*" propagation="SUPPORTS" read-only="true"/&gt; &lt;tx:method name="get*" propagation="SUPPORTS" read-only="true"/&gt; &lt;tx:method name="select*" propagation="SUPPORTS" read-only="true"/&gt; &lt;tx:method name="list*" propagation="SUPPORTS" read-only="true"/&gt; &lt;tx:method name="save*" propagation="REQUIRED" rollback-for="Exception"/&gt; &lt;tx:method name="update*" propagation="REQUIRED" rollback-for="Exception"/&gt; &lt;tx:method name="delete*" propagation="REQUIRED" rollback-for="Exception"/&gt; &lt;tx:method name="add*" propagation="REQUIRED" rollback-for="Exception"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;aop:config&gt; &lt;!-- 注意：如果是自己编写的切面，使用&lt;aop:aspect&gt;标签，如果是系统制作的，使用&lt;aop:advisor&gt;标签。 --&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut="execution (* com.example.atomikos.service.*.*(..))" order="0" /&gt; &lt;/aop:config&gt; &lt;/beans&gt; 2.5.实例2.5.1.项目结构 2.5.2.数据库personal.sql 123456789101112131415create table if not exists article ( id bigint unsigned auto_increment primary key, content varchar(255) null, title varchar(255) null, url varchar(255) null ); create table if not exists user ( id bigint unsigned auto_increment primary key, username varchar(255) charset utf8 null, password varchar(255) charset utf8 null ); secondary.sql 1234567create table book ( id bigint unsigned auto_increment primary key, name varchar(255) null, article_id bigint unsigned null, user_id bigint unsigned null ); 2.5.3.Maven依赖123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;learn-jta-atomikos-SpringBoot&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;learn-jta-atomikos&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- MyBatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!-- 热部署 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 数据库连接 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 分布式事务atomikos --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jta-atomikos&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- tx + aop --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加Log4j2 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 为log4j2添加异步支持 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.lmax&lt;/groupId&gt; &lt;artifactId&gt;disruptor&lt;/artifactId&gt; &lt;version&gt;3.4.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 简化代码 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 用于监控与管理 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!-- WEB --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 配合@ConfigurationProperties编译生成元数据文件(IDEA编辑器的属性提示) --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;!-- 测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; 2.5.4.配置application.properties123456789101112131415161718192021222324252627282930313233343536spring.application.name=learn-jta-atomikos # 开启下划线-驼峰命名转换 mybatis.configuration.map-underscore-to-camel-case=true spring.aop.proxy-target-class=true ## jta相关参数配置 # 如果你在JTA环境中，并且仍然希望使用本地事务，你可以设置spring.jta.enabled属性为false以禁用JTA自动配置。 spring.jta.enabled=true # 必须配置唯一的资源名 spring.jta.atomikos.datasource.one.unique-resource-name=jta-personal # 配置Druid的属性 https://github.com/alibaba/druid/wiki/DruidDataSource%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%E5%88%97%E8%A1%A8 spring.jta.atomikos.datasource.one.xa-data-source-class-name=com.alibaba.druid.pool.xa.DruidXADataSource spring.jta.atomikos.datasource.one.xa-properties.url=jdbc:mysql://localhost:3306/personal?characterEncoding=utf-8&amp;useSSL=false&amp;allowMultiQueries=true spring.jta.atomikos.datasource.one.xa-properties.username=root spring.jta.atomikos.datasource.one.xa-properties.password=123456 spring.jta.atomikos.datasource.one.xa-properties.filters=slf4j,stat,wall,config #spring.jta.atomikos.datasource.one.xa-properties.connectionProperties=config.decrypt=true;config.decrypt.key=$&#123;druid.publickey&#125; spring.jta.atomikos.datasource.two.unique-resource-name=jta-book spring.jta.atomikos.datasource.two.max-pool-size=8 spring.jta.atomikos.datasource.two.xa-data-source-class-name=com.alibaba.druid.pool.xa.DruidXADataSource spring.jta.atomikos.datasource.two.xa-properties.url=jdbc:mysql://localhost:3306/secondary?characterEncoding=utf-8&amp;useSSL=false&amp;&amp;allowMultiQueries=true spring.jta.atomikos.datasource.two.xa-properties.username=root spring.jta.atomikos.datasource.two.xa-properties.password=123456 spring.jta.atomikos.datasource.two.xa-properties.filters=slf4j,stat,wall,config #spring.jta.atomikos.datasource.two.xa-properties.connectionProperties=config.decrypt=true;config.decrypt.key=$&#123;druid.publickey&#125; ## Druid监控设置 spring.datasource.druid.web-stat-filter.exclusions=*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/* spring.datasource.druid.stat-view-servlet.url-pattern=/druid/* spring.datasource.druid.stat-view-servlet.reset-enable=true spring.datasource.druid.stat-view-servlet.login-username=admin spring.datasource.druid.stat-view-servlet.login-password=admin spring.datasource.druid.aop-patterns=com.example.atomikos.service.* OneDatabaseConfig12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.example.atomikos.config; import com.atomikos.jdbc.AtomikosDataSourceBean; import org.apache.ibatis.session.SqlSessionFactory; import org.mybatis.spring.SqlSessionFactoryBean; import org.mybatis.spring.annotation.MapperScan; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Primary; import javax.sql.DataSource; /** * 设置JTA(Atomikos)数据源，Mybatis * * @author fengxuechao */ @Configuration @MapperScan(basePackages = "com.example.atomikos.dao.one", sqlSessionFactoryRef = "oneSqlSessionFactory") public class OneDatabaseConfig &#123; /** * 设置JTA(Atomikos)数据源 * * @return &#123;@link AtomikosDataSourceBean&#125; */ @Primary @Bean @ConfigurationProperties(prefix = "spring.jta.atomikos.datasource.one") public DataSource oneDataSource() &#123; return new AtomikosDataSourceBean(); &#125; /** * 设置Mybatis的会话工厂类 * * @param dataSource JTA(Atomikos)数据源 * @return &#123;@link SqlSessionFactoryBean#getObject()&#125; * @throws Exception */ @Primary @Bean(name = "oneSqlSessionFactory") public SqlSessionFactory oneSqlSessionFactory(DataSource dataSource) throws Exception &#123; SqlSessionFactoryBean bean = new SqlSessionFactoryBean(); bean.setDataSource(dataSource); return bean.getObject(); &#125; &#125; TwoDatabaseConfig1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.example.atomikos.config; import com.atomikos.jdbc.AtomikosDataSourceBean; import org.apache.ibatis.session.SqlSessionFactory; import org.mybatis.spring.SqlSessionFactoryBean; import org.mybatis.spring.annotation.MapperScan; import org.springframework.beans.factory.annotation.Qualifier; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import javax.sql.DataSource; /** * 设置JTA(Atomikos)数据源，Mybatis * * @author fengxuechao */ @Configuration @MapperScan(basePackages = "com.example.atomikos.dao.two", sqlSessionFactoryRef = "twoSqlSessionFactory") public class TwoDatabaseConfig &#123; /** * 设置JTA(Atomikos)数据源 * * @return &#123;@link AtomikosDataSourceBean&#125; */ @Bean(name = "twoAtomikosDataSource") @ConfigurationProperties(prefix = "spring.jta.atomikos.datasource.two") public DataSource oneDataSource() &#123; return new AtomikosDataSourceBean(); &#125; /** * 设置Mybatis的会话工厂类 * * @param dataSource JTA(Atomikos)数据源 * @return &#123;@link SqlSessionFactoryBean#getObject()&#125; * @throws Exception */ @Bean(name = "twoSqlSessionFactory") public SqlSessionFactory oneSqlSessionFactory(@Qualifier("twoAtomikosDataSource") DataSource dataSource) throws Exception &#123; SqlSessionFactoryBean bean = new SqlSessionFactoryBean(); bean.setDataSource(dataSource); return bean.getObject(); &#125; &#125; TransactionConfig12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package com.example.atomikos.config; import org.springframework.aop.Advisor; import org.springframework.aop.aspectj.AspectJExpressionPointcut; import org.springframework.aop.support.DefaultPointcutAdvisor; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.transaction.PlatformTransactionManager; import org.springframework.transaction.TransactionDefinition; import org.springframework.transaction.interceptor.*; import java.util.Collections; import java.util.HashMap; import java.util.Map; /** * 配置声明式事务 切面拦截 * * @author fengxuechao */ @Configuration public class TransactionConfig &#123; private static final int TX_METHOD_TIMEOUT = 5; private static final String AOP_POINTCUT_EXPRESSION = "execution (* com.example.atomikos.service.*.*(..))"; @Autowired private PlatformTransactionManager transactionManager; @Bean public TransactionInterceptor txAdvice() &#123; NameMatchTransactionAttributeSource source = new NameMatchTransactionAttributeSource(); /* 只读事务，不做更新操作 */ RuleBasedTransactionAttribute readOnlyTx = new RuleBasedTransactionAttribute(); readOnlyTx.setReadOnly(true); readOnlyTx.setPropagationBehavior(TransactionDefinition.PROPAGATION_SUPPORTS); /* 当前存在事务就使用当前事务，当前不存在事务就创建一个新的事务 */ RuleBasedTransactionAttribute requiredTx = new RuleBasedTransactionAttribute(); requiredTx.setRollbackRules(Collections.singletonList(new RollbackRuleAttribute(Exception.class))); requiredTx.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED); requiredTx.setTimeout(TX_METHOD_TIMEOUT); Map&lt;String, TransactionAttribute&gt; txMap = new HashMap&lt;&gt;(10); txMap.put("add*", requiredTx); txMap.put("save*", requiredTx); txMap.put("insert*", requiredTx); txMap.put("update*", requiredTx); txMap.put("delete*", requiredTx); txMap.put("get*", readOnlyTx); txMap.put("query*", readOnlyTx); txMap.put("list*", readOnlyTx); txMap.put("find*", readOnlyTx); source.setNameMap(txMap); return new TransactionInterceptor(transactionManager, source); &#125; /** * 切点 * * @return */ @Bean public Advisor txAdviceAdvisor() &#123; AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut(); pointcut.setExpression(AOP_POINTCUT_EXPRESSION); return new DefaultPointcutAdvisor(pointcut, txAdvice()); &#125; &#125; 2.5.5.实体类1234567891011121314151617181920212223242526272829package com.example.atomikos.entity; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; import java.io.Serializable; /** * 文章 * * @author fengxuechao */ @Data @NoArgsConstructor @AllArgsConstructor public class ArticleDO implements Serializable &#123; private static final long serialVersionUID = 3971756585655871603L; private Long id; private String title; private String content; private String url; &#125; 1234567891011121314151617181920212223242526272829package com.example.atomikos.entity; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; import java.io.Serializable; /** * 书 * * @author fengxuechao */ @Data @NoArgsConstructor @AllArgsConstructor public class BookDO implements Serializable &#123; private static final long serialVersionUID = 3231762613546697469L; private Long id; private String name; private Long articleId; private Long userId; &#125; 123456789package com.example.atomikos.entity; import lombok.Data; @Data public class BookVo extends BookDO &#123; private UserDO user; &#125; 1234567891011121314151617181920212223242526package com.example.atomikos.entity; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; import java.io.Serializable; /** * 用户 * * @author fengxuechao */ @Data @NoArgsConstructor @AllArgsConstructor public class UserDO implements Serializable &#123; private static final long serialVersionUID = 469663920369239035L; private Long id; private String username; private String password; &#125; 2.5.6.Dao层UserDao注意包名，UserDao对应的配置为OneDatabaseConfig 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.example.atomikos.dao.one; import com.example.atomikos.entity.UserDO; import org.apache.ibatis.annotations.*; import org.springframework.stereotype.Repository; import java.util.List; /** * @author fengxuechao * @date 2018/11/30 */ @Repository public interface UserDao &#123; /** * 根据主键查询一条记录 * * @param id * @return */ @Select("select id, username, password from user where id = #&#123;id&#125;") UserDO get(Long id); /** * 分页列表查询 * * @param page * @param size * @return */ @Select("select id, username, password from user limit #&#123;page&#125;, #&#123;size&#125;") List&lt;UserDO&gt; list(Integer page, Integer size); /** * 保存 * * @param userDO * @return 自增主键 */ @Insert("insert into user(username, password) values(#&#123;username&#125;, #&#123;password&#125;)") @Options(useGeneratedKeys = true, keyColumn = "id") int save(UserDO userDO); /** * 修改一条记录 * * @param user * @return */ @Update("update user set username = #&#123;username&#125;, password = #&#123;password&#125; where id = #&#123;id&#125;") int update(UserDO user); /** * 删除一条记录 * * @param id 主键 * @return */ @Delete("delete from user where id = #&#123;id&#125;") int delete(Long id); &#125; BookDao注意包名，UserDao对应的配置为TwoDatabaseConfig 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.example.atomikos.dao.two; import com.example.atomikos.entity.BookDO; import org.apache.ibatis.annotations.*; import org.springframework.stereotype.Repository; import java.util.List; /** * @author fengxuechao * @date 2018/11/30 */ @Mapper @Repository public interface BookDao &#123; /** * 分页查询 * * @param page 页码 * @param size 每页记录数 * @return */ @Select("select id, name, article_id as articleId, user_id as userId from book limit $&#123;page&#125;, $&#123;size&#125;") List&lt;BookDO&gt; list(@Param("page") Integer page, @Param("size") Integer size); /** * 根据主键查询单条记录 * * @param id * @return */ @Select("select id, name, article_id as articleId, user_id as userId from book where id = #&#123;id&#125;") BookDO get(Long id); /** * 添加一条记录 * * @param book * @return 自增主键 */ @Insert("insert into book(name, article_id, user_id) values(#&#123;name&#125;, #&#123;articleId&#125;, #&#123;userId&#125;)") @Options(useGeneratedKeys = true, keyProperty = "id", keyColumn = "id") int save(BookDO book); /** * 修改一条记录 * * @param book * @return */ @Update("update book set name = #&#123;name&#125;, article_id = #&#123;articleId&#125;, user_id = #&#123;userId&#125; where id = #&#123;id&#125;") int update(BookDO book); /** * 删除一条记录 * * @param id 主键 * @return */ @Delete("delete from book where id = #&#123;id&#125;") int delete(Long id); &#125; 2.5.7.Service层Bookservice1234567891011121314151617181920212223242526272829303132333435363738394041package com.example.atomikos.service; import com.example.atomikos.entity.BookDO; import com.example.atomikos.entity.UserDO; import java.util.List; /** * 主要目的是测试分布式事务 * * @author fengxuechao */ public interface BookService &#123; /** * 保存 * * @param book * @param user * @return */ BookDO save(BookDO book, UserDO user); /** * 单条查询 * * @param id * @return */ BookDO get(Long id); /** * 分页查询 * * @param page * @param size * @return */ List&lt;BookDO&gt; list(Integer page, Integer size); &#125; BookServiceImpl请注意，其中有些代码故意抛出异常是为了测试的目的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117package com.example.atomikos.service.impl; import com.example.atomikos.dao.one.UserDao; import com.example.atomikos.dao.two.BookDao; import com.example.atomikos.entity.BookDO; import com.example.atomikos.entity.UserDO; import com.example.atomikos.service.BookService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import org.springframework.transaction.annotation.Transactional; import java.util.List; /** * @author fengxuechao */ @Service public class BookServiceImpl implements BookService &#123; @Autowired private BookDao bookDao; @Autowired private UserDao userDao; /** * 保存书本和文章, 使用声明式事务(tx+aop形式) * * @param book &#123;@link BookDO&#125; * @param user &#123;@link UserDO&#125; * @return */ @Override public BookDO save(BookDO book, UserDO user) &#123; int userSave = userDao.save(user); if (userSave == 0) &#123; return null; &#125; book.setUserId(user.getId()); int bookSave = bookDao.save(book); if (bookSave == 0) &#123; return null; &#125; // throw new RuntimeException("测试分布式事务(tx+aop形式)"); return book; &#125; /** * 单条查询 * * @param id * @return */ @Override public BookDO get(Long id) &#123; BookDO book = bookDao.get(id); UserDO user = userDao.get(book.getUserId()); return new BookDO(book.getId(), book.getName(), book.getArticleId(), user.getId()); &#125; /** * 分页查询 * * @param page * @param size * @return */ @Override public List&lt;BookDO&gt; list(Integer page, Integer size) &#123; page = (page &lt; 1 ? 0 : page - 1) * size; return bookDao.list(page, size); &#125; /** * 修改书本和文章, 使用声明式事务(注解形式) * * @param book * @param user * @return */ @Transactional(rollbackFor = Exception.class) public BookDO update(BookDO book, UserDO user) &#123; int bookUpdate = bookDao.update(book); if (bookUpdate != 1) &#123; return null; &#125; int userUpdate = userDao.update(user); if (userUpdate != 1) &#123; return null; &#125; throw new RuntimeException("测试分布式事务(注解形式)"); // return book; &#125; /** * 删除书本和文章 * * @param id * @return */ public int delete(Long id) &#123; BookDO book = bookDao.get(id); System.err.println(book); Long userId = book.getUserId(); int userDelete = userDao.delete(userId); if (userDelete != 1) &#123; return 0; &#125; int bookDelete = bookDao.delete(id); if (bookDelete != 1) &#123; return 0; &#125; throw new RuntimeException("测试没有添加分布式事务管理)"); // return 1; &#125; &#125; 2.5.8.Controller层12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.example.atomikos.controller; import com.example.atomikos.entity.BookDO; import com.example.atomikos.entity.BookVo; import com.example.atomikos.service.BookService; import com.example.atomikos.service.impl.BookServiceImpl; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.*; import java.util.List; /** * @author fengxuechao */ @RestController @RequestMapping("/books") public class BookController &#123; @Autowired private BookService bookService; @GetMapping public List&lt;BookDO&gt; list( @RequestParam(defaultValue = "1") Integer page, @RequestParam(defaultValue = "10") Integer size) &#123; return bookService.list(page, size); &#125; @GetMapping("/&#123;id&#125;") public BookDO get(@PathVariable Long id) &#123; return bookService.get(id); &#125; @PostMapping public BookDO save(@RequestBody BookVo book) &#123; return bookService.save(book, book.getUser()); &#125; @PutMapping public BookDO update(@RequestBody BookVo book) &#123; return ((BookServiceImpl) bookService).update(book, book.getUser()); &#125; @DeleteMapping("/&#123;id&#125;") public int delete(@PathVariable Long id) &#123; return ((BookServiceImpl) bookService).delete(id); &#125; &#125; 2.5.9.单元测试BookServiceImplTest由于故意抛出异常，故单元测试失败，查看数据库，数据库中数据保持原样 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.example.atomikos.service.impl; import com.example.atomikos.entity.BookDO; import com.example.atomikos.entity.UserDO; import com.example.atomikos.service.BookService; import org.junit.Assert; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.junit4.SpringRunner; /** * 测试分布式事务：切面拦截形式, 注解式 */ @RunWith(SpringRunner.class) @SpringBootTest public class BookServiceImplTest &#123; @Autowired BookService bookService; /** * 测试分布式事务(切面拦截形式) */ @Test public void save() &#123; BookDO book = new BookDO(); book.setName("Book Name - 001"); book.setArticleId(69L); UserDO user = new UserDO(); user.setUsername("username - 001"); user.setPassword("password - 001"); BookDO bookDO = bookService.save(book, user); System.out.println(bookDO); &#125; /** * 测试分布式事务(注解式) */ @Test public void update() &#123; BookDO book = new BookDO(); book.setId(10L); book.setName("Book Name - 002"); book.setArticleId(69L); UserDO user = new UserDO(); user.setId(18L); user.setUsername("username - 002"); user.setPassword("password - 002"); ((BookServiceImpl)bookService).update(book, user); &#125; /** * 没有事务管理 */ @Test public void delete() &#123; int delete = ((BookServiceImpl) bookService).delete(11L); Assert.assertEquals(1, delete); &#125; &#125; BookControllerTest123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115package com.example.atomikos.controller; import com.example.atomikos.dao.one.UserDao; import com.example.atomikos.entity.BookVo; import com.example.atomikos.entity.UserDO; import com.fasterxml.jackson.databind.ObjectMapper; import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.http.MediaType; import org.springframework.test.context.junit4.SpringRunner; import org.springframework.test.web.servlet.MockMvc; import org.springframework.test.web.servlet.request.MockMvcRequestBuilders; import org.springframework.test.web.servlet.setup.MockMvcBuilders; import org.springframework.web.context.WebApplicationContext; import static org.hamcrest.Matchers.is; import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post; import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.put; import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print; import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath; import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status; /** * 测试分布式事务 */ @RunWith(SpringRunner.class) @SpringBootTest public class BookControllerTest &#123; private MockMvc mockMvc; private ObjectMapper objectMapper = new ObjectMapper(); @Autowired private UserDao userDao; @Autowired private WebApplicationContext context; @Before public void setUp() &#123; this.mockMvc = MockMvcBuilders.webAppContextSetup(this.context).build(); &#125; /** * 申明式 * * @throws Exception */ @Test public void save() throws Exception &#123; UserDO user = new UserDO(); user.setUsername("username - 002"); user.setPassword("password - 002"); BookVo book = new BookVo(); book.setName("Book Name - 002"); book.setArticleId(69L); book.setUser(user); String json = objectMapper.writeValueAsString(book); this.mockMvc.perform( post("/books") .contentType(MediaType.APPLICATION_JSON_UTF8) .content(json)) .andExpect(status().isOk()) .andExpect(jsonPath("$.name", is("Book Name - 002"))) .andExpect(jsonPath("$.articleId", is(69))) .andDo(print()); &#125; /** * 注解式 * * @throws Exception */ @Test public void update() throws Exception &#123; UserDO user = userDao.get(3L); assert user != null; user.setUsername("username - 003"); user.setPassword("password - 003"); BookVo book = new BookVo(); book.setId(3L); book.setName("Book Name - 003"); book.setArticleId(69L); book.setUser(user); String json = objectMapper.writeValueAsString(book); this.mockMvc.perform( put("/books") .contentType(MediaType.APPLICATION_JSON_UTF8) .content(json)) .andExpect(status().isOk()) .andExpect(jsonPath("$.name", is("Book Name - 003"))) .andExpect(jsonPath("$.articleId", is(69))) .andDo(print()); &#125; /** * 没有事务管理 * * @throws Exception */ @Test public void delete() throws Exception &#123; this.mockMvc.perform( MockMvcRequestBuilders.delete("/books/4")) .andExpect(status().isOk()) .andDo(print()); &#125; &#125; 3.引用 http://www.thedevpiece.com/configuring-multiple-datasources-using-springboot-and-atomikos/ https://blog.csdn.net/a510835147/article/details/75675311 https://www.jianshu.com/p/0dde641295af http://www.importnew.com/15812.html https://www.ibm.com/developerworks/cn/java/j-lo-jta/]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>分布式事务</tag>
        <tag>spring-boot</tag>
        <tag>atomikos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring-boot-starter单元测试入门]]></title>
    <url>%2Fpassages%2Fspring-boot-starter%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[这次来介绍下Spring Boot中对单元测试的整合使用，本篇会通过以下3点来介绍，基本满足日常需求： Dao层单元测试 Service层单元测试 Controller层单元测试在单元测试中要尽量使用断言，本文所有的测试类都符合几个原则： 测试类卸载src/test/java目录下 测试类的包结构与被测试类的包结构相同 测试类的命名都是被测试类类名后缀加上Test，例如,UserDaoImpl与UserDaoImplTest相对应 测试类的方法与被测试类的方法命名相同 1.前言这次来介绍下Spring Boot中对单元测试的整合使用，本篇会通过以下3点来介绍，基本满足日常需求： Dao层单元测试 Service层单元测试 Controller层单元测试在单元测试中要尽量使用断言，本文所有的测试类都符合几个原则： 测试类卸载src/test/java目录下 测试类的包结构与被测试类的包结构相同 测试类的命名都是被测试类类名后缀加上Test，例如,UserDaoImpl与UserDaoImplTest相对应 测试类的方法与被测试类的方法命名相同 2.正文2.1核心依赖在Spring Boot 项目中引入单元测试很简单，依赖如下： 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 2.2 如何创建单元测试类Spring Boot中单元测试类写在在src/test/java目录下，你可以手动创建具体测试类，如果是IDEA，则可以通过IDEA自动创建测试类，如下图，可以通过快捷键Ctrl+Shift+T(Window)来创建，如下： 2.3. 盲点解释@RunwithJUnit用例都是在Runner（运行器）来执行的。通过它，可以为这个测试类指定一个特定的Runner。JUnit允许用户指定其它的单元测试执行类，只需要我们的测试执行类继承类org.junit.runners.BlockJUnit4ClassRunner就可以了，Spring的执行类SpringJUnit4ClassRunner就是继承了该类。我们平时用Spring也比较多，为了能够更加方便的引用配置文件，我们单元测试就使用了Spring实现的执行类。此时的单元测试执行类将会看起来是这样： 123456789101112131415@RunWith(SpringRunner.class)@SpringBootTestpublic class UserDaoImplTest &#123; @Autowired private UserDao dao; /** * 测试根据用户名查询用户 */ @Test public void getByUsername() &#123; User user = dao.getByUsername("小明"); System.err.println(user); &#125; SpringRunnerSpringRunner是SpringJUnit4ClassRunner的一个别名。SpringJUnit4ClassRunner是JUnit的BlockJUnit4ClassRunner类的一个常规扩展，提供了一些spring测试环境上下文去规范JUnit测试。 @SpringBootTest注解制定了一个测试类运行了Spring Boot环境。提供以下特性： 自动搜索到SpringBootConfiguration注解的文件。 允许自动注入Environment类读取配置文件。 提供一个webEnvironment环境，可以完整的允许一个web环境使用随机的端口或者自定义的端口。 Spring Boot测试步骤直接在测试类上面加上如下2个注解@RunWith(SpringRunner.class)@SpringBootTest就能取到spring中的容器的实例，如果配置了@Autowired那么就自动将对象注入。 单元测试回滚单元个测试的时候如果不想造成垃圾数据，可以开启事物功能，记在方法或者类头部添加@Transactional注解即可,如下： 1234567@Transactional@Testpublic void save() &#123; User user = new User("测试用户", "123456"); int save = dao.save(user); Assert.assertEquals(1, save);&#125; 这样测试完数据就会回滚了，不会造成垃圾数据。 3.核心代码示例3.1.Dao层单元测试基本上所有的WEB程序都会涉及到数据库，本次示例就以最简化的模式：持久层框架就用spring-jdbc。Dao层的测试涉及到基本的CRUD操作。 UserDaoImpl1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162@Repositorypublic class UserDaoImpl implements UserDao &#123; @Autowired private JdbcTemplate template; private static final BeanPropertyRowMapper&lt;User&gt; MAPPER = new BeanPropertyRowMapper&lt;&gt;(User.class); /** * 新建用户 * * @param user * @return */ @Override public int save(User user) &#123; return template.update( "insert into user(username, password) values (?, ?)", user.getUsername(), user.getPassword()); &#125; /** * 修改密码 * * @return */ @Override public int update(User user) &#123; return template.update( "update user set password = ? where username = ?", user.getPassword(), user.getUsername()); &#125; /** * 根据ID删除用户 * * @return */ @Override public int delete(Long id) &#123; return template.update("delete from user where id = ?", id); &#125; /** * 获取所有用户 * * @return */ @Override public List&lt;User&gt; list() &#123; return template.query("select id, username, password from user", MAPPER); &#125; @Override public User getByUsername(String username) &#123; try &#123; return template.queryForObject( "select id, username, password from user where username = ? limit 1", MAPPER, username); &#125; catch (EmptyResultDataAccessException e) &#123; return null; &#125; &#125;&#125; UserDaoImplTest12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667@RunWith(SpringRunner.class)@SpringBootTestpublic class UserDaoImplTest &#123; @Autowired private UserDao dao; /** * 测试根据用户名查询用户 */ @Test public void getByUsername() &#123; User user = dao.getByUsername("小明"); System.err.println(user); &#125; /** * 测试新建用户 */ @Transactional @Test public void save() &#123; User user = new User("测试用户", "123456"); int save = dao.save(user); Assert.assertEquals(1, save); &#125; /** * 测试修改密码 */ @Transactional @Test public void update() &#123; User user = new User("测试用户", "123456"); dao.save(user); /* 密码修改前 */ User before = dao.getByUsername("测试用户"); user.setPassword("654321"); /* 密码修改后 */ dao.update(user); User after = dao.getByUsername("测试用户"); /* 断言判断修改密码前后的两个类不同 */ Assert.assertNotEquals(before, after); &#125; /** * 测试删除用户 */ @Transactional @Test public void delete() &#123; int save = dao.save(new User("测试用户", "123456")); Assert.assertEquals(1, save); User user = dao.getByUsername("测试用户"); int delete = dao.delete(user.getId()); Assert.assertEquals(1, delete); &#125; /** * 测试用户列表 */ @Test public void list() &#123; List&lt;User&gt; list = dao.list(); System.err.println(list); &#125;&#125; 3.2.Service层单元测试UserServiceImpl12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758@Servicepublic class UserServiceImpl implements UserService &#123; @Autowired private UserDao dao; /** * 根据用户名查询用户 * * @param username * @return */ @Override public User getByUsername(String username) &#123; return dao.getByUsername(username); &#125; /** * 列表查询用户 * * @return */ @Override public List&lt;User&gt; list() &#123; return dao.list(); &#125; /** * 修改密码 * @return */ @Transactional @Override public int updatePassword(User user) &#123; return dao.update(user); &#125; /** * 根据ID删除用户 * @return */ @Transactional @Override public int deleteById(Long id) &#123; return dao.delete(id); &#125; /** * 添加用户 * @param user * @return */ @Transactional @Override public int save(User user) &#123; return dao.save(user); &#125;&#125; UserServiceImplTest123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566@RunWith(SpringRunner.class)@SpringBootTestpublic class UserServiceImplTest &#123; @Autowired private UserService service; /** * 测试根据用户名查询用户 */ @Test public void getByUsername() &#123; User user = service.getByUsername("小明"); System.err.println(user); &#125; /** * 测试列表查询用户 */ @Test public void list() &#123; List&lt;User&gt; list = service.list(); System.err.println(list); &#125; /** * 测试修改密码 */ @Transactional @Test public void updatePassword() &#123; User user = new User("测试用户", "123456"); service.save(user); /* 密码修改前 */ User before = service.getByUsername("测试用户"); user.setPassword("654321"); /* 密码修改后 */ service.updatePassword(user); User after = service.getByUsername("测试用户"); /* 断言判断修改密码前后的两个类不同 */ Assert.assertNotEquals(before, after); &#125; /** * 测试根据ID删除用户 */ @Transactional @Test public void deleteById() &#123; int save = service.save(new User("测试用户", "123456")); Assert.assertEquals(1, save); User user = service.getByUsername("测试用户"); int delete = service.deleteById(user.getId()); Assert.assertEquals(1, delete); &#125; /** * 测试添加用户 */ @Transactional @Test public void save() &#123; List&lt;User&gt; list = service.list(); System.err.println(list); &#125;&#125; 3.3.Controller层单元测试上面只是针对Service和Dao层做测试，但是有时候需要对Controller层（API）做测试，这时候就得用到MockMvc了，你可以不必启动工程就能测试这些接口。 MockMvc实现了对Http请求的模拟，能够直接使用网络的形式，转换到Controller的调用，这样可以使得测试速度快、不依赖网络环境，而且提供了一套验证的工具，这样可以使得请求的验证统一而且很方便。 UserController12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758@RestControllerpublic class UserController &#123; @Autowired private UserService service; /** * 用户列表 * @return */ @RequestMapping("/user/list") public List&lt;User&gt; list() &#123; return service.list(); &#125; /** * 新建用户 * @param username * @param password * @return */ @RequestMapping("/user/save") public int save(@RequestParam String username, @RequestParam String password) &#123; return service.save(new User(username, password)); &#125; /** * 根据ID删除用户 * @param id * @return */ @RequestMapping("/user/delete") public int delete(@RequestParam Long id) &#123; return service.deleteById(id); &#125; /** * 根据用户名查询用户 * @param username * @return */ @RequestMapping("/user/getByUsername") public User getByUsername(@RequestParam String username) &#123; return service.getByUsername(username); &#125; /** * 根据用户名修改密码 * @param username * @param newPassword * @return */ @RequestMapping("/user/updatepassword") public int updatepassword(@RequestParam String username, @RequestParam String newPassword) &#123; return service.updatePassword(new User(username, newPassword)); &#125;&#125; UserControllerTest123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293/** * 1.SpringRunner继承SpringJUnit4ClassRunner，通俗的讲SpringRunner是SpringJUnit4ClassRunner的别名。 * 2.SpringBoot项目中自动添加注解式事务支持，在测试环境中添加@Transactional，可以对有事务影响的数据库操作回滚 */@RunWith(SpringJUnit4ClassRunner.class)@SpringBootTestpublic class UserControllerTest &#123; /** * 模拟浏览器 */ MockMvc mvc; /** * 加载WEB的上下文 */ @Autowired WebApplicationContext context; @Before public void before() &#123; // mvc = MockMvcBuilders.standaloneSetup(new TestController()).build(); mvc = MockMvcBuilders.webAppContextSetup(context).build();//建议使用这种 &#125; /** * 测试用户列表 * * @throws Exception */ @Test public void list() throws Exception &#123; mvc.perform( MockMvcRequestBuilders.get("/user/list")) .andExpect(status().isOk()) // 期待返回状态码200 .andDo(print()); // 打印返回的 http response 信息 &#125; /** * 测试添加用户 * 期待：Body = 1 * * @throws Exception */ @Transactional @Test public void save() throws Exception &#123; mvc.perform( MockMvcRequestBuilders.post("/user/save") .param("username", "测试用户1") .param("password", "123456")) .andExpect(status().isOk()) .andDo(print()); &#125; /** * 测试删除用户 * 期待：Body = 1 */ @Transactional @Test public void delete() throws Exception &#123; mvc.perform(MockMvcRequestBuilders.post("/user/delete") .param("id", "1")) .andExpect(status().isOk()) .andDo(print()); &#125; /** * 测试根据用户名查询用户 */ @Test public void getByUsername() throws Exception &#123; mvc.perform(MockMvcRequestBuilders.get("/user/getByUsername") .param("username", "小明")) .andExpect(status().isOk()) .andDo(print()); &#125; /** * 测试修改密码 * 期待：Body = 1 */ @Transactional @Test public void updatepassword() throws Exception &#123; mvc.perform(MockMvcRequestBuilders.post("/user/updatepassword") .param("username", "小明") .param("newPassword", "654321")) .andExpect(status().isOk()) .andDo(print()); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>spring-boot</tag>
        <tag>spring-boot-starter-test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux安装Java的脚本]]></title>
    <url>%2Fpassages%2Flinux%E5%AE%89%E8%A3%85Java%E7%9A%84%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[linux安装Java的脚本1234567891011121314151617181920212223242526272829303132333435#!/bin/bashset -ex# UPDATE THESE URLsexport JDK_URL=https://download.oracle.com/otn-pub/java/jdk/8u191-b12/2787e4a523244c269598db4e85c51e0c/jdk-8u191-linux-x64.tar.gzexport UNLIMITED_STRENGTH_URL=http://download.oracle.com/otn-pub/java/jce/8/jce_policy-8.zip# Download Oracle Java 8 accepting the licensewget --no-cookies --header "Cookie: oraclelicense=accept-securebackup-cookie" \$&#123;JDK_URL&#125;# Extract the archivetar -xzvf jdk-*.tar.gz# clean up the tarrm -fr jdk-*.tar.gz# mk the jvm dirsudo mkdir -p /usr/lib/jvm# move the server jresudo mv jdk1.8* /usr/lib/jvm/oracle_jdk8# install unlimited strength policywget --no-cookies --header "Cookie: oraclelicense=accept-securebackup-cookie" \$&#123;UNLIMITED_STRENGTH_URL&#125;unzip jce_policy-8.zipmv UnlimitedJCEPolicyJDK8/local_policy.jar /usr/lib/jvm/oracle_jdk8/jre/lib/security/mv UnlimitedJCEPolicyJDK8/US_export_policy.jar /usr/lib/jvm/oracle_jdk8/jre/lib/security/sudo update-alternatives --install /usr/bin/java java /usr/lib/jvm/oracle_jdk8/jre/bin/java 2000sudo update-alternatives --install /usr/bin/javac javac /usr/lib/jvm/oracle_jdk8/bin/javac 2000sudo echo "export J2SDKDIR=/usr/lib/jvm/oracle_jdk8export J2REDIR=/usr/lib/jvm/oracle_jdk8/jreexport PATH=$PATH:/usr/lib/jvm/oracle_jdk8/bin:/usr/lib/jvm/oracle_jdk8/db/bin:/usr/lib/jvm/oracle_jdk8/jre/binexport JAVA_HOME=/usr/lib/jvm/oracle_jdk8export DERBY_HOME=/usr/lib/jvm/oracle_jdk8/db" | sudo tee -a /etc/profile.d/oraclejdk.sh chmod +x 文件名.sh 脚本来自 https://stackoverflow.com/questions/36478741/installing-oracle-jdk-on-windows-subsystem-for-linux]]></content>
  </entry>
  <entry>
    <title><![CDATA[MyBatis代码生成]]></title>
    <url>%2Fpassages%2FMyBatis%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%2F</url>
    <content type="text"><![CDATA[要使用generator插件自动生成相关文件，需要引入mybatis-generator-core这个包，在 &lt;dependencys&gt; 中加入 1. 在pom.xml中做两处配置1.1. 配置dependency要使用generator插件自动生成相关文件，需要引入mybatis-generator-core这个包，在 &lt;dependencys&gt; 中加入： 12345678&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt; 1.2. 配置plugin在 &lt;build&gt; 这个节点的 &lt;plugins&gt; 节点内部加入一个 &lt;plugin&gt;，如下： 1234567891011121314151617&lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.5&lt;/version&gt; &lt;configuration&gt; &lt;configurationFile&gt;$&#123;basedir&#125;/src/main/resources/generator/generatorConfig.xml&lt;/configurationFile&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;/configuration&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.3.5&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/plugin&gt; 2. 创建generatorConfig.xml2.1. 配置文件路径名称以及内容在resource目录下创建generatorConfig.xml配置文件，当然了该文件起这个名字，并且放到resource根目录下是根据genereator的默认方案来的，如果要用别的名，放到别的目录也可以，只是要做其它配置，这里就按默认算了，该文件的配置内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE generatorConfigurationPUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN""http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;&lt;generatorConfiguration&gt; &lt;!-- 数据库驱动:选择你的本地硬盘上面的数据库驱动包--&gt; &lt;classPathEntry location="E:\develop\mavenRepository\mysql\mysql-connector-java\5.1.46\mysql-connector-java-5.1.46.jar"/&gt; &lt;context id="mysqlTables" targetRuntime="MyBatis3"&gt; &lt;!-- 自动识别数据库关键字，默认false，如果设置为true，根据SqlReservedWords中定义的关键字列表； 一般保留默认值，遇到数据库关键字（Java关键字），使用columnOverride覆盖 --&gt; &lt;property name="autoDelimitKeywords" value="false"/&gt; &lt;!-- 生成的Java文件的编码 --&gt; &lt;property name="javaFileEncoding" value="UTF-8"/&gt; &lt;!-- 格式化java代码 --&gt; &lt;property name="javaFormatter" value="org.mybatis.generator.api.dom.DefaultJavaFormatter"/&gt; &lt;!-- 格式化XML代码 --&gt; &lt;property name="xmlFormatter" value="org.mybatis.generator.api.dom.DefaultXmlFormatter"/&gt; &lt;!-- beginningDelimiter和endingDelimiter：指明数据库的用于标记数据库对象名的符号，比如ORACLE就是双引号，MYSQL默认是`反引号； --&gt; &lt;property name="beginningDelimiter" value="`"/&gt; &lt;property name="endingDelimiter" value="`"/&gt; &lt;commentGenerator&gt; &lt;property name="suppressDate" value="true"/&gt; &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt; &lt;property name="suppressAllComments" value="true"/&gt; &lt;/commentGenerator&gt; &lt;!--数据库链接URL，用户名、密码 --&gt; &lt;jdbcConnection driverClass="com.mysql.jdbc.Driver" connectionURL="jdbc:mysql://localhost:3306/personal?characterEncoding=UTF-8" userId="root" password="123456"&gt;&lt;/jdbcConnection&gt; &lt;!-- java类型处理器 用于处理DB中的类型到Java中的类型，默认使用JavaTypeResolverDefaultImpl； 注意一点，默认会先尝试使用Integer，Long，Short等来对应DECIMAL和 NUMERIC数据类型； --&gt; &lt;javaTypeResolver type="org.mybatis.generator.internal.types.JavaTypeResolverDefaultImpl"&gt; &lt;!-- true：使用BigDecimal对应DECIMAL和 NUMERIC数据类型 false：默认, scale&gt;0;length&gt;18：使用BigDecimal; scale=0;length[10,18]：使用Long； scale=0;length[5,9]：使用Integer； scale=0;length&lt;5：使用Short； --&gt; &lt;property name="forceBigDecimals" value="false"/&gt;&lt;/javaTypeResolver&gt; &lt;!-- 生成模型的包名和位置--&gt; &lt;javaModelGenerator targetPackage="com.littlefxc.personal.model" targetProject="src/main/java"&gt; &lt;property name="enableSubPackages" value="true"/&gt; &lt;property name="trimStrings" value="true"/&gt; &lt;/javaModelGenerator&gt; &lt;!-- 生成映射文件的包名和位置--&gt; &lt;sqlMapGenerator targetPackage="mybatis" targetProject="src/main/resources"&gt; &lt;property name="enableSubPackages" value="true"/&gt; &lt;/sqlMapGenerator&gt; &lt;!-- 生成DAO的包名和位置--&gt; &lt;javaClientGenerator type="XMLMAPPER" targetPackage="com.littlefxc.personal.mapper" targetProject="src/main/java"&gt; &lt;property name="enableSubPackages" value="true"/&gt; &lt;/javaClientGenerator&gt; &lt;!-- 要生成的表 tableName是数据库中的表名或视图名 domainObjectName是实体类名--&gt; &lt;!-- generatedKey用于生成生成主键的方法， 如果设置了该元素，MBG会在生成的&lt;insert&gt;元素中生成一条正确的&lt;selectKey&gt;元素，该元素可选 column:主键的列名； sqlStatement：要生成的selectKey语句，有以下可选项： Cloudscape:相当于selectKey的SQL为： VALUES IDENTITY_VAL_LOCAL() DB2 :相当于selectKey的SQL为： VALUES IDENTITY_VAL_LOCAL() DB2_MF :相当于selectKey的SQL为：SELECT IDENTITY_VAL_LOCAL() FROM SYSIBM.SYSDUMMY1 Derby :相当于selectKey的SQL为：VALUES IDENTITY_VAL_LOCAL() HSQLDB :相当于selectKey的SQL为：CALL IDENTITY() Informix :相当于selectKey的SQL为：select dbinfo('sqlca.sqlerrd1') from systables where tabid=1 MySql :相当于selectKey的SQL为：SELECT LAST_INSERT_ID() SqlServer :相当于selectKey的SQL为：SELECT SCOPE_IDENTITY() SYBASE :相当于selectKey的SQL为：SELECT @@IDENTITY JDBC :相当于在生成的insert元素上添加useGeneratedKeys="true"和keyProperty属性 &lt;generatedKey column="" sqlStatement=""/&gt; --&gt; &lt;table tableName="article" domainObjectName="ArticlePo" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false"&gt; &lt;generatedKey column="id" sqlStatement="MySql" identity="true"/&gt; &lt;/table&gt; &lt;table tableName="article_tag" domainObjectName="ArticleTagPo" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false"&gt; &lt;generatedKey column="id" sqlStatement="MySql" identity="true"/&gt; &lt;/table&gt; &lt;table tableName="user" domainObjectName="UserPo" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false"&gt; &lt;generatedKey column="id" sqlStatement="MySql" identity="true"/&gt; &lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 3. 执行3.1. 利用idea 执行 3.2. 也可以执行mvn mybatis-generator:generate命令 生成最终效果图结构]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[window删除右键管理员权限]]></title>
    <url>%2Fpassages%2Fwindow%E5%88%A0%E9%99%A4%E5%8F%B3%E9%94%AE%E7%AE%A1%E7%90%86%E5%91%98%E6%9D%83%E9%99%90%2F</url>
    <content type="text"><![CDATA[删除右键管理员权限.reg123Windows Registry Editor Version 5.00[-HKEY_CLASSES_ROOT\*\shell\runas][-HKEY_CLASSES_ROOT\Directory\shell\runas]]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>权限</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[window右键获取管理员权限]]></title>
    <url>%2Fpassages%2Fwindow%E5%8F%B3%E9%94%AE%E8%8E%B7%E5%8F%96%E7%AE%A1%E7%90%86%E5%91%98%E6%9D%83%E9%99%90%2F</url>
    <content type="text"><![CDATA[文件名：获取管理员的所有权限–带图标.reg123456789101112131415161718192021222324252627282930313233Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\*\shell\runas][HKEY_CLASSES_ROOT\*\shell\runas]@="获取超级管理员的所有权限""Icon"="C:\\Windows\\System32\\imageres.dll,-78""NoWorkingDirectory"=""[HKEY_CLASSES_ROOT\*\shell\runas\command]@="cmd.exe /c takeown /f \"%1\" &amp;&amp; icacls \"%1\" /grant administrators:F""IsolatedCommand"="cmd.exe /c takeown /f \"%1\" &amp;&amp; icacls \"%1\" /grant administrators:F"[HKEY_CLASSES_ROOT\Directory\shell\runas][HKEY_CLASSES_ROOT\Directory\shell\runas]@="获取超级管理员的所有权限""Icon"="C:\\Windows\\System32\\imageres.dll,-78""NoWorkingDirectory"=""[HKEY_CLASSES_ROOT\Directory\shell\runas\command]@="cmd.exe /c takeown /f \"%1\" /r /d y &amp;&amp; icacls \"%1\" /grant administrators:F /t""IsolatedCommand"="cmd.exe /c takeown /f \"%1\" /r /d y &amp;&amp; icacls \"%1\" /grant administrators:F /t"[HKEY_CLASSES_ROOT\dllfile\shell][HKEY_CLASSES_ROOT\dllfile\shell\runas]@="获取超级管理员的所有权限""HasLUAShield"="""NoWorkingDirectory"=""[HKEY_CLASSES_ROOT\dllfile\shell\runas\command]@="cmd.exe /c takeown /f \"%1\" &amp;&amp; icacls \"%1\" /grant administrators:F""IsolatedCommand"="cmd.exe /c takeown /f \"%1\" &amp;&amp; icacls \"%1\" /grant administrators:F"[HKEY_CLASSES_ROOT\Drive\shell\runas][HKEY_CLASSES_ROOT\Drive\shell\runas]@="获取超级管理员的所有权限""Icon"="C:\\Windows\\System32\\imageres.dll,-78""NoWorkingDirectory"=""[HKEY_CLASSES_ROOT\Drive\shell\runas\command]@="cmd.exe /c takeown /f \"%1\" /r /d y &amp;&amp; icacls \"%1\" /grant administrators:F /t""IsolatedCommand"="cmd.exe /c takeown /f \"%1\" /r /d y &amp;&amp; icacls \"%1\" /grant administrators:F /t"]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>权限</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring-boot-starter-validation学习笔记]]></title>
    <url>%2Fpassages%2Fspring-boot-starter-validation%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[开发过程中，后台的参数校验是必不可少的，本文关于 spring-boot-starter-validation的学习笔记。 1 背景开发过程中，后台的参数校验是必不可少的，本文关于 spring-boot-starter-validation的学习笔记 2 示例2.1 如何在pom.xml中引用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.littlefxc&lt;/groupId&gt; &lt;artifactId&gt;personal&lt;/artifactId&gt; &lt;version&gt;1.0-snapshot&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.16.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 热部署 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 校验框架 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;central&lt;/id&gt; &lt;name&gt;central&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt;&lt;/repositories&gt;&lt;/project&gt; 2.2 Hibernate Validator 常用注解 2.3 创建自定义校验器2.3.1 创建自定义注解1234567891011121314151617181920212223242526272829303132package com.littlefxc.examples.validation;import javax.validation.Constraint;import javax.validation.Payload;import javax.validation.ReportAsSingleViolation;import javax.validation.constraints.Pattern;import java.lang.annotation.Documented;import java.lang.annotation.Retention;import java.lang.annotation.Target;import static java.lang.annotation.ElementType.*;import static java.lang.annotation.ElementType.PARAMETER;import static java.lang.annotation.RetentionPolicy.RUNTIME;/** * @author fengxuechao */ @Documented @Constraint(validatedBy = &#123; &#125;) @Target(&#123; METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER &#125;) @Retention(RUNTIME) @ReportAsSingleViolation@Pattern(regexp = "") public @interface IsPhone &#123; /** * 错误提示 * @return */ String message() default "&#123;login.phone.invalid&#125;"; Class&lt;?&gt;[] groups() default &#123;&#125;; Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;;&#125; 2.3.2 实现ConstraintValidator仅仅创建注解是没有任何意义的，必须与ConstraintValidator这个接口配合，才能使自定义注解生效 1234567891011121314151617181920212223242526272829package com.littlefxc.examples.validation;import javax.validation.ConstraintValidator;import javax.validation.ConstraintValidatorContext;import java.util.regex.Pattern;/** * @author fengxuechao */public class IsPhoneConstraintValidator implements ConstraintValidator&lt;IsPhone, String&gt; &#123; private Pattern pattern = Pattern.compile("^(13[0-9]|14[579]|15[0-3,5-9]|16[6]|17[0135678]|18[0-9]|19[89])\\d&#123;8&#125;$"); @Override public void initialize(IsPhone constraintAnnotation) &#123; //启动时执行 &#125; /** * 自定义校验逻辑 * @param value CharSequence为校验的类型 * @param context * @return */ @Override public boolean isValid(String value, ConstraintValidatorContext context) &#123; if (value == null || value.length() == 0) &#123; return true; &#125; return pattern.matcher(value).matches(); &#125;&#125; 2.3.3 组合验证：创建两个接口表示添加时和编辑时1234567891011121314package com.littlefxc.examples.validation;/** * 添加时 * @author fengxuechao */public interface ValidatorAdd &#123;&#125;package com.littlefxc.examples.validation;/** * 编辑时 * @author fengxuechao */public interface ValidatorEdit &#123;&#125; 2.3.4 定义错误信息Spring Boot Validation约定错误信息放在resources文件夹下的ValidationMessages.properties。文件中key代表的是校验框架注解中的message属性。 123456login.id.NotNull=id不能为空login.username.NotBlank=用户名不能为空login.username.Email=用户名必须是邮箱账号login.password.NotBlank=密码不能为空login.password.Length=密码长度至少为6位login.phone.invalid="手机号格式不合法" 2.3.5 创建实体类123456789101112131415161718192021222324252627282930313233343536373839404142package com.littlefxc.examples.model;import com.littlefxc.examples.validation.IsPhone;import com.littlefxc.examples.validation.ValidatorAdd;import com.littlefxc.examples.validation.ValidatorEdit;import lombok.Data;import org.hibernate.validator.constraints.Email;import org.hibernate.validator.constraints.Length;import org.hibernate.validator.constraints.NotBlank;import javax.validation.constraints.NotNull;/** * @author fengxuechao */@Datapublic class LoginVo &#123; /** * 编辑时：不能为null */ @NotNull(message = "&#123;login.id.NotNull&#125;", groups = &#123;ValidatorEdit.class&#125;) private String id; /** * 添加时：不能为空，符合邮箱格式 * 编辑时：符合邮箱格式 */ @NotBlank(message = "&#123;login.username.NotBlank&#125;", groups = &#123;ValidatorAdd.class&#125;) @Email(message = "&#123;login.username.Email&#125;", groups = &#123;ValidatorAdd.class, ValidatorEdit.class&#125;) private String username; /** * 添加时：不能为空，密码长度至少为6位 * 编辑时：密码长度至少为6位 */ @NotBlank(message = "&#123;login.password.NotBlank&#125;", groups = &#123;ValidatorAdd.class&#125;) @Length(min = 6, message = "&#123;login.password.Length&#125;", groups = &#123;ValidatorAdd.class, ValidatorEdit.class&#125;) private String password; /** * 添加时：符合手机格式 * 编辑时：符合手机格式 */ @IsPhone(groups = &#123;ValidatorAdd.class, ValidatorEdit.class&#125;) private String phone;&#125; 2.3.6 定义控制器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package com.littlefxc.examples.controller;import com.littlefxc.examples.model.LoginVo;import com.littlefxc.examples.validation.ValidatorAdd;import com.littlefxc.examples.validation.ValidatorEdit;import org.springframework.validation.BindException;import org.springframework.validation.FieldError;import org.springframework.validation.annotation.Validated;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.HashMap;import java.util.UUID;/** * @author fengxuechao */@RestControllerpublic class ValidatorController &#123; /** * 持久化 */ private static final HashMap&lt;String, LoginVo&gt; map = new HashMap&lt;&gt;(); /** * 添加时 * * @param loginVo * @return */ @RequestMapping(value = "/save") public String save(@Validated(&#123;ValidatorAdd.class&#125;) LoginVo loginVo) &#123; loginVo.setId(UUID.randomUUID().toString().replace("-", "")); map.put(loginVo.getId(), loginVo); return "添加通过：" + loginVo.toString(); &#125; /** * 编辑时 * * @param loginVo * @return */ @RequestMapping(value = "/edit") public String edit(@Validated(&#123;ValidatorEdit.class&#125;) LoginVo loginVo) &#123; map.replace(loginVo.getId(), map.get(loginVo.getId()), loginVo); return "编辑通过：" + loginVo.toString(); &#125; /** * 列表 * * @return */ @RequestMapping(value = "/list") public HashMap&lt;String, LoginVo&gt; edit() &#123; return map; &#125; /** * 统一异常处理 * * @param ex * @return */ @ExceptionHandler(BindException.class) public String handleBindException(BindException ex) &#123; StringBuilder sb = new StringBuilder(); for (FieldError fieldError : ex.getFieldErrors()) &#123; sb.append(fieldError.getField()) .append(": ") hexo.append(fieldError.getDefaultMessage()) hexo.append(";"); &#125; return "验证失败：" + sb.toString(); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>spring-boot</tag>
        <tag>spring-boot-starter-validation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[规则引擎Drools模板编译]]></title>
    <url>%2Fpassages%2F%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8EDrools%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91%2F</url>
    <content type="text"><![CDATA[规则引擎 Drools 模板编译1.模板编译1.1依赖12345&lt;dependency&gt; &lt;groupId&gt;org.drools&lt;/groupId&gt; &lt;artifactId&gt;drools-templates&lt;/artifactId&gt; &lt;version&gt;7.7.0.Final&lt;/version&gt;&lt;/dependency&gt; 1.2建立模板新建模板文件 test.drt 12345678910111213141516template headerconditionexecutionpackage templatetemplate "this is a test" rule "test_@&#123;row.rowNumber&#125;" when @&#123;condition&#125; then System.out.println(@&#123;execution&#125;); endend template 说明规则模板主要由两部分构成： Template header 定义了在模板中使用的变量。模板中以 “template name” 开头, 以”end template” 结尾, 中间定义了模板的内容。变量占位符使用 @{variable_name} .@{row.rowNumber}是一个特殊的变量, 每次会按顺序生成一个行号, 可用于区分规则名。 1.3 渲染模板生成规则文件渲染模板的流程，先将数据封装为 DataProvider，然后通过 DataProviderCompiler 使用 DataProvider 将模板编译为 DRL。 Drools支持数组类型的DataProvider, ArrayDataProvider实现了DataProvider, 示例 1234567InputStream templateStream = DataDrivenTemplateExample.class.getResourceAsStream("/rules/SimpleTemplateExample.drt");// @&#123;row.rowNumber&#125;=数组下标, @&#123;condition&#125;=规则条件, @&#123;execution&#125;=规则动作DataProvider data = new ArrayDataProvider(new String[][]&#123; new String[]&#123;"String(this == \"规则条件\")", "\"规则动作\""&#125;&#125;);DataProviderCompiler converter = new DataProviderCompiler();String drl = converter.compile(data, templateStream); 1.4 编译规则在模板渲染、编译成规则文件后，就可以正常的编译DRL规则文件， 新建会话等。 KieHelper 是 Drools提供的工具类, 可用于编译DRL规则文件， 新建会话等。ps: 也可以使用其他的方式编译，这里只是为了简单 123456KieHelper helper = new KieHelper();helper.addContent(drl, ResourceType.DRL);KieSession kieSession = helper.build().newKieSession();kieSession.insert(new String("Hello, World!"));kieSession.fireAllRules();kieSession.dispose(); 1.5 模板编译示例1.5.1 DRT模板文件 template.drt12345678910111213141516template headerconditionexecutionpackage templatetemplate "this is a test" rule "test_@&#123;row.rowNumber&#125;" when @&#123;condition&#125; then System.out.println(@&#123;execution&#125;); endend template 1.5.2 单元测试12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Demo &#123; static KnowledgeBuilder builder;KieBase kieBase; @BeforeClass public static void beforeClass() &#123; builder = KnowledgeBuilderFactory.newKnowledgeBuilder(); &#125; @Before public void setUp() &#123; /** * 1. 从本地模板DRT文件得到输入流 * 2. 创建一个 ArrayDataProvider , 二维数组中元素按顺序与DRT文件中定义的变量一一对应 * 3. 创建一个 DataProviderCompiler 对象用compile()方法渲染, 将二维数组中的元素一一填充到DRT模板中, 得到DRL(规则)字符串 * 4. 加载DRL(规则)字符串 */ String pathToDrt = "E:\\template.drt"; try (InputStream stream = new FileInputStream(pathToDrt)) &#123; DataProvider dataProvider = new ArrayDataProvider(new String[][]&#123; new String[]&#123;"String(this == \"规则条件\")", "\"规则动作\""&#125; &#125;); DataProviderCompiler compiler = new DataProviderCompiler(); String DRL = compiler.compile(dataProvider, stream); System.out.println("-----模板DRT渲染后的DRL-----"); System.out.println(DRL); System.out.println("-----模板DRT渲染后的DRL-----"); byte[] drlBytes = DRL.getBytes("UTF-8"); Resource resourceTemplate = ResourceFactory.newByteArrayResource(drlBytes); builder.add(resourceTemplate, ResourceType.DRL); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; builder.add(resourceNative, ResourceType.DRL);// builder.add(resourceRemote, ResourceType.DRL); kieBase = builder.newKieBase(); &#125; @Test public void testTemplate() &#123; KieSession kieSession = kieBase.newKieSession(); kieSession.insert("规则条件"); kieSession.fireAllRules(); kieSession.dispose(); &#125;&#125; 1.5.3 输出 -----模板DRT渲染后的DRL----- package template rule &quot;test_0&quot; when String(this == &quot;规则条件&quot;) then System.out.println(&quot;规则动作&quot;); end -----模板DRT渲染后的DRL----- 规则动作 2 本地加载与远程加载2.1 创建本地DRL文件创建远程的DRL文件，地址为 E:\native.drl 12345678package rules.native;dialect "mvel"rule "native" when then System.out.println("本地加载成功");end 2.2 创建远程DRL文件创建远程的DRL文件，地址为 http://localhost:8761/remote.drl 12345678package rules.remote;dialect "mvel"rule "remote" when then System.out.println("远程加载成功");end 2.3 单元测试1234567891011121314151617181920212223242526272829303132public class Demo &#123; static KnowledgeBuilder builder; KieBase kieBase; @BeforeClass public static void beforeClass() &#123; builder = KnowledgeBuilderFactory.newKnowledgeBuilder(); &#125; @Before public void setUp() &#123; /** * 本地加载DRL */ Resource resourceNative = ResourceFactory.newFileResource("E:\\native.drl"); /** * 远程加载URL */ String url = "http://localhost:8761/remote.drl";Resource resourceRemote = ResourceFactory.newUrlResource(url );// 加载方式的不同builder.add(resourceNative, ResourceType.DRL);builder.add(resourceRemote, ResourceType.DRL); &#125; @Test public void testNativeAndRemote() &#123; KieSession kieSession = kieBase.newKieSession(); kieSession.fireAllRules(); kieSession.dispose(); &#125;&#125; 2.4 输出 远程加载成功本地加载成功 3 总结关键API：Resource: 资源类，规则文件的加载KnowledgeBuilder: 收集编译已经编写好的规则文件(drl) 从整体的收集、编译、执行上看，远程加载与本地加载大同小异，无非就是在使用Resource时加载规则文件上的不同。使用模板则在此基础上，需要将模板(drt)编译成规则(drl)。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>drools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文章标题]]></title>
    <url>%2Fpassages%2Fhello-world%2F</url>
    <content type="text"><![CDATA[文章摘要写在前面，支持markdown左右语法。 文章正文写在这里。 Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>文章分类</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
        <tag>更多标签</tag>
      </tags>
  </entry>
</search>
